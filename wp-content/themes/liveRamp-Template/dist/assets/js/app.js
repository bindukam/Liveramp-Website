/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(0);

var _jquery2 = _interopRequireDefault(_jquery);

var _whatInput = __webpack_require__(3);

var _whatInput2 = _interopRequireDefault(_whatInput);

var _foundationSites = __webpack_require__(4);

var _foundationSites2 = _interopRequireDefault(_foundationSites);

__webpack_require__(5);

__webpack_require__(6);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import TweenMax from "gsap/TweenMax";

window.$ = _jquery2.default;
//import "../../../node_modules/@fortawesome/fontawesome-pro/js/all.js";

// If you want to pick and choose which modules to include, comment out the above and uncomment
// the line below
//import './lib/foundation-explicit-pieces';


// un-comment to convert select menus to custom javascript menus
// converts slects into javascript selects

(0, _jquery2.default)(document).foundation();

(0, _jquery2.default)(document).ready(function () {
   console.log("ready!");

   (0, _jquery2.default)(".search-btn").click(function () {
      (0, _jquery2.default)('#searchModal').foundation('open');
   });

   (0, _jquery2.default)('.mobile-module-slider').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      autoplay: false,
      autoplaySpeed: 2000,
      mobileFirst: true,
      arrows: false,
      dots: true,
      adaptiveHeight: true,
      responsive: [{
         breakpoint: 767,
         settings: "unslick"
      }]
   });

   (0, _jquery2.default)('.full-module-slider').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      autoplay: false,
      autoplaySpeed: 2000,
      mobileFirst: true,
      arrows: false,
      dots: true,
      adaptiveHeight: true
   });

   (0, _jquery2.default)('.slider-1card').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      autoplay: false,
      autoplaySpeed: 2000,
      mobileFirst: true,
      arrows: false,
      dots: true,
      adaptiveHeight: true
   });

   (0, _jquery2.default)('.slider-1card-auto').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      autoplay: true,
      autoplaySpeed: 4000,
      mobileFirst: true,
      arrows: false,
      dots: true
   });

   (0, _jquery2.default)('.slider-3cards').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      autoplay: false,
      autoplaySpeed: 2000,
      mobileFirst: true,
      arrows: false,
      dots: true,
      adaptiveHeight: true,
      responsive: [{
         breakpoint: 1025,
         settings: {
            slidesToShow: 3
         }
      }]
   });

   (0, _jquery2.default)('.slider-2x2').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      rows: 2,
      slidesPerRow: 2,
      autoplay: false,
      autoplaySpeed: 2000,
      mobileFirst: true,
      arrows: false,
      dots: true,
      fade: true,
      adaptiveHeight: true
   });

   // Script to make a'card' clckable. makesure to add the url as a data-url="your_url_here.html" in the element.
   // to have the card open in a new window add data-blank="true"

   // remove seo links
   (0, _jquery2.default)('.seo-link').hide();

   function clickCard() {
      (0, _jquery2.default)('.seo-link').hide();

      //fix to prevent click card from firing when clicking the meta tags of the resources hero module     
      var metaclick = 0;
      (0, _jquery2.default)('.resources_hero .meta').click(function () {
         metaclick = 1;
         setTimeout(function () {
            return metaclick = 0;
         }, 100);
      });
      if (metaclick === 1) {
         return;
      }

      (0, _jquery2.default)('.click-card').click(function () {

         var url = (0, _jquery2.default)(this).data('url');
         var blank = (0, _jquery2.default)(this).data('blank');
         if (blank) {
            window.open(url);
         } else {
            window.location.href = url;
         };
      });
   }

   clickCard();

   // ==============================
   //PAGE SCROLL ANIMATION
   (0, _jquery2.default)(document).ready(function () {
      (0, _jquery2.default)('section').each(function () {
         var _win = (0, _jquery2.default)(window),
             _ths = (0, _jquery2.default)(this),
             _pos = _ths.offset().top,
             _scroll = _win.scrollTop(),
             _height = _win.height();

         // (_scroll > _pos - _height * 1) ? _ths.addClass('entrance-anim') : _ths.removeClass('entrance-anim');
         _scroll > _pos - _height * 1 ? _ths.addClass('entrance-anim') : _ths.removeClass('entrance-anim');
      });
   });

   (0, _jquery2.default)(window).scroll(function () {
      (0, _jquery2.default)('section').each(function () {
         var _win = (0, _jquery2.default)(window),
             _ths = (0, _jquery2.default)(this),
             _pos = _ths.offset().top,
             _scroll = _win.scrollTop(),
             _height = _win.height();

         _scroll > _pos - _height * .9 ? _ths.addClass('entrance-anim') : _ths.removeClass('entrance-anim');
      });
   });
});

// make $ safe to use with jquery


// footer toggle for mobile
footerMenuToggle();

function footerMenuToggle() {
   // -------------------
   var toggles = document.querySelectorAll(".footer-nav.widget_nav_menu > h6"),
       containers = document.querySelectorAll(".footer-nav.widget_nav_menu");

   toggles.forEach(function (toggle, ind) {
      return toggle.addEventListener("click", function () {
         containers[ind].classList.toggle("selected");
      });
   });
} // end footerMenuToggle function definition -------


// Reset styled menus to defaults 

// not yet built

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).
 * @version v4.3.1
 * @link https://github.com/ten1seven/what-input
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("whatInput", [], factory);
	else if(typeof exports === 'object')
		exports["whatInput"] = factory();
	else
		root["whatInput"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
	  /*
	   * variables
	   */

	  // last used input type
	  var currentInput = 'initial';

	  // last used input intent
	  var currentIntent = null;

	  // cache document.documentElement
	  var doc = document.documentElement;

	  // form input types
	  var formInputs = ['input', 'select', 'textarea'];

	  var functionList = [];

	  // list of modifier keys commonly used with the mouse and
	  // can be safely ignored to prevent false keyboard detection
	  var ignoreMap = [16, // shift
	  17, // control
	  18, // alt
	  91, // Windows key / left Apple cmd
	  93 // Windows menu / right Apple cmd
	  ];

	  // list of keys for which we change intent even for form inputs
	  var changeIntentMap = [9 // tab
	  ];

	  // mapping of events to input types
	  var inputMap = {
	    keydown: 'keyboard',
	    keyup: 'keyboard',
	    mousedown: 'mouse',
	    mousemove: 'mouse',
	    MSPointerDown: 'pointer',
	    MSPointerMove: 'pointer',
	    pointerdown: 'pointer',
	    pointermove: 'pointer',
	    touchstart: 'touch'
	  };

	  // array of all used input types
	  var inputTypes = [];

	  // boolean: true if touch buffer is active
	  var isBuffering = false;

	  // boolean: true if the page is being scrolled
	  var isScrolling = false;

	  // store current mouse position
	  var mousePos = {
	    x: null,
	    y: null
	  };

	  // map of IE 10 pointer events
	  var pointerMap = {
	    2: 'touch',
	    3: 'touch', // treat pen like touch
	    4: 'mouse'
	  };

	  var supportsPassive = false;

	  try {
	    var opts = Object.defineProperty({}, 'passive', {
	      get: function get() {
	        supportsPassive = true;
	      }
	    });

	    window.addEventListener('test', null, opts);
	  } catch (e) {}

	  /*
	   * set up
	   */

	  var setUp = function setUp() {
	    // add correct mouse wheel event mapping to `inputMap`
	    inputMap[detectWheel()] = 'mouse';

	    addListeners();
	    setInput();
	  };

	  /*
	   * events
	   */

	  var addListeners = function addListeners() {
	    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding
	    // can only demonstrate potential, but not actual, interaction
	    // and are treated separately
	    var options = supportsPassive ? { passive: true } : false;

	    // pointer events (mouse, pen, touch)
	    if (window.PointerEvent) {
	      doc.addEventListener('pointerdown', updateInput);
	      doc.addEventListener('pointermove', setIntent);
	    } else if (window.MSPointerEvent) {
	      doc.addEventListener('MSPointerDown', updateInput);
	      doc.addEventListener('MSPointerMove', setIntent);
	    } else {
	      // mouse events
	      doc.addEventListener('mousedown', updateInput);
	      doc.addEventListener('mousemove', setIntent);

	      // touch events
	      if ('ontouchstart' in window) {
	        doc.addEventListener('touchstart', touchBuffer, options);
	        doc.addEventListener('touchend', touchBuffer);
	      }
	    }

	    // mouse wheel
	    doc.addEventListener(detectWheel(), setIntent, options);

	    // keyboard events
	    doc.addEventListener('keydown', updateInput);
	    doc.addEventListener('keyup', updateInput);
	  };

	  // checks conditions before updating new input
	  var updateInput = function updateInput(event) {
	    // only execute if the touch buffer timer isn't running
	    if (!isBuffering) {
	      var eventKey = event.which;
	      var value = inputMap[event.type];
	      if (value === 'pointer') value = pointerType(event);

	      if (currentInput !== value || currentIntent !== value) {
	        var activeElem = document.activeElement;
	        var activeInput = false;
	        var notFormInput = activeElem && activeElem.nodeName && formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1;

	        if (notFormInput || changeIntentMap.indexOf(eventKey) !== -1) {
	          activeInput = true;
	        }

	        if (value === 'touch' ||
	        // ignore mouse modifier keys
	        value === 'mouse' ||
	        // don't switch if the current element is a form input
	        value === 'keyboard' && eventKey && activeInput && ignoreMap.indexOf(eventKey) === -1) {
	          // set the current and catch-all variable
	          currentInput = currentIntent = value;

	          setInput();
	        }
	      }
	    }
	  };

	  // updates the doc and `inputTypes` array with new input
	  var setInput = function setInput() {
	    doc.setAttribute('data-whatinput', currentInput);
	    doc.setAttribute('data-whatintent', currentInput);

	    if (inputTypes.indexOf(currentInput) === -1) {
	      inputTypes.push(currentInput);
	      doc.className += ' whatinput-types-' + currentInput;
	    }

	    fireFunctions('input');
	  };

	  // updates input intent for `mousemove` and `pointermove`
	  var setIntent = function setIntent(event) {
	    // test to see if `mousemove` happened relative to the screen
	    // to detect scrolling versus mousemove
	    if (mousePos['x'] !== event.screenX || mousePos['y'] !== event.screenY) {
	      isScrolling = false;

	      mousePos['x'] = event.screenX;
	      mousePos['y'] = event.screenY;
	    } else {
	      isScrolling = true;
	    }

	    // only execute if the touch buffer timer isn't running
	    // or scrolling isn't happening
	    if (!isBuffering && !isScrolling) {
	      var value = inputMap[event.type];
	      if (value === 'pointer') value = pointerType(event);

	      if (currentIntent !== value) {
	        currentIntent = value;

	        doc.setAttribute('data-whatintent', currentIntent);

	        fireFunctions('intent');
	      }
	    }
	  };

	  // buffers touch events because they frequently also fire mouse events
	  var touchBuffer = function touchBuffer(event) {
	    if (event.type === 'touchstart') {
	      isBuffering = false;

	      // set the current input
	      updateInput(event);
	    } else {
	      isBuffering = true;
	    }
	  };

	  var fireFunctions = function fireFunctions(type) {
	    for (var i = 0, len = functionList.length; i < len; i++) {
	      if (functionList[i].type === type) {
	        functionList[i].fn.call(undefined, currentIntent);
	      }
	    }
	  };

	  /*
	   * utilities
	   */

	  var pointerType = function pointerType(event) {
	    if (typeof event.pointerType === 'number') {
	      return pointerMap[event.pointerType];
	    } else {
	      // treat pen like touch
	      return event.pointerType === 'pen' ? 'touch' : event.pointerType;
	    }
	  };

	  // detect version of mouse wheel event to use
	  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel
	  var detectWheel = function detectWheel() {
	    var wheelType = void 0;

	    // Modern browsers support "wheel"
	    if ('onwheel' in document.createElement('div')) {
	      wheelType = 'wheel';
	    } else {
	      // Webkit and IE support at least "mousewheel"
	      // or assume that remaining browsers are older Firefox
	      wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
	    }

	    return wheelType;
	  };

	  var objPos = function objPos(match) {
	    for (var i = 0, len = functionList.length; i < len; i++) {
	      if (functionList[i].fn === match) {
	        return i;
	      }
	    }
	  };

	  /*
	   * init
	   */

	  // don't start script unless browser cuts the mustard
	  // (also passes if polyfills are used)
	  if ('addEventListener' in window && Array.prototype.indexOf) {
	    setUp();
	  }

	  /*
	   * api
	   */

	  return {
	    // returns string: the current input type
	    // opt: 'loose'|'strict'
	    // 'strict' (default): returns the same value as the `data-whatinput` attribute
	    // 'loose': includes `data-whatintent` value if it's more current than `data-whatinput`
	    ask: function ask(opt) {
	      return opt === 'loose' ? currentIntent : currentInput;
	    },

	    // returns array: all the detected input types
	    types: function types() {
	      return inputTypes;
	    },

	    // overwrites ignored keys with provided array
	    ignoreKeys: function ignoreKeys(arr) {
	      ignoreMap = arr;
	    },

	    // attach functions to input and intent "events"
	    // funct: function to fire on change
	    // eventType: 'input'|'intent'
	    registerOnChange: function registerOnChange(fn, eventType) {
	      functionList.push({
	        fn: fn,
	        type: eventType || 'input'
	      });
	    },

	    unRegisterOnChange: function unRegisterOnChange(fn) {
	      var position = objPos(fn);

	      if (position) {
	        functionList.splice(position, 1);
	      }
	    }
	  };
	}();

/***/ }
/******/ ])
});
;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onImagesLoaded = exports.Triggers = exports.Touch = exports.Tooltip = exports.Toggler = exports.Timer = exports.Tabs = exports.Sticky = exports.SmoothScroll = exports.Slider = exports.Reveal = exports.ResponsiveToggle = exports.ResponsiveMenu = exports.ResponsiveAccordionTabs = exports.Orbit = exports.OffCanvas = exports.Nest = exports.Move = exports.Motion = exports.MediaQuery = exports.Magellan = exports.Keyboard = exports.Interchange = exports.Foundation = exports.Equalizer = exports.DropdownMenu = exports.Dropdown = exports.Drilldown = exports.CoreUtils = exports.Core = exports.Box = exports.AccordionMenu = exports.Accordion = exports.Abide = undefined;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jquery = __webpack_require__(0);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/**
 * Returns a boolean for RTL support
 */

function rtl() {
  return (0, _jquery2.default)('html').attr('dir') === 'rtl';
}
/**
 * returns a random base-36 uid with namespacing
 * @function
 * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
 * @param {String} namespace - name of plugin to be incorporated in uid, optional.
 * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
 * @returns {String} - unique id
 */

function GetYoDigits() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 6;
  var namespace = arguments.length > 1 ? arguments[1] : undefined;
  var str = '';
  var chars = '0123456789abcdefghijklmnopqrstuvwxyz';
  var charsLength = chars.length;

  for (var i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * charsLength)];
  }

  return namespace ? "".concat(str, "-").concat(namespace) : str;
}
/**
 * Escape a string so it can be used as a regexp pattern
 * @function
 * @see https://stackoverflow.com/a/9310752/4317384
 *
 * @param {String} str - string to escape.
 * @returns {String} - escaped string
 */

function RegExpEscape(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}

function transitionend($elem) {
  var transitions = {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'otransitionend'
  };
  var elem = document.createElement('div'),
      end;

  for (var transition in transitions) {
    if (typeof elem.style[transition] !== 'undefined') {
      end = transitions[transition];
    }
  }

  if (end) {
    return end;
  } else {
    setTimeout(function () {
      $elem.triggerHandler('transitionend', [$elem]);
    }, 1);
    return 'transitionend';
  }
}
/**
 * Return an event type to listen for window load.
 *
 * If `$elem` is passed, an event will be triggered on `$elem`. If window is already loaded, the event will still be triggered.
 * If `handler` is passed, attach it to the event on `$elem`.
 * Calling `onLoad` without handler allows you to get the event type that will be triggered before attaching the handler by yourself.
 * @function
 *
 * @param {Object} [] $elem - jQuery element on which the event will be triggered if passed.
 * @param {Function} [] handler - function to attach to the event.
 * @returns {String} - event type that should or will be triggered.
 */

function onLoad($elem, handler) {
  var didLoad = document.readyState === 'complete';
  var eventType = (didLoad ? '_didLoad' : 'load') + '.zf.util.onLoad';

  var cb = function cb() {
    return $elem.triggerHandler(eventType);
  };

  if ($elem) {
    if (handler) $elem.one(eventType, handler);
    if (didLoad) setTimeout(cb);else (0, _jquery2.default)(window).one('load', cb);
  }

  return eventType;
}
/**
 * Retuns an handler for the `mouseleave` that ignore disappeared mouses.
 *
 * If the mouse "disappeared" from the document (like when going on a browser UI element, See https://git.io/zf-11410),
 * the event is ignored.
 * - If the `ignoreLeaveWindow` is `true`, the event is ignored when the user actually left the window
 *   (like by switching to an other window with [Alt]+[Tab]).
 * - If the `ignoreReappear` is `true`, the event will be ignored when the mouse will reappear later on the document
 *   outside of the element it left.
 *
 * @function
 *
 * @param {Function} [] handler - handler for the filtered `mouseleave` event to watch.
 * @param {Object} [] options - object of options:
 * - {Boolean} [false] ignoreLeaveWindow - also ignore when the user switched windows.
 * - {Boolean} [false] ignoreReappear - also ignore when the mouse reappeared outside of the element it left.
 * @returns {Function} - filtered handler to use to listen on the `mouseleave` event.
 */

function ignoreMousedisappear(handler) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$ignoreLeaveWindo = _ref.ignoreLeaveWindow,
      ignoreLeaveWindow = _ref$ignoreLeaveWindo === void 0 ? false : _ref$ignoreLeaveWindo,
      _ref$ignoreReappear = _ref.ignoreReappear,
      ignoreReappear = _ref$ignoreReappear === void 0 ? false : _ref$ignoreReappear;

  return function leaveEventHandler(eLeave) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    var callback = handler.bind.apply(handler, [this, eLeave].concat(rest)); // The mouse left: call the given callback if the mouse entered elsewhere

    if (eLeave.relatedTarget !== null) {
      return callback();
    } // Otherwise, check if the mouse actually left the window.
    // In firefox if the user switched between windows, the window sill have the focus by the time
    // the event is triggered. We have to debounce the event to test this case.


    setTimeout(function leaveEventDebouncer() {
      if (!ignoreLeaveWindow && document.hasFocus && !document.hasFocus()) {
        return callback();
      } // Otherwise, wait for the mouse to reeapear outside of the element,


      if (!ignoreReappear) {
        (0, _jquery2.default)(document).one('mouseenter', function reenterEventHandler(eReenter) {
          if (!(0, _jquery2.default)(eLeave.currentTarget).has(eReenter.target).length) {
            // Fill where the mouse finally entered.
            eLeave.relatedTarget = eReenter.target;
            callback();
          }
        });
      }
    }, 0);
  };
}

var foundation_core_utils = /*#__PURE__*/Object.freeze({
  rtl: rtl,
  GetYoDigits: GetYoDigits,
  RegExpEscape: RegExpEscape,
  transitionend: transitionend,
  onLoad: onLoad,
  ignoreMousedisappear: ignoreMousedisappear
});

// Authors & copyright Â© 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. MIT license

/* eslint-disable */

window.matchMedia || (window.matchMedia = function () {

  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium

  if (!styleMedia) {
    var style = document.createElement('style'),
        script = document.getElementsByTagName('script')[0],
        info = null;
    style.type = 'text/css';
    style.id = 'matchmediajs-test';

    if (!script) {
      document.head.appendChild(style);
    } else {
      script.parentNode.insertBefore(style, script);
    } // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers


    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;
    styleMedia = {
      matchMedium: function matchMedium(media) {
        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers

        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        } // Test if media query is true or false


        return info.width === '1px';
      }
    };
  }

  return function (media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());
/* eslint-enable */

var MediaQuery = {
  queries: [],
  current: '',

  /**
   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
   * @function
   * @private
   */
  _init: function _init() {
    // make sure the initialization is only done once when calling _init() several times
    if (this.isInitialized === true) {
      return;
    } else {
      this.isInitialized = true;
    }

    var self = this;
    var $meta = (0, _jquery2.default)('meta.foundation-mq');

    if (!$meta.length) {
      (0, _jquery2.default)('<meta class="foundation-mq">').appendTo(document.head);
    }

    var extractedStyles = (0, _jquery2.default)('.foundation-mq').css('font-family');
    var namedQueries;
    namedQueries = parseStyleToObject(extractedStyles);
    self.queries = []; // reset

    for (var key in namedQueries) {
      if (namedQueries.hasOwnProperty(key)) {
        self.queries.push({
          name: key,
          value: "only screen and (min-width: ".concat(namedQueries[key], ")")
        });
      }
    }

    this.current = this._getCurrentSize();

    this._watcher();
  },

  /**
   * Reinitializes the media query helper.
   * Useful if your CSS breakpoint configuration has just been loaded or has changed since the initialization.
   * @function
   * @private
   */
  _reInit: function _reInit() {
    this.isInitialized = false;

    this._init();
  },

  /**
   * Checks if the screen is at least as wide as a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
   */
  atLeast: function atLeast(size) {
    var query = this.get(size);

    if (query) {
      return window.matchMedia(query).matches;
    }

    return false;
  },

  /**
   * Checks if the screen is within the given breakpoint.
   * If smaller than the breakpoint of larger than its upper limit it returns false.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` otherwise.
   */
  only: function only(size) {
    return size === this._getCurrentSize();
  },

  /**
   * Checks if the screen is within a breakpoint or smaller.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's larger.
   */
  upTo: function upTo(size) {
    var nextSize = this.next(size); // If the next breakpoint does not match, the screen is smaller than
    // the upper limit of this breakpoint.

    if (nextSize) {
      return !this.atLeast(nextSize);
    } // If there is no next breakpoint, the "size" breakpoint does not have
    // an upper limit and the screen will always be within it or smaller.


    return true;
  },

  /**
   * Checks if the screen matches to a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.
   */
  is: function is(size) {
    var parts = size.trim().split(' ').filter(function (p) {
      return !!p.length;
    });

    var _parts = _slicedToArray(parts, 2),
        bpSize = _parts[0],
        _parts$ = _parts[1],
        bpModifier = _parts$ === void 0 ? '' : _parts$; // Only the breakpont


    if (bpModifier === 'only') {
      return this.only(bpSize);
    } // At least the breakpoint (included)


    if (!bpModifier || bpModifier === 'up') {
      return this.atLeast(bpSize);
    } // Up to the breakpoint (included)


    if (bpModifier === 'down') {
      return this.upTo(bpSize);
    }

    throw new Error("\n      Invalid breakpoint passed to MediaQuery.is().\n      Expected a breakpoint name formatted like \"<size> <modifier>\", got \"".concat(size, "\".\n    "));
  },

  /**
   * Gets the media query of a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to get.
   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
   */
  get: function get(size) {
    for (var i in this.queries) {
      if (this.queries.hasOwnProperty(i)) {
        var query = this.queries[i];
        if (size === query.name) return query.value;
      }
    }

    return null;
  },

  /**
   * Get the breakpoint following the given breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint.
   * @returns {String|null} - The name of the following breakpoint, or `null` if the passed breakpoint was the last one.
   */
  next: function next(size) {
    var _this = this;

    var queryIndex = this.queries.findIndex(function (q) {
      return _this._getQueryName(q) === size;
    });

    if (queryIndex === -1) {
      throw new Error("\n        Unknown breakpoint \"".concat(size, "\" passed to MediaQuery.next().\n        Ensure it is present in your Sass \"$breakpoints\" setting.\n      "));
    }

    var nextQuery = this.queries[queryIndex + 1];
    return nextQuery ? nextQuery.name : null;
  },

  /**
   * Returns the name of the breakpoint related to the given value.
   * @function
   * @private
   * @param {String|Object} value - Breakpoint name or query object.
   * @returns {String} Name of the breakpoint.
   */
  _getQueryName: function _getQueryName(value) {
    if (typeof value === 'string') return value;
    if (_typeof(value) === 'object') return value.name;
    throw new TypeError("\n      Invalid value passed to MediaQuery._getQueryName().\n      Expected a breakpoint name (String) or a breakpoint query (Object), got \"".concat(value, "\" (").concat(_typeof(value), ")\n    "));
  },

  /**
   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
   * @function
   * @private
   * @returns {String} Name of the current breakpoint.
   */
  _getCurrentSize: function _getCurrentSize() {
    var matched;

    for (var i = 0; i < this.queries.length; i++) {
      var query = this.queries[i];

      if (window.matchMedia(query.value).matches) {
        matched = query;
      }
    }

    return matched && this._getQueryName(matched);
  },

  /**
   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
   * @function
   * @private
   */
  _watcher: function _watcher() {
    var _this2 = this;

    (0, _jquery2.default)(window).off('resize.zf.mediaquery').on('resize.zf.mediaquery', function () {
      var newSize = _this2._getCurrentSize(),
          currentSize = _this2.current;

      if (newSize !== currentSize) {
        // Change the current media query
        _this2.current = newSize; // Broadcast the media query change on the window

        (0, _jquery2.default)(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);
      }
    });
  }
}; // Thank you: https://github.com/sindresorhus/query-string

function parseStyleToObject(str) {
  var styleObject = {};

  if (typeof str !== 'string') {
    return styleObject;
  }

  str = str.trim().slice(1, -1); // browsers re-quote string style values

  if (!str) {
    return styleObject;
  }

  styleObject = str.split('&').reduce(function (ret, param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = parts[0];
    var val = parts[1];
    key = decodeURIComponent(key); // missing `=` should be `null`:
    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

    val = typeof val === 'undefined' ? null : decodeURIComponent(val);

    if (!ret.hasOwnProperty(key)) {
      ret[key] = val;
    } else if (Array.isArray(ret[key])) {
      ret[key].push(val);
    } else {
      ret[key] = [ret[key], val];
    }

    return ret;
  }, {});
  return styleObject;
}

var FOUNDATION_VERSION = '6.6.3'; // Global Foundation object
// This is attached to the window, or used as a module for AMD/Browserify

var Foundation = {
  version: FOUNDATION_VERSION,

  /**
   * Stores initialized plugins.
   */
  _plugins: {},

  /**
   * Stores generated unique ids for plugin instances
   */
  _uuids: [],

  /**
   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
   * @param {Object} plugin - The constructor of the plugin.
   */
  plugin: function plugin(_plugin, name) {
    // Object key to use when adding to global Foundation object
    // Examples: Foundation.Reveal, Foundation.OffCanvas
    var className = name || functionName(_plugin); // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
    // Examples: data-reveal, data-off-canvas

    var attrName = hyphenate(className); // Add to the Foundation object and the plugins list (for reflowing)

    this._plugins[attrName] = this[className] = _plugin;
  },

  /**
   * @function
   * Populates the _uuids array with pointers to each individual plugin instance.
   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
   * Also fires the initialization event for each plugin, consolidating repetitive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @param {String} name - the name of the plugin, passed as a camelCased string.
   * @fires Plugin#init
   */
  registerPlugin: function registerPlugin(plugin, name) {
    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
    plugin.uuid = GetYoDigits(6, pluginName);

    if (!plugin.$element.attr("data-".concat(pluginName))) {
      plugin.$element.attr("data-".concat(pluginName), plugin.uuid);
    }

    if (!plugin.$element.data('zfPlugin')) {
      plugin.$element.data('zfPlugin', plugin);
    }
    /**
     * Fires when the plugin has initialized.
     * @event Plugin#init
     */

    plugin.$element.trigger("init.zf.".concat(pluginName));

    this._uuids.push(plugin.uuid);

    return;
  },

  /**
   * @function
   * Removes the plugins uuid from the _uuids array.
   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
   * Also fires the destroyed event for the plugin, consolidating repetitive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @fires Plugin#destroyed
   */
  unregisterPlugin: function unregisterPlugin(plugin) {
    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);

    plugin.$element.removeAttr("data-".concat(pluginName)).removeData('zfPlugin')
    /**
     * Fires when the plugin has been destroyed.
     * @event Plugin#destroyed
     */
    .trigger("destroyed.zf.".concat(pluginName));

    for (var prop in plugin) {
      plugin[prop] = null; //clean up script to prep for garbage collection.
    }

    return;
  },

  /**
   * @function
   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
   * @default If no argument is passed, reflow all currently active plugins.
   */
  reInit: function reInit(plugins) {
    var isJQ = plugins instanceof _jquery2.default;

    try {
      if (isJQ) {
        plugins.each(function () {
          (0, _jquery2.default)(this).data('zfPlugin')._init();
        });
      } else {
        var type = _typeof(plugins),
            _this = this,
            fns = {
          'object': function object(plgs) {
            plgs.forEach(function (p) {
              p = hyphenate(p);
              (0, _jquery2.default)('[data-' + p + ']').foundation('_init');
            });
          },
          'string': function string() {
            plugins = hyphenate(plugins);
            (0, _jquery2.default)('[data-' + plugins + ']').foundation('_init');
          },
          'undefined': function undefined$1() {
            this['object'](Object.keys(_this._plugins));
          }
        };

        fns[type](plugins);
      }
    } catch (err) {
      console.error(err);
    } finally {
      return plugins;
    }
  },

  /**
   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
   */
  reflow: function reflow(elem, plugins) {
    // If plugins is undefined, just grab everything
    if (typeof plugins === 'undefined') {
      plugins = Object.keys(this._plugins);
    } // If plugins is a string, convert it to an array with one item
    else if (typeof plugins === 'string') {
        plugins = [plugins];
      }

    var _this = this; // Iterate through each plugin


    _jquery2.default.each(plugins, function (i, name) {
      // Get the current plugin
      var plugin = _this._plugins[name]; // Localize the search to all elements inside elem, as well as elem itself, unless elem === document

      var $elem = (0, _jquery2.default)(elem).find('[data-' + name + ']').addBack('[data-' + name + ']').filter(function () {
        return typeof (0, _jquery2.default)(this).data("zfPlugin") === 'undefined';
      }); // For each plugin found, initialize it

      $elem.each(function () {
        var $el = (0, _jquery2.default)(this),
            opts = {
          reflow: true
        };

        if ($el.attr('data-options')) {
          $el.attr('data-options').split(';').forEach(function (option, _index) {
            var opt = option.split(':').map(function (el) {
              return el.trim();
            });
            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
          });
        }

        try {
          $el.data('zfPlugin', new plugin((0, _jquery2.default)(this), opts));
        } catch (er) {
          console.error(er);
        } finally {
          return;
        }
      });
    });
  },
  getFnName: functionName,
  addToJquery: function addToJquery($) {
    // TODO: consider not making this a jQuery function
    // TODO: need way to reflow vs. re-initialize

    /**
     * The Foundation jQuery method.
     * @param {String|Array} method - An action to perform on the current jQuery object.
     */
    var foundation = function foundation(method) {
      var type = _typeof(method),
          $noJS = $('.no-js');

      if ($noJS.length) {
        $noJS.removeClass('no-js');
      }

      if (type === 'undefined') {
        //needs to initialize the Foundation object, or an individual plugin.
        MediaQuery._init();

        Foundation.reflow(this);
      } else if (type === 'string') {
        //an individual method to invoke on a plugin or group of plugins
        var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary

        var plugClass = this.data('zfPlugin'); //determine the class of plugin

        if (typeof plugClass !== 'undefined' && typeof plugClass[method] !== 'undefined') {
          //make sure both the class and method exist
          if (this.length === 1) {
            //if there's only one, call it directly.
            plugClass[method].apply(plugClass, args);
          } else {
            this.each(function (i, el) {
              //otherwise loop through the jQuery collection and invoke the method on each
              plugClass[method].apply($(el).data('zfPlugin'), args);
            });
          }
        } else {
          //error for no class or no method
          throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
        }
      } else {
        //error for invalid argument type
        throw new TypeError("We're sorry, ".concat(type, " is not a valid parameter. You must use a string representing the method you wish to invoke."));
      }

      return this;
    };

    $.fn.foundation = foundation;
    return $;
  }
};
Foundation.util = {
  /**
   * Function for applying a debounce effect to a function call.
   * @function
   * @param {Function} func - Function to be called at end of timeout.
   * @param {Number} delay - Time in ms to delay the call of `func`.
   * @returns function
   */
  throttle: function throttle(func, delay) {
    var timer = null;
    return function () {
      var context = this,
          args = arguments;

      if (timer === null) {
        timer = setTimeout(function () {
          func.apply(context, args);
          timer = null;
        }, delay);
      }
    };
  }
};
window.Foundation = Foundation; // Polyfill for requestAnimationFrame

(function () {
  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
    return new Date().getTime();
  };
  var vendors = ['webkit', 'moz'];

  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
  }

  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;

    window.requestAnimationFrame = function (callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };

    window.cancelAnimationFrame = clearTimeout;
  }
  /**
   * Polyfill for performance.now, required by rAF
   */

  if (!window.performance || !window.performance.now) {
    window.performance = {
      start: Date.now(),
      now: function now() {
        return Date.now() - this.start;
      }
    };
  }
})();

if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function fNOP() {},
        fBound = function fBound() {
      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    if (this.prototype) {
      // native functions don't have a prototype
      fNOP.prototype = this.prototype;
    }

    fBound.prototype = new fNOP();
    return fBound;
  };
} // Polyfill to get the name of a function in IE9


function functionName(fn) {
  if (typeof Function.prototype.name === 'undefined') {
    var funcNameRegex = /function\s([^(]{1,})\(/;
    var results = funcNameRegex.exec(fn.toString());
    return results && results.length > 1 ? results[1].trim() : "";
  } else if (typeof fn.prototype === 'undefined') {
    return fn.constructor.name;
  } else {
    return fn.prototype.constructor.name;
  }
}

function parseValue(str) {
  if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);
  return str;
} // Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580


function hyphenate(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

var Box = {
  ImNotTouchingYou: ImNotTouchingYou,
  OverlapArea: OverlapArea,
  GetDimensions: GetDimensions,
  GetExplicitOffsets: GetExplicitOffsets
  /**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */

};

function ImNotTouchingYou(element, parent, lrOnly, tbOnly, ignoreBottom) {
  return OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) === 0;
}

function OverlapArea(element, parent, lrOnly, tbOnly, ignoreBottom) {
  var eleDims = GetDimensions(element),
      topOver,
      bottomOver,
      leftOver,
      rightOver;

  if (parent) {
    var parDims = GetDimensions(parent);
    bottomOver = parDims.height + parDims.offset.top - (eleDims.offset.top + eleDims.height);
    topOver = eleDims.offset.top - parDims.offset.top;
    leftOver = eleDims.offset.left - parDims.offset.left;
    rightOver = parDims.width + parDims.offset.left - (eleDims.offset.left + eleDims.width);
  } else {
    bottomOver = eleDims.windowDims.height + eleDims.windowDims.offset.top - (eleDims.offset.top + eleDims.height);
    topOver = eleDims.offset.top - eleDims.windowDims.offset.top;
    leftOver = eleDims.offset.left - eleDims.windowDims.offset.left;
    rightOver = eleDims.windowDims.width - (eleDims.offset.left + eleDims.width);
  }

  bottomOver = ignoreBottom ? 0 : Math.min(bottomOver, 0);
  topOver = Math.min(topOver, 0);
  leftOver = Math.min(leftOver, 0);
  rightOver = Math.min(rightOver, 0);

  if (lrOnly) {
    return leftOver + rightOver;
  }

  if (tbOnly) {
    return topOver + bottomOver;
  } // use sum of squares b/c we care about overlap area.


  return Math.sqrt(topOver * topOver + bottomOver * bottomOver + leftOver * leftOver + rightOver * rightOver);
}
/**
 * Uses native methods to return an object of dimension values.
 * @function
 * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
 * @returns {Object} - nested object of integer pixel values
 * TODO - if element is window, return only those values.
 */

function GetDimensions(elem) {
  elem = elem.length ? elem[0] : elem;

  if (elem === window || elem === document) {
    throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
  }

  var rect = elem.getBoundingClientRect(),
      parRect = elem.parentNode.getBoundingClientRect(),
      winRect = document.body.getBoundingClientRect(),
      winY = window.pageYOffset,
      winX = window.pageXOffset;
  return {
    width: rect.width,
    height: rect.height,
    offset: {
      top: rect.top + winY,
      left: rect.left + winX
    },
    parentDims: {
      width: parRect.width,
      height: parRect.height,
      offset: {
        top: parRect.top + winY,
        left: parRect.left + winX
      }
    },
    windowDims: {
      width: winRect.width,
      height: winRect.height,
      offset: {
        top: winY,
        left: winX
      }
    }
  };
}
/**
 * Returns an object of top and left integer pixel values for dynamically rendered elements,
 * such as: Tooltip, Reveal, and Dropdown. Maintained for backwards compatibility, and where
 * you don't know alignment, but generally from
 * 6.4 forward you should use GetExplicitOffsets, as GetOffsets conflates position and alignment.
 * @function
 * @param {jQuery} element - jQuery object for the element being positioned.
 * @param {jQuery} anchor - jQuery object for the element's anchor point.
 * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
 * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
 * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
 * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
 * TODO alter/rewrite to work with `em` values as well/instead of pixels
 */

function GetExplicitOffsets(element, anchor, position, alignment, vOffset, hOffset, isOverflow) {
  var $eleDims = GetDimensions(element),
      $anchorDims = anchor ? GetDimensions(anchor) : null;
  var topVal, leftVal;

  if ($anchorDims !== null) {
    // set position related attribute
    switch (position) {
      case 'top':
        topVal = $anchorDims.offset.top - ($eleDims.height + vOffset);
        break;

      case 'bottom':
        topVal = $anchorDims.offset.top + $anchorDims.height + vOffset;
        break;

      case 'left':
        leftVal = $anchorDims.offset.left - ($eleDims.width + hOffset);
        break;

      case 'right':
        leftVal = $anchorDims.offset.left + $anchorDims.width + hOffset;
        break;
    } // set alignment related attribute


    switch (position) {
      case 'top':
      case 'bottom':
        switch (alignment) {
          case 'left':
            leftVal = $anchorDims.offset.left + hOffset;
            break;

          case 'right':
            leftVal = $anchorDims.offset.left - $eleDims.width + $anchorDims.width - hOffset;
            break;

          case 'center':
            leftVal = isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2 + hOffset;
            break;
        }

        break;

      case 'right':
      case 'left':
        switch (alignment) {
          case 'bottom':
            topVal = $anchorDims.offset.top - vOffset + $anchorDims.height - $eleDims.height;
            break;

          case 'top':
            topVal = $anchorDims.offset.top + vOffset;
            break;

          case 'center':
            topVal = $anchorDims.offset.top + vOffset + $anchorDims.height / 2 - $eleDims.height / 2;
            break;
        }

        break;
    }
  }

  return {
    top: topVal,
    left: leftVal
  };
}

/**
 * Runs a callback function when images are fully loaded.
 * @param {Object} images - Image(s) to check if loaded.
 * @param {Func} callback - Function to execute when image is fully loaded.
 */

function onImagesLoaded(images, callback) {
  var unloaded = images.length;

  if (unloaded === 0) {
    callback();
  }

  images.each(function () {
    // Check if image is loaded
    if (this.complete && typeof this.naturalWidth !== 'undefined') {
      singleImageLoaded();
    } else {
      // If the above check failed, simulate loading on detached element.
      var image = new Image(); // Still count image as loaded if it finalizes with an error.

      var events = "load.zf.images error.zf.images";
      (0, _jquery2.default)(image).one(events, function me(event) {
        // Unbind the event listeners. We're using 'one' but only one of the two events will have fired.
        (0, _jquery2.default)(this).off(events, me);
        singleImageLoaded();
      });
      image.src = (0, _jquery2.default)(this).attr('src');
    }
  });

  function singleImageLoaded() {
    unloaded--;

    if (unloaded === 0) {
      callback();
    }
  }
}

/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/
var keyCodes = {
  9: 'TAB',
  13: 'ENTER',
  27: 'ESCAPE',
  32: 'SPACE',
  35: 'END',
  36: 'HOME',
  37: 'ARROW_LEFT',
  38: 'ARROW_UP',
  39: 'ARROW_RIGHT',
  40: 'ARROW_DOWN'
};
var commands = {}; // Functions pulled out to be referenceable from internals

function findFocusable($element) {
  if (!$element) {
    return false;
  }

  return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
    if (!(0, _jquery2.default)(this).is(':visible') || (0, _jquery2.default)(this).attr('tabindex') < 0) {
      return false;
    } //only have visible elements and those that have a tabindex greater or equal 0


    return true;
  });
}

function parseKey(event) {
  var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase(); // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events

  key = key.replace(/\W+/, '');
  if (event.shiftKey) key = "SHIFT_".concat(key);
  if (event.ctrlKey) key = "CTRL_".concat(key);
  if (event.altKey) key = "ALT_".concat(key); // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)

  key = key.replace(/_$/, '');
  return key;
}

var Keyboard = {
  keys: getKeyCodes(keyCodes),

  /**
   * Parses the (keyboard) event and returns a String that represents its key
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   * @param {Event} event - the event generated by the event handler
   * @return String key - String that represents the key pressed
   */
  parseKey: parseKey,

  /**
   * Handles the given (keyboard) event
   * @param {Event} event - the event generated by the event handler
   * @param {String} component - Foundation component's name, e.g. Slider or Reveal
   * @param {Objects} functions - collection of functions that are to be executed
   */
  handleKey: function handleKey(event, component, functions) {
    var commandList = commands[component],
        keyCode = this.parseKey(event),
        cmds,
        command,
        fn;
    if (!commandList) return console.warn('Component not defined!'); // Ignore the event if it was already handled

    if (event.zfIsKeyHandled === true) return; // This component does not differentiate between ltr and rtl

    if (typeof commandList.ltr === 'undefined') {
      cmds = commandList; // use plain list
    } else {
      // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
      if (rtl()) cmds = _jquery2.default.extend({}, commandList.ltr, commandList.rtl);else cmds = _jquery2.default.extend({}, commandList.rtl, commandList.ltr);
    }

    command = cmds[keyCode];
    fn = functions[command]; // Execute the handler if found

    if (fn && typeof fn === 'function') {
      var returnValue = fn.apply(); // Mark the event as "handled" to prevent future handlings

      event.zfIsKeyHandled = true; // Execute function when event was handled

      if (functions.handled || typeof functions.handled === 'function') {
        functions.handled(returnValue);
      }
    } else {
      // Execute function when event was not handled
      if (functions.unhandled || typeof functions.unhandled === 'function') {
        functions.unhandled();
      }
    }
  },

  /**
   * Finds all focusable elements within the given `$element`
   * @param {jQuery} $element - jQuery object to search within
   * @return {jQuery} $focusable - all focusable elements within `$element`
   */
  findFocusable: findFocusable,

  /**
   * Returns the component name name
   * @param {Object} component - Foundation component, e.g. Slider or Reveal
   * @return String componentName
   */
  register: function register(componentName, cmds) {
    commands[componentName] = cmds;
  },
  // TODO9438: These references to Keyboard need to not require global. Will 'this' work in this context?
  //

  /**
   * Traps the focus in the given element.
   * @param  {jQuery} $element  jQuery object to trap the foucs into.
   */
  trapFocus: function trapFocus($element) {
    var $focusable = findFocusable($element),
        $firstFocusable = $focusable.eq(0),
        $lastFocusable = $focusable.eq(-1);
    $element.on('keydown.zf.trapfocus', function (event) {
      if (event.target === $lastFocusable[0] && parseKey(event) === 'TAB') {
        event.preventDefault();
        $firstFocusable.focus();
      } else if (event.target === $firstFocusable[0] && parseKey(event) === 'SHIFT_TAB') {
        event.preventDefault();
        $lastFocusable.focus();
      }
    });
  },

  /**
   * Releases the trapped focus from the given element.
   * @param  {jQuery} $element  jQuery object to release the focus for.
   */
  releaseFocus: function releaseFocus($element) {
    $element.off('keydown.zf.trapfocus');
  }
};
/*
 * Constants for easier comparing.
 * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
 */

function getKeyCodes(kcs) {
  var k = {};

  for (var kc in kcs) {
    k[kcs[kc]] = kcs[kc];
  }

  return k;
}

/**
 * Motion module.
 * @module foundation.motion
 */

var initClasses = ['mui-enter', 'mui-leave'];
var activeClasses = ['mui-enter-active', 'mui-leave-active'];
var Motion = {
  animateIn: function animateIn(element, animation, cb) {
    animate(true, element, animation, cb);
  },
  animateOut: function animateOut(element, animation, cb) {
    animate(false, element, animation, cb);
  }
};

function Move(duration, elem, fn) {
  var anim,
      prog,
      start = null; // console.log('called');

  if (duration === 0) {
    fn.apply(elem);
    elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    return;
  }

  function move(ts) {
    if (!start) start = ts; // console.log(start, ts);

    prog = ts - start;
    fn.apply(elem);

    if (prog < duration) {
      anim = window.requestAnimationFrame(move, elem);
    } else {
      window.cancelAnimationFrame(anim);
      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    }
  }

  anim = window.requestAnimationFrame(move);
}
/**
 * Animates an element in or out using a CSS transition class.
 * @function
 * @private
 * @param {Boolean} isIn - Defines if the animation is in or out.
 * @param {Object} element - jQuery or HTML object to animate.
 * @param {String} animation - CSS class to use.
 * @param {Function} cb - Callback to run when animation is finished.
 */

function animate(isIn, element, animation, cb) {
  element = (0, _jquery2.default)(element).eq(0);
  if (!element.length) return;
  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1]; // Set up the animation

  reset();
  element.addClass(animation).css('transition', 'none');
  requestAnimationFrame(function () {
    element.addClass(initClass);
    if (isIn) element.show();
  }); // Start the animation

  requestAnimationFrame(function () {
    // will trigger the browser to synchronously calculate the style and layout
    // also called reflow or layout thrashing
    // see https://gist.github.com/paulirish/5d52fb081b3570c81e3a
    element[0].offsetWidth;
    element.css('transition', '').addClass(activeClass);
  }); // Clean up the animation when it finishes

  element.one(transitionend(element), finish); // Hides the element (for out animations), resets the element, and runs a callback

  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  } // Resets transitions and removes motion-specific classes


  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass("".concat(initClass, " ").concat(activeClass, " ").concat(animation));
  }
}

var Nest = {
  Feather: function Feather(menu) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';
    menu.attr('role', 'menubar');
    menu.find('a').attr({
      'role': 'menuitem'
    });
    var items = menu.find('li').attr({
      'role': 'none'
    }),
        subMenuClass = "is-".concat(type, "-submenu"),
        subItemClass = "".concat(subMenuClass, "-item"),
        hasSubClass = "is-".concat(type, "-submenu-parent"),
        applyAria = type !== 'accordion'; // Accordions handle their own ARIA attriutes.

    items.each(function () {
      var $item = (0, _jquery2.default)(this),
          $sub = $item.children('ul');

      if ($sub.length) {
        $item.addClass(hasSubClass);

        if (applyAria) {
          $item.attr({
            'aria-haspopup': true,
            'aria-label': $item.children('a:first').text()
          }); // Note:  Drilldowns behave differently in how they hide, and so need
          // additional attributes.  We should look if this possibly over-generalized
          // utility (Nest) is appropriate when we rework menus in 6.4

          if (type === 'drilldown') {
            $item.attr({
              'aria-expanded': false
            });
          }
        }

        $sub.addClass("submenu ".concat(subMenuClass)).attr({
          'data-submenu': '',
          'role': 'menubar'
        });

        if (type === 'drilldown') {
          $sub.attr({
            'aria-hidden': true
          });
        }
      }

      if ($item.parent('[data-submenu]').length) {
        $item.addClass("is-submenu-item ".concat(subItemClass));
      }
    });
    return;
  },
  Burn: function Burn(menu, type) {
    var //items = menu.find('li'),
    subMenuClass = "is-".concat(type, "-submenu"),
        subItemClass = "".concat(subMenuClass, "-item"),
        hasSubClass = "is-".concat(type, "-submenu-parent");
    menu.find('>li, > li > ul, .menu, .menu > li, [data-submenu] > li').removeClass("".concat(subMenuClass, " ").concat(subItemClass, " ").concat(hasSubClass, " is-submenu-item submenu is-active")).removeAttr('data-submenu').css('display', '');
  }
};

function Timer(elem, options, cb) {
  var _this = this,
      duration = options.duration,

  //options is an object for easily adding features later.
  nameSpace = Object.keys(elem.data())[0] || 'timer',
      remain = -1,
      start,
      timer;

  this.isPaused = false;

  this.restart = function () {
    remain = -1;
    clearTimeout(timer);
    this.start();
  };

  this.start = function () {
    this.isPaused = false; // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.

    clearTimeout(timer);
    remain = remain <= 0 ? duration : remain;
    elem.data('paused', false);
    start = Date.now();
    timer = setTimeout(function () {
      if (options.infinite) {
        _this.restart(); //rerun the timer.
      }

      if (cb && typeof cb === 'function') {
        cb();
      }
    }, remain);
    elem.trigger("timerstart.zf.".concat(nameSpace));
  };

  this.pause = function () {
    this.isPaused = true; //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.

    clearTimeout(timer);
    elem.data('paused', true);
    var end = Date.now();
    remain = remain - (end - start);
    elem.trigger("timerpaused.zf.".concat(nameSpace));
  };
}

var Touch = {};
var startPosX,
    startPosY,
    startTime,
    elapsedTime,
    startEvent,
    isMoving = false,
    didMoved = false;

function onTouchEnd(e) {
  this.removeEventListener('touchmove', onTouchMove);
  this.removeEventListener('touchend', onTouchEnd); // If the touch did not move, consider it as a "tap"

  if (!didMoved) {
    var tapEvent = _jquery2.default.Event('tap', startEvent || e);
    (0, _jquery2.default)(this).trigger(tapEvent);
  }

  startEvent = null;
  isMoving = false;
  didMoved = false;
}

function onTouchMove(e) {
  if (_jquery2.default.spotSwipe.preventDefault) {
    e.preventDefault();
  }

  if (isMoving) {
    var x = e.touches[0].pageX;
    var y = e.touches[0].pageY;
    var dx = startPosX - x;
    var dir;
    didMoved = true;
    elapsedTime = new Date().getTime() - startTime;

    if (Math.abs(dx) >= _jquery2.default.spotSwipe.moveThreshold && elapsedTime <= _jquery2.default.spotSwipe.timeThreshold) {
      dir = dx > 0 ? 'left' : 'right';
    } // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
    //   dir = dy > 0 ? 'down' : 'up';
    // }


    if (dir) {
      e.preventDefault();
      onTouchEnd.apply(this, arguments);
      (0, _jquery2.default)(this).trigger(_jquery2.default.Event('swipe', Object.assign({}, e)), dir).trigger(_jquery2.default.Event("swipe".concat(dir), Object.assign({}, e)));
    }
  }
}

function onTouchStart(e) {
  if (e.touches.length == 1) {
    startPosX = e.touches[0].pageX;
    startPosY = e.touches[0].pageY;
    startEvent = e;
    isMoving = true;
    didMoved = false;
    startTime = new Date().getTime();
    this.addEventListener('touchmove', onTouchMove, false);
    this.addEventListener('touchend', onTouchEnd, false);
  }
}

function init() {
  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
}

var SpotSwipe =
/*#__PURE__*/
function () {
  function SpotSwipe($) {
    _classCallCheck(this, SpotSwipe);

    this.version = '1.0.0';
    this.enabled = 'ontouchstart' in document.documentElement;
    this.preventDefault = false;
    this.moveThreshold = 75;
    this.timeThreshold = 200;
    this.$ = $;

    this._init();
  }

  _createClass(SpotSwipe, [{
    key: "_init",
    value: function _init() {
      var $ = this.$;
      $.event.special.swipe = {
        setup: init
      };
      $.event.special.tap = {
        setup: init
      };
      $.each(['left', 'up', 'down', 'right'], function () {
        $.event.special["swipe".concat(this)] = {
          setup: function setup() {
            $(this).on('swipe', $.noop);
          }
        };
      });
    }
  }]);

  return SpotSwipe;
}();
/****************************************************
 * As far as I can tell, both setupSpotSwipe and    *
 * setupTouchHandler should be idempotent,          *
 * because they directly replace functions &        *
 * values, and do not add event handlers directly.  *
 ****************************************************/

Touch.setupSpotSwipe = function ($) {
  $.spotSwipe = new SpotSwipe($);
};
/****************************************************
 * Method for adding pseudo drag events to elements *
 ***************************************************/

Touch.setupTouchHandler = function ($) {
  $.fn.addTouch = function () {
    this.each(function (i, el) {
      $(el).bind('touchstart touchmove touchend touchcancel', function (event) {
        //we pass the original event object because the jQuery event
        //object is normalized to w3c specs and does not provide the TouchList
        handleTouch(event);
      });
    });

    var handleTouch = function handleTouch(event) {
      var touches = event.changedTouches,
          first = touches[0],
          eventTypes = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup'
      },
          type = eventTypes[event.type],
          simulatedEvent;

      if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
        simulatedEvent = new window.MouseEvent(type, {
          'bubbles': true,
          'cancelable': true,
          'screenX': first.screenX,
          'screenY': first.screenY,
          'clientX': first.clientX,
          'clientY': first.clientY
        });
      } else {
        simulatedEvent = document.createEvent('MouseEvent');
        simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0
        /*left*/
        , null);
      }

      first.target.dispatchEvent(simulatedEvent);
    };
  };
};

Touch.init = function ($) {
  if (typeof $.spotSwipe === 'undefined') {
    Touch.setupSpotSwipe($);
    Touch.setupTouchHandler($);
  }
};

var MutationObserver = function () {
  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];

  for (var i = 0; i < prefixes.length; i++) {
    if ("".concat(prefixes[i], "MutationObserver") in window) {
      return window["".concat(prefixes[i], "MutationObserver")];
    }
  }

  return false;
}();

var triggers = function triggers(el, type) {
  el.data(type).split(' ').forEach(function (id) {
    (0, _jquery2.default)("#".concat(id))[type === 'close' ? 'trigger' : 'triggerHandler']("".concat(type, ".zf.trigger"), [el]);
  });
};

var Triggers = {
  Listeners: {
    Basic: {},
    Global: {}
  },
  Initializers: {}
};
Triggers.Listeners.Basic = {
  openListener: function openListener() {
    triggers((0, _jquery2.default)(this), 'open');
  },
  closeListener: function closeListener() {
    var id = (0, _jquery2.default)(this).data('close');

    if (id) {
      triggers((0, _jquery2.default)(this), 'close');
    } else {
      (0, _jquery2.default)(this).trigger('close.zf.trigger');
    }
  },
  toggleListener: function toggleListener() {
    var id = (0, _jquery2.default)(this).data('toggle');

    if (id) {
      triggers((0, _jquery2.default)(this), 'toggle');
    } else {
      (0, _jquery2.default)(this).trigger('toggle.zf.trigger');
    }
  },
  closeableListener: function closeableListener(e) {
    var animation = (0, _jquery2.default)(this).data('closable'); // Only close the first closable element. See https://git.io/zf-7833

    e.stopPropagation();

    if (animation !== '') {
      Motion.animateOut((0, _jquery2.default)(this), animation, function () {
        (0, _jquery2.default)(this).trigger('closed.zf');
      });
    } else {
      (0, _jquery2.default)(this).fadeOut().trigger('closed.zf');
    }
  },
  toggleFocusListener: function toggleFocusListener() {
    var id = (0, _jquery2.default)(this).data('toggle-focus');
    (0, _jquery2.default)("#".concat(id)).triggerHandler('toggle.zf.trigger', [(0, _jquery2.default)(this)]);
  }
}; // Elements with [data-open] will reveal a plugin that supports it when clicked.

Triggers.Initializers.addOpenListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.openListener);
  $elem.on('click.zf.trigger', '[data-open]', Triggers.Listeners.Basic.openListener);
}; // Elements with [data-close] will close a plugin that supports it when clicked.
// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.


Triggers.Initializers.addCloseListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.closeListener);
  $elem.on('click.zf.trigger', '[data-close]', Triggers.Listeners.Basic.closeListener);
}; // Elements with [data-toggle] will toggle a plugin that supports it when clicked.


Triggers.Initializers.addToggleListener = function ($elem) {
  $elem.off('click.zf.trigger', Triggers.Listeners.Basic.toggleListener);
  $elem.on('click.zf.trigger', '[data-toggle]', Triggers.Listeners.Basic.toggleListener);
}; // Elements with [data-closable] will respond to close.zf.trigger events.


Triggers.Initializers.addCloseableListener = function ($elem) {
  $elem.off('close.zf.trigger', Triggers.Listeners.Basic.closeableListener);
  $elem.on('close.zf.trigger', '[data-closeable], [data-closable]', Triggers.Listeners.Basic.closeableListener);
}; // Elements with [data-toggle-focus] will respond to coming in and out of focus


Triggers.Initializers.addToggleFocusListener = function ($elem) {
  $elem.off('focus.zf.trigger blur.zf.trigger', Triggers.Listeners.Basic.toggleFocusListener);
  $elem.on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', Triggers.Listeners.Basic.toggleFocusListener);
}; // More Global/complex listeners and triggers


Triggers.Listeners.Global = {
  resizeListener: function resizeListener($nodes) {
    if (!MutationObserver) {
      //fallback for IE 9
      $nodes.each(function () {
        (0, _jquery2.default)(this).triggerHandler('resizeme.zf.trigger');
      });
    } //trigger all listening elements and signal a resize event


    $nodes.attr('data-events', "resize");
  },
  scrollListener: function scrollListener($nodes) {
    if (!MutationObserver) {
      //fallback for IE 9
      $nodes.each(function () {
        (0, _jquery2.default)(this).triggerHandler('scrollme.zf.trigger');
      });
    } //trigger all listening elements and signal a scroll event


    $nodes.attr('data-events', "scroll");
  },
  closeMeListener: function closeMeListener(e, pluginId) {
    var plugin = e.namespace.split('.')[0];
    var plugins = (0, _jquery2.default)("[data-".concat(plugin, "]")).not("[data-yeti-box=\"".concat(pluginId, "\"]"));
    plugins.each(function () {
      var _this = (0, _jquery2.default)(this);

      _this.triggerHandler('close.zf.trigger', [_this]);
    });
  } // Global, parses whole document.

};

Triggers.Initializers.addClosemeListener = function (pluginName) {
  var yetiBoxes = (0, _jquery2.default)('[data-yeti-box]'),
      plugNames = ['dropdown', 'tooltip', 'reveal'];

  if (pluginName) {
    if (typeof pluginName === 'string') {
      plugNames.push(pluginName);
    } else if (_typeof(pluginName) === 'object' && typeof pluginName[0] === 'string') {
      plugNames = plugNames.concat(pluginName);
    } else {
      console.error('Plugin names must be strings');
    }
  }

  if (yetiBoxes.length) {
    var listeners = plugNames.map(function (name) {
      return "closeme.zf.".concat(name);
    }).join(' ');
    (0, _jquery2.default)(window).off(listeners).on(listeners, Triggers.Listeners.Global.closeMeListener);
  }
};

function debounceGlobalListener(debounce, trigger, listener) {
  var timer,
      args = Array.prototype.slice.call(arguments, 3);
  (0, _jquery2.default)(window).off(trigger).on(trigger, function (e) {
    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(function () {
      listener.apply(null, args);
    }, debounce || 10); //default time to emit scroll event
  });
}

Triggers.Initializers.addResizeListener = function (debounce) {
  var $nodes = (0, _jquery2.default)('[data-resize]');

  if ($nodes.length) {
    debounceGlobalListener(debounce, 'resize.zf.trigger', Triggers.Listeners.Global.resizeListener, $nodes);
  }
};

Triggers.Initializers.addScrollListener = function (debounce) {
  var $nodes = (0, _jquery2.default)('[data-scroll]');

  if ($nodes.length) {
    debounceGlobalListener(debounce, 'scroll.zf.trigger', Triggers.Listeners.Global.scrollListener, $nodes);
  }
};

Triggers.Initializers.addMutationEventsListener = function ($elem) {
  if (!MutationObserver) {
    return false;
  }

  var $nodes = $elem.find('[data-resize], [data-scroll], [data-mutate]'); //element callback

  var listeningElementsMutation = function listeningElementsMutation(mutationRecordsList) {
    var $target = (0, _jquery2.default)(mutationRecordsList[0].target); //trigger the event handler for the element depending on type

    switch (mutationRecordsList[0].type) {
      case "attributes":
        if ($target.attr("data-events") === "scroll" && mutationRecordsList[0].attributeName === "data-events") {
          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
        }

        if ($target.attr("data-events") === "resize" && mutationRecordsList[0].attributeName === "data-events") {
          $target.triggerHandler('resizeme.zf.trigger', [$target]);
        }

        if (mutationRecordsList[0].attributeName === "style") {
          $target.closest("[data-mutate]").attr("data-events", "mutate");
          $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
        }

        break;

      case "childList":
        $target.closest("[data-mutate]").attr("data-events", "mutate");
        $target.closest("[data-mutate]").triggerHandler('mutateme.zf.trigger', [$target.closest("[data-mutate]")]);
        break;

      default:
        return false;
      //nothing
    }
  };

  if ($nodes.length) {
    //for each element that needs to listen for resizing, scrolling, or mutation add a single observer
    for (var i = 0; i <= $nodes.length - 1; i++) {
      var elementObserver = new MutationObserver(listeningElementsMutation);
      elementObserver.observe($nodes[i], {
        attributes: true,
        childList: true,
        characterData: false,
        subtree: true,
        attributeFilter: ["data-events", "style"]
      });
    }
  }
};

Triggers.Initializers.addSimpleListeners = function () {
  var $document = (0, _jquery2.default)(document);
  Triggers.Initializers.addOpenListener($document);
  Triggers.Initializers.addCloseListener($document);
  Triggers.Initializers.addToggleListener($document);
  Triggers.Initializers.addCloseableListener($document);
  Triggers.Initializers.addToggleFocusListener($document);
};

Triggers.Initializers.addGlobalListeners = function () {
  var $document = (0, _jquery2.default)(document);
  Triggers.Initializers.addMutationEventsListener($document);
  Triggers.Initializers.addResizeListener();
  Triggers.Initializers.addScrollListener();
  Triggers.Initializers.addClosemeListener();
};

Triggers.init = function ($, Foundation) {
  onLoad($(window), function () {
    if ($.triggersInitialized !== true) {
      Triggers.Initializers.addSimpleListeners();
      Triggers.Initializers.addGlobalListeners();
      $.triggersInitialized = true;
    }
  });

  if (Foundation) {
    Foundation.Triggers = Triggers; // Legacy included to be backwards compatible for now.

    Foundation.IHearYou = Triggers.Initializers.addGlobalListeners;
  }
};

// {function} _setup (replaces previous constructor),
// {function} _destroy (replaces previous destroy)

var Plugin =
/*#__PURE__*/
function () {
  function Plugin(element, options) {
    _classCallCheck(this, Plugin);

    this._setup(element, options);

    var pluginName = getPluginName(this);
    this.uuid = GetYoDigits(6, pluginName);

    if (!this.$element.attr("data-".concat(pluginName))) {
      this.$element.attr("data-".concat(pluginName), this.uuid);
    }

    if (!this.$element.data('zfPlugin')) {
      this.$element.data('zfPlugin', this);
    }
    /**
     * Fires when the plugin has initialized.
     * @event Plugin#init
     */

    this.$element.trigger("init.zf.".concat(pluginName));
  }

  _createClass(Plugin, [{
    key: "destroy",
    value: function destroy() {
      this._destroy();

      var pluginName = getPluginName(this);
      this.$element.removeAttr("data-".concat(pluginName)).removeData('zfPlugin')
      /**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */
      .trigger("destroyed.zf.".concat(pluginName));

      for (var prop in this) {
        this[prop] = null; //clean up script to prep for garbage collection.
      }
    }
  }]);

  return Plugin;
}(); // Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580


function hyphenate$1(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}

function getPluginName(obj) {
  return hyphenate$1(obj.className);
}

/**
 * Abide module.
 * @module foundation.abide
 */

var Abide =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Abide, _Plugin);

  function Abide() {
    _classCallCheck(this, Abide);

    return _possibleConstructorReturn(this, _getPrototypeOf(Abide).apply(this, arguments));
  }

  _createClass(Abide, [{
    key: "_setup",

    /**
     * Creates a new instance of Abide.
     * @class
     * @name Abide
     * @fires Abide#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.$element = element;
      this.options = _jquery2.default.extend(true, {}, Abide.defaults, this.$element.data(), options);
      this.isEnabled = true;
      this.formnovalidate = null;
      this.className = 'Abide'; // ie9 back compat

      this._init();
    }
    /**
     * Initializes the Abide plugin and calls functions to get Abide functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      this.$inputs = _jquery2.default.merge( // Consider as input to validate:
      this.$element.find('input').not('[type="submit"]'), // * all input fields expect submit
      this.$element.find('textarea, select') // * all textareas and select fields
      );
      this.$submits = this.$element.find('[type="submit"]');
      var $globalErrors = this.$element.find('[data-abide-error]'); // Add a11y attributes to all fields

      if (this.options.a11yAttributes) {
        this.$inputs.each(function (i, input) {
          return _this2.addA11yAttributes((0, _jquery2.default)(input));
        });
        $globalErrors.each(function (i, error) {
          return _this2.addGlobalErrorA11yAttributes((0, _jquery2.default)(error));
        });
      }

      this._events();
    }
    /**
     * Initializes events for Abide.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this3 = this;

      this.$element.off('.abide').on('reset.zf.abide', function () {
        _this3.resetForm();
      }).on('submit.zf.abide', function () {
        return _this3.validateForm();
      });
      this.$submits.off('click.zf.abide keydown.zf.abide').on('click.zf.abide keydown.zf.abide', function (e) {
        if (!e.key || e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          _this3.formnovalidate = e.target.getAttribute('formnovalidate') !== null;

          _this3.$element.submit();
        }
      });

      if (this.options.validateOn === 'fieldChange') {
        this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }

      if (this.options.liveValidate) {
        this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }

      if (this.options.validateOnBlur) {
        this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {
          _this3.validateInput((0, _jquery2.default)(e.target));
        });
      }
    }
    /**
     * Calls necessary functions to update Abide upon DOM change
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      this._init();
    }
    /**
     * Checks whether the submitted form should be validated or not, consodering formnovalidate and isEnabled
     * @returns {Boolean}
     * @private
     */

  }, {
    key: "_validationIsDisabled",
    value: function _validationIsDisabled() {
      if (this.isEnabled === false) {
        // whole validation disabled
        return true;
      } else if (typeof this.formnovalidate === 'boolean') {
        // triggered by $submit
        return this.formnovalidate;
      } // triggered by Enter in non-submit input


      return this.$submits.length ? this.$submits[0].getAttribute('formnovalidate') !== null : false;
    }
    /**
     * Enables the whole validation
     */

  }, {
    key: "enableValidation",
    value: function enableValidation() {
      this.isEnabled = true;
    }
    /**
     * Disables the whole validation
     */

  }, {
    key: "disableValidation",
    value: function disableValidation() {
      this.isEnabled = false;
    }
    /**
     * Checks whether or not a form element has the required attribute and if it's checked or not
     * @param {Object} element - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "requiredCheck",
    value: function requiredCheck($el) {
      if (!$el.attr('required')) return true;
      var isGood = true;

      switch ($el[0].type) {
        case 'checkbox':
          isGood = $el[0].checked;
          break;

        case 'select':
        case 'select-one':
        case 'select-multiple':
          var opt = $el.find('option:selected');
          if (!opt.length || !opt.val()) isGood = false;
          break;

        default:
          if (!$el.val() || !$el.val().length) isGood = false;
      }

      return isGood;
    }
    /**
     * Get:
     * - Based on $el, the first element(s) corresponding to `formErrorSelector` in this order:
     *   1. The element's direct sibling('s).
     *   2. The element's parent's children.
     * - Element(s) with the attribute `[data-form-error-for]` set with the element's id.
     *
     * This allows for multiple form errors per input, though if none are found, no form errors will be shown.
     *
     * @param {Object} $el - jQuery object to use as reference to find the form error selector.
     * @param {String[]} [failedValidators] - List of failed validators.
     * @returns {Object} jQuery object with the selector.
     */

  }, {
    key: "findFormError",
    value: function findFormError($el, failedValidators) {
      var _this4 = this;

      var id = $el.length ? $el[0].id : '';
      var $error = $el.siblings(this.options.formErrorSelector);

      if (!$error.length) {
        $error = $el.parent().find(this.options.formErrorSelector);
      }

      if (id) {
        $error = $error.add(this.$element.find("[data-form-error-for=\"".concat(id, "\"]")));
      }

      if (!!failedValidators) {
        $error = $error.not('[data-form-error-on]');
        failedValidators.forEach(function (v) {
          $error = $error.add($el.siblings("[data-form-error-on=\"".concat(v, "\"]")));
          $error = $error.add(_this4.$element.find("[data-form-error-for=\"".concat(id, "\"][data-form-error-on=\"").concat(v, "\"]")));
        });
      }

      return $error;
    }
    /**
     * Get the first element in this order:
     * 2. The <label> with the attribute `[for="someInputId"]`
     * 3. The `.closest()` <label>
     *
     * @param {Object} $el - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "findLabel",
    value: function findLabel($el) {
      var id = $el[0].id;
      var $label = this.$element.find("label[for=\"".concat(id, "\"]"));

      if (!$label.length) {
        return $el.closest('label');
      }

      return $label;
    }
    /**
     * Get the set of labels associated with a set of radio els in this order
     * 2. The <label> with the attribute `[for="someInputId"]`
     * 3. The `.closest()` <label>
     *
     * @param {Object} $el - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "findRadioLabels",
    value: function findRadioLabels($els) {
      var _this5 = this;

      var labels = $els.map(function (i, el) {
        var id = el.id;

        var $label = _this5.$element.find("label[for=\"".concat(id, "\"]"));

        if (!$label.length) {
          $label = (0, _jquery2.default)(el).closest('label');
        }

        return $label[0];
      });
      return (0, _jquery2.default)(labels);
    }
    /**
     * Get the set of labels associated with a set of checkbox els in this order
     * 2. The <label> with the attribute `[for="someInputId"]`
     * 3. The `.closest()` <label>
     *
     * @param {Object} $el - jQuery object to check for required attribute
     * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
     */

  }, {
    key: "findCheckboxLabels",
    value: function findCheckboxLabels($els) {
      var _this6 = this;

      var labels = $els.map(function (i, el) {
        var id = el.id;

        var $label = _this6.$element.find("label[for=\"".concat(id, "\"]"));

        if (!$label.length) {
          $label = (0, _jquery2.default)(el).closest('label');
        }

        return $label[0];
      });
      return (0, _jquery2.default)(labels);
    }
    /**
     * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
     * @param {Object} $el - jQuery object to add the class to
     * @param {String[]} [failedValidators] - List of failed validators.
     */

  }, {
    key: "addErrorClasses",
    value: function addErrorClasses($el, failedValidators) {
      var $label = this.findLabel($el);
      var $formError = this.findFormError($el, failedValidators);

      if ($label.length) {
        $label.addClass(this.options.labelErrorClass);
      }

      if ($formError.length) {
        $formError.addClass(this.options.formErrorClass);
      }

      $el.addClass(this.options.inputErrorClass).attr({
        'data-invalid': '',
        'aria-invalid': true
      });
    }
    /**
     * Adds [for] and [role=alert] attributes to all form error targetting $el,
     * and [aria-describedby] attribute to $el toward the first form error.
     * @param {Object} $el - jQuery object
     */

  }, {
    key: "addA11yAttributes",
    value: function addA11yAttributes($el) {
      var $errors = this.findFormError($el);
      var $labels = $errors.filter('label');
      var $error = $errors.first();
      if (!$errors.length) return; // Set [aria-describedby] on the input toward the first form error if it is not set

      if (typeof $el.attr('aria-describedby') === 'undefined') {
        // Get the first error ID or create one
        var errorId = $error.attr('id');

        if (typeof errorId === 'undefined') {
          errorId = GetYoDigits(6, 'abide-error');
          $error.attr('id', errorId);
        }

        $el.attr('aria-describedby', errorId);
      }

      if ($labels.filter('[for]').length < $labels.length) {
        // Get the input ID or create one
        var elemId = $el.attr('id');

        if (typeof elemId === 'undefined') {
          elemId = GetYoDigits(6, 'abide-input');
          $el.attr('id', elemId);
        } // For each label targeting $el, set [for] if it is not set.


        $labels.each(function (i, label) {
          var $label = (0, _jquery2.default)(label);
          if (typeof $label.attr('for') === 'undefined') $label.attr('for', elemId);
        });
      } // For each error targeting $el, set [role=alert] if it is not set.


      $errors.each(function (i, label) {
        var $label = (0, _jquery2.default)(label);
        if (typeof $label.attr('role') === 'undefined') $label.attr('role', 'alert');
      }).end();
    }
    /**
     * Adds [aria-live] attribute to the given global form error $el.
     * @param {Object} $el - jQuery object to add the attribute to
     */

  }, {
    key: "addGlobalErrorA11yAttributes",
    value: function addGlobalErrorA11yAttributes($el) {
      if (typeof $el.attr('aria-live') === 'undefined') $el.attr('aria-live', this.options.a11yErrorLevel);
    }
    /**
     * Remove CSS error classes etc from an entire radio button group
     * @param {String} groupName - A string that specifies the name of a radio button group
     *
     */

  }, {
    key: "removeRadioErrorClasses",
    value: function removeRadioErrorClasses(groupName) {
      var $els = this.$element.find(":radio[name=\"".concat(groupName, "\"]"));
      var $labels = this.findRadioLabels($els);
      var $formErrors = this.findFormError($els);

      if ($labels.length) {
        $labels.removeClass(this.options.labelErrorClass);
      }

      if ($formErrors.length) {
        $formErrors.removeClass(this.options.formErrorClass);
      }

      $els.removeClass(this.options.inputErrorClass).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
    }
    /**
     * Remove CSS error classes etc from an entire checkbox group
     * @param {String} groupName - A string that specifies the name of a checkbox group
     *
     */

  }, {
    key: "removeCheckboxErrorClasses",
    value: function removeCheckboxErrorClasses(groupName) {
      var $els = this.$element.find(":checkbox[name=\"".concat(groupName, "\"]"));
      var $labels = this.findCheckboxLabels($els);
      var $formErrors = this.findFormError($els);

      if ($labels.length) {
        $labels.removeClass(this.options.labelErrorClass);
      }

      if ($formErrors.length) {
        $formErrors.removeClass(this.options.formErrorClass);
      }

      $els.removeClass(this.options.inputErrorClass).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
    }
    /**
     * Removes CSS error class as specified by the Abide settings from the label, input, and the form
     * @param {Object} $el - jQuery object to remove the class from
     */

  }, {
    key: "removeErrorClasses",
    value: function removeErrorClasses($el) {
      // radios need to clear all of the els
      if ($el[0].type == 'radio') {
        return this.removeRadioErrorClasses($el.attr('name'));
      } // checkboxes need to clear all of the els
      else if ($el[0].type == 'checkbox') {
          return this.removeCheckboxErrorClasses($el.attr('name'));
        }

      var $label = this.findLabel($el);
      var $formError = this.findFormError($el);

      if ($label.length) {
        $label.removeClass(this.options.labelErrorClass);
      }

      if ($formError.length) {
        $formError.removeClass(this.options.formErrorClass);
      }

      $el.removeClass(this.options.inputErrorClass).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
    }
    /**
     * Goes through a form to find inputs and proceeds to validate them in ways specific to their type.
     * Ignores inputs with data-abide-ignore, type="hidden" or disabled attributes set
     * @fires Abide#invalid
     * @fires Abide#valid
     * @param {Object} element - jQuery object to validate, should be an HTML input
     * @returns {Boolean} goodToGo - If the input is valid or not.
     */

  }, {
    key: "validateInput",
    value: function validateInput($el) {
      var _this7 = this;

      var clearRequire = this.requiredCheck($el),
          validator = $el.attr('data-validator'),
          failedValidators = [],
          manageErrorClasses = true; // skip validation if disabled

      if (this._validationIsDisabled()) {
        return true;
      } // don't validate ignored inputs or hidden inputs or disabled inputs


      if ($el.is('[data-abide-ignore]') || $el.is('[type="hidden"]') || $el.is('[disabled]')) {
        return true;
      }

      switch ($el[0].type) {
        case 'radio':
          this.validateRadio($el.attr('name')) || failedValidators.push('required');
          break;

        case 'checkbox':
          this.validateCheckbox($el.attr('name')) || failedValidators.push('required'); // validateCheckbox() adds/removes error classes

          manageErrorClasses = false;
          break;

        case 'select':
        case 'select-one':
        case 'select-multiple':
          clearRequire || failedValidators.push('required');
          break;

        default:
          clearRequire || failedValidators.push('required');
          this.validateText($el) || failedValidators.push('pattern');
      }

      if (validator) {
        var required = $el.attr('required') ? true : false;
        validator.split(' ').forEach(function (v) {
          _this7.options.validators[v]($el, required, $el.parent()) || failedValidators.push(v);
        });
      }

      if ($el.attr('data-equalto')) {
        this.options.validators.equalTo($el) || failedValidators.push('equalTo');
      }

      var goodToGo = failedValidators.length === 0;
      var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';

      if (goodToGo) {
        // Re-validate inputs that depend on this one with equalto
        var dependentElements = this.$element.find("[data-equalto=\"".concat($el.attr('id'), "\"]"));

        if (dependentElements.length) {
          var _this = this;

          dependentElements.each(function () {
            if ((0, _jquery2.default)(this).val()) {
              _this.validateInput((0, _jquery2.default)(this));
            }
          });
        }
      }

      if (manageErrorClasses) {
        this.removeErrorClasses($el);

        if (!goodToGo) {
          this.addErrorClasses($el, failedValidators);
        }
      }
      /**
       * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`
       * Trigger includes the DOM element of the input.
       * @event Abide#valid
       * @event Abide#invalid
       */

      $el.trigger(message, [$el]);
      return goodToGo;
    }
    /**
     * Goes through a form and if there are any invalid inputs, it will display the form error element
     * @returns {Boolean} noError - true if no errors were detected...
     * @fires Abide#formvalid
     * @fires Abide#forminvalid
     */

  }, {
    key: "validateForm",
    value: function validateForm() {
      var _this8 = this;

      var acc = [];

      var _this = this;

      var checkboxGroupName; // Remember first form submission to prevent specific checkbox validation (more than one required) until form got initially submitted

      if (!this.initialized) {
        this.initialized = true;
      } // skip validation if disabled


      if (this._validationIsDisabled()) {
        this.formnovalidate = null;
        return true;
      }

      this.$inputs.each(function () {
        // Only use one checkbox per group since validateCheckbox() iterates over all associated checkboxes
        if ((0, _jquery2.default)(this)[0].type === 'checkbox') {
          if ((0, _jquery2.default)(this).attr('name') === checkboxGroupName) return true;
          checkboxGroupName = (0, _jquery2.default)(this).attr('name');
        }

        acc.push(_this.validateInput((0, _jquery2.default)(this)));
      });
      var noError = acc.indexOf(false) === -1;
      this.$element.find('[data-abide-error]').each(function (i, elem) {
        var $elem = (0, _jquery2.default)(elem); // Ensure a11y attributes are set

        if (_this8.options.a11yAttributes) _this8.addGlobalErrorA11yAttributes($elem); // Show or hide the error

        $elem.css('display', noError ? 'none' : 'block');
      });
      /**
       * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.
       * Trigger includes the element of the form.
       * @event Abide#formvalid
       * @event Abide#forminvalid
       */

      this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);
      return noError;
    }
    /**
     * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.
     * @param {Object} $el - jQuery object to validate, should be a text input HTML element
     * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns
     * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
     */

  }, {
    key: "validateText",
    value: function validateText($el, pattern) {
      // A pattern can be passed to this function, or it will be infered from the input's "pattern" attribute, or it's "type" attribute
      pattern = pattern || $el.attr('data-pattern') || $el.attr('pattern') || $el.attr('type');
      var inputText = $el.val();
      var valid = true;

      if (inputText.length) {
        // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp
        if (this.options.patterns.hasOwnProperty(pattern)) {
          valid = this.options.patterns[pattern].test(inputText);
        } // If the pattern name isn't also the type attribute of the field, then test it as a regexp
        else if (pattern !== $el.attr('type')) {
            valid = new RegExp(pattern).test(inputText);
          }
      }

      return valid;
    }
    /**
     * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.
     * @param {String} groupName - A string that specifies the name of a radio button group
     * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
     */

  }, {
    key: "validateRadio",
    value: function validateRadio(groupName) {
      // If at least one radio in the group has the `required` attribute, the group is considered required
      // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice
      var $group = this.$element.find(":radio[name=\"".concat(groupName, "\"]"));
      var valid = false,
          required = false; // For the group to be required, at least one radio needs to be required

      $group.each(function (i, e) {
        if ((0, _jquery2.default)(e).attr('required')) {
          required = true;
        }
      });
      if (!required) valid = true;

      if (!valid) {
        // For the group to be valid, at least one radio needs to be checked
        $group.each(function (i, e) {
          if ((0, _jquery2.default)(e).prop('checked')) {
            valid = true;
          }
        });
      }

      return valid;
    }
    /**
     * Determines whether or a not a checkbox input is valid based on whether or not it is required and checked. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all checkboxes in its group.
     * @param {String} groupName - A string that specifies the name of a checkbox group
     * @returns {Boolean} Boolean value depends on whether or not at least one checkbox input has been checked (if it's required)
     */

  }, {
    key: "validateCheckbox",
    value: function validateCheckbox(groupName) {
      var _this9 = this;

      // If at least one checkbox in the group has the `required` attribute, the group is considered required
      // Per W3C spec, all checkboxes in a group should have `required`, but we're being nice
      var $group = this.$element.find(":checkbox[name=\"".concat(groupName, "\"]"));
      var valid = false,
          required = false,
          minRequired = 1,
          checked = 0; // For the group to be required, at least one checkbox needs to be required

      $group.each(function (i, e) {
        if ((0, _jquery2.default)(e).attr('required')) {
          required = true;
        }
      });
      if (!required) valid = true;

      if (!valid) {
        // Count checked checkboxes within the group
        // Use data-min-required if available (default: 1)
        $group.each(function (i, e) {
          if ((0, _jquery2.default)(e).prop('checked')) {
            checked++;
          }

          if (typeof (0, _jquery2.default)(e).attr('data-min-required') !== 'undefined') {
            minRequired = parseInt((0, _jquery2.default)(e).attr('data-min-required'));
          }
        }); // For the group to be valid, the minRequired amount of checkboxes have to be checked

        if (checked >= minRequired) {
          valid = true;
        }
      } // Skip validation if more than 1 checkbox have to be checked AND if the form hasn't got submitted yet (otherwise it will already show an error during the first fill in)


      if (this.initialized !== true && minRequired > 1) {
        return true;
      } // Refresh error class for all input


      $group.each(function (i, e) {
        if (!valid) {
          _this9.addErrorClasses((0, _jquery2.default)(e), ['required']);
        } else {
          _this9.removeErrorClasses((0, _jquery2.default)(e));
        }
      });
      return valid;
    }
    /**
     * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator="foo bar baz"` in a space separated listed.
     * @param {Object} $el - jQuery input element.
     * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.
     * @param {Boolean} required - self explanatory?
     * @returns {Boolean} - true if validations passed.
     */

  }, {
    key: "matchValidation",
    value: function matchValidation($el, validators, required) {
      var _this10 = this;

      required = required ? true : false;
      var clear = validators.split(' ').map(function (v) {
        return _this10.options.validators[v]($el, required, $el.parent());
      });
      return clear.indexOf(false) === -1;
    }
    /**
     * Resets form inputs and styles
     * @fires Abide#formreset
     */

  }, {
    key: "resetForm",
    value: function resetForm() {
      var $form = this.$element,
          opts = this.options;
      (0, _jquery2.default)(".".concat(opts.labelErrorClass), $form).not('small').removeClass(opts.labelErrorClass);
      (0, _jquery2.default)(".".concat(opts.inputErrorClass), $form).not('small').removeClass(opts.inputErrorClass);
      (0, _jquery2.default)("".concat(opts.formErrorSelector, ".").concat(opts.formErrorClass)).removeClass(opts.formErrorClass);
      $form.find('[data-abide-error]').css('display', 'none');
      (0, _jquery2.default)(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      (0, _jquery2.default)(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      (0, _jquery2.default)(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).attr({
        'data-invalid': null,
        'aria-invalid': null
      });
      /**
       * Fires when the form has been reset.
       * @event Abide#formreset
       */

      $form.trigger('formreset.zf.abide', [$form]);
    }
    /**
     * Destroys an instance of Abide.
     * Removes error styles and classes from elements, without resetting their values.
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      var _this = this;

      this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');
      this.$inputs.off('.abide').each(function () {
        _this.removeErrorClasses((0, _jquery2.default)(this));
      });
      this.$submits.off('.abide');
    }
  }]);

  return Abide;
}(Plugin);
/**
 * Default settings for plugin
 */

Abide.defaults = {
  /**
   * The default event to validate inputs. Checkboxes and radios validate immediately.
   * Remove or change this value for manual validation.
   * @option
   * @type {?string}
   * @default 'fieldChange'
   */
  validateOn: 'fieldChange',

  /**
   * Class to be applied to input labels on failed validation.
   * @option
   * @type {string}
   * @default 'is-invalid-label'
   */
  labelErrorClass: 'is-invalid-label',

  /**
   * Class to be applied to inputs on failed validation.
   * @option
   * @type {string}
   * @default 'is-invalid-input'
   */
  inputErrorClass: 'is-invalid-input',

  /**
   * Class selector to use to target Form Errors for show/hide.
   * @option
   * @type {string}
   * @default '.form-error'
   */
  formErrorSelector: '.form-error',

  /**
   * Class added to Form Errors on failed validation.
   * @option
   * @type {string}
   * @default 'is-visible'
   */
  formErrorClass: 'is-visible',

  /**
   * If true, automatically insert when possible:
   * - `[aria-describedby]` on fields
   * - `[role=alert]` on form errors and `[for]` on form error labels
   * - `[aria-live]` on global errors `[data-abide-error]` (see option `a11yErrorLevel`).
   * @option
   * @type {boolean}
   * @default true
   */
  a11yAttributes: true,

  /**
   * [aria-live] attribute value to be applied on global errors `[data-abide-error]`.
   * Options are: 'assertive', 'polite' and 'off'/null
   * @option
   * @see https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions
   * @type {string}
   * @default 'assertive'
   */
  a11yErrorLevel: 'assertive',

  /**
   * Set to true to validate text inputs on any value change.
   * @option
   * @type {boolean}
   * @default false
   */
  liveValidate: false,

  /**
   * Set to true to validate inputs on blur.
   * @option
   * @type {boolean}
   * @default false
   */
  validateOnBlur: false,
  patterns: {
    alpha: /^[a-zA-Z]+$/,
    alpha_numeric: /^[a-zA-Z0-9]+$/,
    integer: /^[-+]?\d+$/,
    number: /^[-+]?\d*(?:[\.\,]\d+)?$/,
    // amex, visa, diners
    card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|(?:222[1-9]|2[3-6][0-9]{2}|27[0-1][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
    cvv: /^([0-9]){3,4}$/,
    // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
    email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,
    // From CommonRegexJS (@talyssonoc)
    // https://github.com/talyssonoc/CommonRegexJS/blob/e2901b9f57222bc14069dc8f0598d5f412555411/lib/commonregex.js#L76
    // For more restrictive URL Regexs, see https://mathiasbynens.be/demo/url-regex.
    url: /^((?:(https?|ftps?|file|ssh|sftp):\/\/|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\))+(?:\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:\'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))$/,
    // abc.de
    domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,
    datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
    // YYYY-MM-DD
    date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
    // HH:MM:SS
    time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
    dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
    // MM/DD/YYYY
    month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
    // DD/MM/YYYY
    day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,
    // #FFF or #FFFFFF
    color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,
    // Domain || URL
    website: {
      test: function test(text) {
        return Abide.defaults.patterns['domain'].test(text) || Abide.defaults.patterns['url'].test(text);
      }
    }
  },

  /**
   * Optional validation functions to be used. `equalTo` being the only default included function.
   * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:
   * el : The jQuery element to validate.
   * required : Boolean value of the required attribute be present or not.
   * parent : The direct parent of the input.
   * @option
   */
  validators: {
    equalTo: function equalTo(el, required, parent) {
      return (0, _jquery2.default)("#".concat(el.attr('data-equalto'))).val() === el.val();
    }
  }
};

/**
 * Accordion module.
 * @module foundation.accordion
 * @requires foundation.util.keyboard
 */

var Accordion =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Accordion, _Plugin);

  function Accordion() {
    _classCallCheck(this, Accordion);

    return _possibleConstructorReturn(this, _getPrototypeOf(Accordion).apply(this, arguments));
  }

  _createClass(Accordion, [{
    key: "_setup",

    /**
     * Creates a new instance of an accordion.
     * @class
     * @name Accordion
     * @fires Accordion#init
     * @param {jQuery} element - jQuery object to make into an accordion.
     * @param {Object} options - a plain object with settings to override the default options.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Accordion.defaults, this.$element.data(), options);
      this.className = 'Accordion'; // ie9 back compat

      this._init();

      Keyboard.register('Accordion', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_DOWN': 'next',
        'ARROW_UP': 'previous'
      });
    }
    /**
     * Initializes the accordion by animating the preset active pane(s).
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      this._isInitializing = true;
      this.$element.attr('role', 'tablist');
      this.$tabs = this.$element.children('[data-accordion-item]');
      this.$tabs.attr({
        'role': 'presentation'
      });
      this.$tabs.each(function (idx, el) {
        var $el = (0, _jquery2.default)(el),
            $content = $el.children('[data-tab-content]'),
            id = $content[0].id || GetYoDigits(6, 'accordion'),
            linkId = el.id ? "".concat(el.id, "-label") : "".concat(id, "-label");
        $el.find('a:first').attr({
          'aria-controls': id,
          'role': 'tab',
          'id': linkId,
          'aria-expanded': false,
          'aria-selected': false
        });
        $content.attr({
          'role': 'tabpanel',
          'aria-labelledby': linkId,
          'aria-hidden': true,
          'id': id
        });
      });
      var $initActive = this.$element.find('.is-active').children('[data-tab-content]');

      if ($initActive.length) {
        // Save up the initial hash to return to it later when going back in history
        this._initialAnchor = $initActive.prev('a').attr('href');

        this._openSingleTab($initActive);
      }

      this._checkDeepLink = function () {
        var anchor = window.location.hash;

        if (!anchor.length) {
          // If we are still initializing and there is no anchor, then there is nothing to do
          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor

          if (_this2._initialAnchor) anchor = _this2._initialAnchor;
        }

        var $anchor = anchor && (0, _jquery2.default)(anchor);

        var $link = anchor && _this2.$element.find("[href$=\"".concat(anchor, "\"]")); // Whether the anchor element that has been found is part of this element


        var isOwnAnchor = !!($anchor.length && $link.length);

        if (isOwnAnchor) {
          // If there is an anchor for the hash, open it (if not already active)
          if ($anchor && $link && $link.length) {
            if (!$link.parent('[data-accordion-item]').hasClass('is-active')) {
              _this2._openSingleTab($anchor);
            }
          } // Otherwise, close everything
          else {
              _this2._closeAllTabs();
            } // Roll up a little to show the titles


          if (_this2.options.deepLinkSmudge) {
            onLoad((0, _jquery2.default)(window), function () {
              var offset = _this2.$element.offset();

              (0, _jquery2.default)('html, body').animate({
                scrollTop: offset.top - _this2.options.deepLinkSmudgeOffset
              }, _this2.options.deepLinkSmudgeDelay);
            });
          }
          /**
           * Fires when the plugin has deeplinked at pageload
           * @event Accordion#deeplink
           */

          _this2.$element.trigger('deeplink.zf.accordion', [$link, $anchor]);
        }
      }; //use browser to open a tab, if it exists in this tabset


      if (this.options.deepLink) {
        this._checkDeepLink();
      }

      this._events();

      this._isInitializing = false;
    }
    /**
     * Adds event handlers for items within the accordion.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$tabs.each(function () {
        var $elem = (0, _jquery2.default)(this);
        var $tabContent = $elem.children('[data-tab-content]');

        if ($tabContent.length) {
          $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {
            e.preventDefault();

            _this.toggle($tabContent);
          }).on('keydown.zf.accordion', function (e) {
            Keyboard.handleKey(e, 'Accordion', {
              toggle: function toggle() {
                _this.toggle($tabContent);
              },
              next: function next() {
                var $a = $elem.next().find('a').focus();

                if (!_this.options.multiExpand) {
                  $a.trigger('click.zf.accordion');
                }
              },
              previous: function previous() {
                var $a = $elem.prev().find('a').focus();

                if (!_this.options.multiExpand) {
                  $a.trigger('click.zf.accordion');
                }
              },
              handled: function handled() {
                e.preventDefault();
              }
            });
          });
        }
      });

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on('hashchange', this._checkDeepLink);
      }
    }
    /**
     * Toggles the selected content pane's open/close state.
     * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle($target) {
      if ($target.closest('[data-accordion]').is('[disabled]')) {
        console.info('Cannot toggle an accordion that is disabled.');
        return;
      }

      if ($target.parent().hasClass('is-active')) {
        this.up($target);
      } else {
        this.down($target);
      } //either replace or update browser history


      if (this.options.deepLink) {
        var anchor = $target.prev('a').attr('href');

        if (this.options.updateHistory) {
          history.pushState({}, '', anchor);
        } else {
          history.replaceState({}, '', anchor);
        }
      }
    }
    /**
     * Opens the accordion tab defined by `$target`.
     * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).
     * @fires Accordion#down
     * @function
     */

  }, {
    key: "down",
    value: function down($target) {
      if ($target.closest('[data-accordion]').is('[disabled]')) {
        console.info('Cannot call down on an accordion that is disabled.');
        return;
      }

      if (this.options.multiExpand) this._openTab($target);else this._openSingleTab($target);
    }
    /**
     * Closes the tab defined by `$target`.
     * It may be ignored if the Accordion options don't allow it.
     *
     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).
     * @fires Accordion#up
     * @function
     */

  }, {
    key: "up",
    value: function up($target) {
      if (this.$element.is('[disabled]')) {
        console.info('Cannot call up on an accordion that is disabled.');
        return;
      } // Don't close the item if it is already closed


      var $targetItem = $target.parent();
      if (!$targetItem.hasClass('is-active')) return; // Don't close the item if there is no other active item (unless with `allowAllClosed`)

      var $othersItems = $targetItem.siblings();
      if (!this.options.allowAllClosed && !$othersItems.hasClass('is-active')) return;

      this._closeTab($target);
    }
    /**
     * Make the tab defined by `$target` the only opened tab, closing all others tabs.
     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).
     * @function
     * @private
     */

  }, {
    key: "_openSingleTab",
    value: function _openSingleTab($target) {
      // Close all the others active tabs.
      var $activeContents = this.$element.children('.is-active').children('[data-tab-content]');

      if ($activeContents.length) {
        this._closeTab($activeContents.not($target));
      } // Then open the target.


      this._openTab($target);
    }
    /**
     * Opens the tab defined by `$target`.
     * @param {jQuery} $target - Accordion tab to open (`.accordion-content`).
     * @fires Accordion#down
     * @function
     * @private
     */

  }, {
    key: "_openTab",
    value: function _openTab($target) {
      var _this3 = this;

      var $targetItem = $target.parent();
      var targetContentId = $target.attr('aria-labelledby');
      $target.attr('aria-hidden', false);
      $targetItem.addClass('is-active');
      (0, _jquery2.default)("#".concat(targetContentId)).attr({
        'aria-expanded': true,
        'aria-selected': true
      });
      $target.finish().slideDown(this.options.slideSpeed, function () {
        /**
         * Fires when the tab is done opening.
         * @event Accordion#down
         */
        _this3.$element.trigger('down.zf.accordion', [$target]);
      });
    }
    /**
     * Closes the tab defined by `$target`.
     * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).
     * @fires Accordion#up
     * @function
     * @private
     */

  }, {
    key: "_closeTab",
    value: function _closeTab($target) {
      var _this4 = this;

      var $targetItem = $target.parent();
      var targetContentId = $target.attr('aria-labelledby');
      $target.attr('aria-hidden', true);
      $targetItem.removeClass('is-active');
      (0, _jquery2.default)("#".concat(targetContentId)).attr({
        'aria-expanded': false,
        'aria-selected': false
      });
      $target.finish().slideUp(this.options.slideSpeed, function () {
        /**
         * Fires when the tab is done collapsing up.
         * @event Accordion#up
         */
        _this4.$element.trigger('up.zf.accordion', [$target]);
      });
    }
    /**
     * Closes all active tabs
     * @fires Accordion#up
     * @function
     * @private
     */

  }, {
    key: "_closeAllTabs",
    value: function _closeAllTabs() {
      var $activeTabs = this.$element.children('.is-active').children('[data-tab-content]');

      if ($activeTabs.length) {
        this._closeTab($activeTabs);
      }
    }
    /**
     * Destroys an instance of an accordion.
     * @fires Accordion#destroyed
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');
      this.$element.find('a').off('.zf.accordion');

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).off('hashchange', this._checkDeepLink);
      }
    }
  }]);

  return Accordion;
}(Plugin);

Accordion.defaults = {
  /**
   * Amount of time to animate the opening of an accordion pane.
   * @option
   * @type {number}
   * @default 250
   */
  slideSpeed: 250,

  /**
   * Allow the accordion to have multiple open panes.
   * @option
   * @type {boolean}
   * @default false
   */
  multiExpand: false,

  /**
   * Allow the accordion to close all panes.
   * @option
   * @type {boolean}
   * @default false
   */
  allowAllClosed: false,

  /**
   * Link the location hash to the open pane.
   * Set the location hash when the opened pane changes, and open and scroll to the corresponding pane when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the accordion panel is visible
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinkSmudge: false,

  /**
   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment
   * @option
   * @type {number}
   * @default 300
   */
  deepLinkSmudgeDelay: 300,

  /**
   * If `deepLinkSmudge` is enabled, the offset for scrollToTtop to prevent overlap by a sticky element at the top of the page
   * @option
   * @type {number}
   * @default 0
   */
  deepLinkSmudgeOffset: 0,

  /**
   * If `deepLink` is enabled, update the browser history with the open accordion
   * @option
   * @type {boolean}
   * @default false
   */
  updateHistory: false
};

/**
 * AccordionMenu module.
 * @module foundation.accordionMenu
 * @requires foundation.util.keyboard
 * @requires foundation.util.nest
 */

var AccordionMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(AccordionMenu, _Plugin);

  function AccordionMenu() {
    _classCallCheck(this, AccordionMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(AccordionMenu).apply(this, arguments));
  }

  _createClass(AccordionMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of an accordion menu.
     * @class
     * @name AccordionMenu
     * @fires AccordionMenu#init
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, AccordionMenu.defaults, this.$element.data(), options);
      this.className = 'AccordionMenu'; // ie9 back compat

      this._init();

      Keyboard.register('AccordionMenu', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ARROW_RIGHT': 'open',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'close',
        'ESCAPE': 'closeAll'
      });
    }
    /**
     * Initializes the accordion menu by hiding all nested menus.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'accordion');

      var _this = this;

      this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');

      this.$element.attr({
        'role': 'tree',
        'aria-multiselectable': this.options.multiOpen
      });
      this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');
      this.$menuLinks.each(function () {
        var linkId = this.id || GetYoDigits(6, 'acc-menu-link'),
            $elem = (0, _jquery2.default)(this),
            $sub = $elem.children('[data-submenu]'),
            subId = $sub[0].id || GetYoDigits(6, 'acc-menu'),
            isActive = $sub.hasClass('is-active');

        if (_this.options.parentLink) {
          var $anchor = $elem.children('a');
          $anchor.clone().prependTo($sub).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-accordion-submenu-item"></li>');
        }

        if (_this.options.submenuToggle) {
          $elem.addClass('has-submenu-toggle');
          $elem.children('a').after('<button id="' + linkId + '" class="submenu-toggle" aria-controls="' + subId + '" aria-expanded="' + isActive + '" title="' + _this.options.submenuToggleText + '"><span class="submenu-toggle-text">' + _this.options.submenuToggleText + '</span></button>');
        } else {
          $elem.attr({
            'aria-controls': subId,
            'aria-expanded': isActive,
            'id': linkId
          });
        }

        $sub.attr({
          'aria-labelledby': linkId,
          'aria-hidden': !isActive,
          'role': 'group',
          'id': subId
        });
      });
      this.$element.find('li').attr({
        'role': 'treeitem'
      });
      var initPanes = this.$element.find('.is-active');

      if (initPanes.length) {
        initPanes.each(function () {
          _this.down((0, _jquery2.default)(this));
        });
      }

      this._events();
    }
    /**
     * Adds event handlers for items within the menu.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$element.find('li').each(function () {
        var $submenu = (0, _jquery2.default)(this).children('[data-submenu]');

        if ($submenu.length) {
          if (_this.options.submenuToggle) {
            (0, _jquery2.default)(this).children('.submenu-toggle').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              _this.toggle($submenu);
            });
          } else {
            (0, _jquery2.default)(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
              e.preventDefault();

              _this.toggle($submenu);
            });
          }
        }
      }).on('keydown.zf.accordionMenu', function (e) {
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('ul').children('li'),
            $prevElement,
            $nextElement,
            $target = $element.children('[data-submenu]');
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();
            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();

            if ((0, _jquery2.default)(this).children('[data-submenu]:visible').length) {
              // has open sub menu
              $nextElement = $element.find('li:first-child').find('a').first();
            }

            if ((0, _jquery2.default)(this).is(':first-child')) {
              // is first element of sub menu
              $prevElement = $element.parents('li').first().find('a').first();
            } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {
              // if previous element has open sub menu
              $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();
            }

            if ((0, _jquery2.default)(this).is(':last-child')) {
              // is last element of sub menu
              $nextElement = $element.parents('li').first().next('li').find('a').first();
            }

            return;
          }
        });
        Keyboard.handleKey(e, 'AccordionMenu', {
          open: function open() {
            if ($target.is(':hidden')) {
              _this.down($target);

              $target.find('li').first().find('a').first().focus();
            }
          },
          close: function close() {
            if ($target.length && !$target.is(':hidden')) {
              // close active sub of this item
              _this.up($target);
            } else if ($element.parent('[data-submenu]').length) {
              // close currently open sub
              _this.up($element.parent('[data-submenu]'));

              $element.parents('li').first().find('a').first().focus();
            }
          },
          up: function up() {
            $prevElement.focus();
            return true;
          },
          down: function down() {
            $nextElement.focus();
            return true;
          },
          toggle: function toggle() {
            if (_this.options.submenuToggle) {
              return false;
            }

            if ($element.children('[data-submenu]').length) {
              _this.toggle($element.children('[data-submenu]'));

              return true;
            }
          },
          closeAll: function closeAll() {
            _this.hideAll();
          },
          handled: function handled(preventDefault) {
            if (preventDefault) {
              e.preventDefault();
            }
          }
        });
      }); //.attr('tabindex', 0);
    }
    /**
     * Closes all panes of the menu.
     * @function
     */

  }, {
    key: "hideAll",
    value: function hideAll() {
      this.up(this.$element.find('[data-submenu]'));
    }
    /**
     * Opens all panes of the menu.
     * @function
     */

  }, {
    key: "showAll",
    value: function showAll() {
      this.down(this.$element.find('[data-submenu]'));
    }
    /**
     * Toggles the open/close state of a submenu.
     * @function
     * @param {jQuery} $target - the submenu to toggle
     */

  }, {
    key: "toggle",
    value: function toggle($target) {
      if (!$target.is(':animated')) {
        if (!$target.is(':hidden')) {
          this.up($target);
        } else {
          this.down($target);
        }
      }
    }
    /**
     * Opens the sub-menu defined by `$target`.
     * @param {jQuery} $target - Sub-menu to open.
     * @fires AccordionMenu#down
     */

  }, {
    key: "down",
    value: function down($target) {
      var _this2 = this;

      // If having multiple submenus active is disabled, close all the submenus
      // that are not parents or children of the targeted submenu.
      if (!this.options.multiOpen) {
        // The "branch" of the targetted submenu, from the component root to
        // the active submenus nested in it.
        var $targetBranch = $target.parentsUntil(this.$element).add($target).add($target.find('.is-active')); // All the active submenus that are not in the branch.

        var $othersActiveSubmenus = this.$element.find('.is-active').not($targetBranch);
        this.up($othersActiveSubmenus);
      }

      $target.addClass('is-active').attr({
        'aria-hidden': false
      });

      if (this.options.submenuToggle) {
        $target.prev('.submenu-toggle').attr({
          'aria-expanded': true
        });
      } else {
        $target.parent('.is-accordion-submenu-parent').attr({
          'aria-expanded': true
        });
      }

      $target.slideDown(this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done opening.
         * @event AccordionMenu#down
         */
        _this2.$element.trigger('down.zf.accordionMenu', [$target]);
      });
    }
    /**
     * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
     * @param {jQuery} $target - Sub-menu to close.
     * @fires AccordionMenu#up
     */

  }, {
    key: "up",
    value: function up($target) {
      var _this3 = this;

      var $submenus = $target.find('[data-submenu]');
      var $allmenus = $target.add($submenus);
      $submenus.slideUp(0);
      $allmenus.removeClass('is-active').attr('aria-hidden', true);

      if (this.options.submenuToggle) {
        $allmenus.prev('.submenu-toggle').attr('aria-expanded', false);
      } else {
        $allmenus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);
      }

      $target.slideUp(this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done collapsing up.
         * @event AccordionMenu#up
         */
        _this3.$element.trigger('up.zf.accordionMenu', [$target]);
      });
    }
    /**
     * Destroys an instance of accordion menu.
     * @fires AccordionMenu#destroyed
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find('[data-submenu]').slideDown(0).css('display', '');
      this.$element.find('a').off('click.zf.accordionMenu');
      this.$element.find('[data-is-parent-link]').detach();

      if (this.options.submenuToggle) {
        this.$element.find('.has-submenu-toggle').removeClass('has-submenu-toggle');
        this.$element.find('.submenu-toggle').remove();
      }

      Nest.Burn(this.$element, 'accordion');
    }
  }]);

  return AccordionMenu;
}(Plugin);

AccordionMenu.defaults = {
  /**
   * Adds the parent link to the submenu.
   * @option
   * @type {boolean}
   * @default false
   */
  parentLink: false,

  /**
   * Amount of time to animate the opening of a submenu in ms.
   * @option
   * @type {number}
   * @default 250
   */
  slideSpeed: 250,

  /**
   * Adds a separate submenu toggle button. This allows the parent item to have a link.
   * @option
   * @example true
   */
  submenuToggle: false,

  /**
   * The text used for the submenu toggle if enabled. This is used for screen readers only.
   * @option
   * @example true
   */
  submenuToggleText: 'Toggle menu',

  /**
   * Allow the menu to have multiple open panes.
   * @option
   * @type {boolean}
   * @default true
   */
  multiOpen: true
};

/**
 * Drilldown module.
 * @module foundation.drilldown
 * @requires foundation.util.keyboard
 * @requires foundation.util.nest
 * @requires foundation.util.box
 */

var Drilldown =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Drilldown, _Plugin);

  function Drilldown() {
    _classCallCheck(this, Drilldown);

    return _possibleConstructorReturn(this, _getPrototypeOf(Drilldown).apply(this, arguments));
  }

  _createClass(Drilldown, [{
    key: "_setup",

    /**
     * Creates a new instance of a drilldown menu.
     * @class
     * @name Drilldown
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Drilldown.defaults, this.$element.data(), options);
      this.className = 'Drilldown'; // ie9 back compat

      this._init();

      Keyboard.register('Drilldown', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close',
        'TAB': 'down',
        'SHIFT_TAB': 'up'
      });
    }
    /**
     * Initializes the drilldown by creating jQuery collections of elements
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'drilldown');

      if (this.options.autoApplyClass) {
        this.$element.addClass('drilldown');
      }

      this.$element.attr({
        'role': 'tree',
        'aria-multiselectable': false
      });
      this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');
      this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]').attr('role', 'group');
      this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'treeitem').find('a'); // Set the main menu as current by default (unless a submenu is selected)
      // Used to set the wrapper height when the drilldown is closed/reopened from any (sub)menu

      this.$currentMenu = this.$element;
      this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || GetYoDigits(6, 'drilldown'));

      this._prepareMenu();

      this._registerEvents();

      this._keyboardEvents();
    }
    /**
     * prepares drilldown menu by setting attributes to links and elements
     * sets a min height to prevent content jumping
     * wraps the element if not already wrapped
     * @private
     * @function
     */

  }, {
    key: "_prepareMenu",
    value: function _prepareMenu() {
      var _this = this; // if(!this.options.holdOpen){
      //   this._menuLinkEvents();
      // }


      this.$submenuAnchors.each(function () {
        var $link = (0, _jquery2.default)(this);
        var $sub = $link.parent();

        if (_this.options.parentLink) {
          $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li data-is-parent-link class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="none"></li>');
        }

        $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);
        $link.children('[data-submenu]').attr({
          'aria-hidden': true,
          'tabindex': 0,
          'role': 'group'
        });

        _this._events($link);
      });
      this.$submenus.each(function () {
        var $menu = (0, _jquery2.default)(this),
            $back = $menu.find('.js-drilldown-back');

        if (!$back.length) {
          switch (_this.options.backButtonPosition) {
            case "bottom":
              $menu.append(_this.options.backButton);
              break;

            case "top":
              $menu.prepend(_this.options.backButton);
              break;

            default:
              console.error("Unsupported backButtonPosition value '" + _this.options.backButtonPosition + "'");
          }
        }

        _this._back($menu);
      });
      this.$submenus.addClass('invisible');

      if (!this.options.autoHeight) {
        this.$submenus.addClass('drilldown-submenu-cover-previous');
      } // create a wrapper on element if it doesn't exist.


      if (!this.$element.parent().hasClass('is-drilldown')) {
        this.$wrapper = (0, _jquery2.default)(this.options.wrapper).addClass('is-drilldown');
        if (this.options.animateHeight) this.$wrapper.addClass('animate-height');
        this.$element.wrap(this.$wrapper);
      } // set wrapper


      this.$wrapper = this.$element.parent();
      this.$wrapper.css(this._getMaxDims());
    }
  }, {
    key: "_resize",
    value: function _resize() {
      this.$wrapper.css({
        'max-width': 'none',
        'min-height': 'none'
      }); // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths

      this.$wrapper.css(this._getMaxDims());
    }
    /**
     * Adds event handlers to elements in the menu.
     * @function
     * @private
     * @param {jQuery} $elem - the current menu item to add handlers to.
     */

  }, {
    key: "_events",
    value: function _events($elem) {
      var _this = this;

      $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
        if ((0, _jquery2.default)(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {
          e.preventDefault();
        } // if(e.target !== e.currentTarget.firstElementChild){
        //   return false;
        // }


        _this._show($elem.parent('li'));

        if (_this.options.closeOnClick) {
          var $body = (0, _jquery2.default)('body');
          $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {
            if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target)) {
              return;
            }

            e.preventDefault();

            _this._hideAll();

            $body.off('.zf.drilldown');
          });
        }
      });
    }
    /**
     * Adds event handlers to the menu element.
     * @function
     * @private
     */

  }, {
    key: "_registerEvents",
    value: function _registerEvents() {
      if (this.options.scrollTop) {
        this._bindHandler = this._scrollTop.bind(this);
        this.$element.on('open.zf.drilldown hide.zf.drilldown close.zf.drilldown closed.zf.drilldown', this._bindHandler);
      }

      this.$element.on('mutateme.zf.trigger', this._resize.bind(this));
    }
    /**
     * Scroll to Top of Element or data-scroll-top-element
     * @function
     * @fires Drilldown#scrollme
     */

  }, {
    key: "_scrollTop",
    value: function _scrollTop() {
      var _this = this;

      var $scrollTopElement = _this.options.scrollTopElement != '' ? (0, _jquery2.default)(_this.options.scrollTopElement) : _this.$element,
          scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset, 10);
      (0, _jquery2.default)('html, body').stop(true).animate({
        scrollTop: scrollPos
      }, _this.options.animationDuration, _this.options.animationEasing, function () {
        /**
          * Fires after the menu has scrolled
          * @event Drilldown#scrollme
          */
        if (this === (0, _jquery2.default)('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');
      });
    }
    /**
     * Adds keydown event listener to `li`'s in the menu.
     * @private
     */

  }, {
    key: "_keyboardEvents",
    value: function _keyboardEvents() {
      var _this = this;

      this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('li').parent('ul').children('li').children('a'),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(Math.max(0, i - 1));
            $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
            return;
          }
        });
        Keyboard.handleKey(e, 'Drilldown', {
          next: function next() {
            if ($element.is(_this.$submenuAnchors)) {
              _this._show($element.parent('li'));

              $element.parent('li').one(transitionend($element), function () {
                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();
              });
              return true;
            }
          },
          previous: function previous() {
            _this._hide($element.parent('li').parent('ul'));

            $element.parent('li').parent('ul').one(transitionend($element), function () {
              setTimeout(function () {
                $element.parent('li').parent('ul').parent('li').children('a').first().focus();
              }, 1);
            });
            return true;
          },
          up: function up() {
            $prevElement.focus(); // Don't tap focus on first element in root ul

            return !$element.is(_this.$element.find('> li:first-child > a'));
          },
          down: function down() {
            $nextElement.focus(); // Don't tap focus on last element in root ul

            return !$element.is(_this.$element.find('> li:last-child > a'));
          },
          close: function close() {
            // Don't close on element in root ul
            if (!$element.is(_this.$element.find('> li > a'))) {
              _this._hide($element.parent().parent());

              $element.parent().parent().siblings('a').focus();
            }
          },
          open: function open() {
            if (_this.options.parentLink && $element.attr('href')) {
              // Link with href
              return false;
            } else if (!$element.is(_this.$menuItems)) {
              // not menu item means back button
              _this._hide($element.parent('li').parent('ul'));

              $element.parent('li').parent('ul').one(transitionend($element), function () {
                setTimeout(function () {
                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();
                }, 1);
              });
              return true;
            } else if ($element.is(_this.$submenuAnchors)) {
              // Sub menu item
              _this._show($element.parent('li'));

              $element.parent('li').one(transitionend($element), function () {
                $element.parent('li').find('ul li a').not('.js-drilldown-back a').first().focus();
              });
              return true;
            }
          },
          handled: function handled(preventDefault) {
            if (preventDefault) {
              e.preventDefault();
            }
          }
        });
      }); // end keyboardAccess
    }
    /**
     * Closes all open elements, and returns to root menu.
     * @function
     * @fires Drilldown#close
     * @fires Drilldown#closed
     */

  }, {
    key: "_hideAll",
    value: function _hideAll() {
      var _this2 = this;

      var $elem = this.$element.find('.is-drilldown-submenu.is-active');
      $elem.addClass('is-closing');

      if (this.options.autoHeight) {
        var calcHeight = $elem.parent().closest('ul').data('calcHeight');
        this.$wrapper.css({
          height: calcHeight
        });
      }
      /**
       * Fires when the menu is closing.
       * @event Drilldown#close
       */

      this.$element.trigger('close.zf.drilldown');
      $elem.one(transitionend($elem), function () {
        $elem.removeClass('is-active is-closing');
        /**
         * Fires when the menu is fully closed.
         * @event Drilldown#closed
         */

        _this2.$element.trigger('closed.zf.drilldown');
      });
    }
    /**
     * Adds event listener for each `back` button, and closes open menus.
     * @function
     * @fires Drilldown#back
     * @param {jQuery} $elem - the current sub-menu to add `back` event.
     */

  }, {
    key: "_back",
    value: function _back($elem) {
      var _this = this;

      $elem.off('click.zf.drilldown');
      $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {
        // console.log('mouseup on back');
        _this._hide($elem); // If there is a parent submenu, call show


        var parentSubMenu = $elem.parent('li').parent('ul').parent('li');

        if (parentSubMenu.length) {
          _this._show(parentSubMenu);
        }
      });
    }
    /**
     * Adds event listener to menu items w/o submenus to close open menus on click.
     * @function
     * @private
     */

  }, {
    key: "_menuLinkEvents",
    value: function _menuLinkEvents() {
      var _this = this;

      this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
        setTimeout(function () {
          _this._hideAll();
        }, 0);
      });
    }
    /**
     * Sets the CSS classes for submenu to show it.
     * @function
     * @private
     * @param {jQuery} $elem - the target submenu (`ul` tag)
     * @param {boolean} trigger - trigger drilldown event
     */

  }, {
    key: "_setShowSubMenuClasses",
    value: function _setShowSubMenuClasses($elem, trigger) {
      $elem.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);
      $elem.parent('li').attr('aria-expanded', true);

      if (trigger === true) {
        this.$element.trigger('open.zf.drilldown', [$elem]);
      }
    }
    /**
     * Sets the CSS classes for submenu to hide it.
     * @function
     * @private
     * @param {jQuery} $elem - the target submenu (`ul` tag)
     * @param {boolean} trigger - trigger drilldown event
     */

  }, {
    key: "_setHideSubMenuClasses",
    value: function _setHideSubMenuClasses($elem, trigger) {
      $elem.removeClass('is-active').addClass('invisible').attr('aria-hidden', true);
      $elem.parent('li').attr('aria-expanded', false);

      if (trigger === true) {
        $elem.trigger('hide.zf.drilldown', [$elem]);
      }
    }
    /**
     * Opens a specific drilldown (sub)menu no matter which (sub)menu in it is currently visible.
     * Compared to _show() this lets you jump into any submenu without clicking through every submenu on the way to it.
     * @function
     * @fires Drilldown#open
     * @param {jQuery} $elem - the target (sub)menu (`ul` tag)
     * @param {boolean} autoFocus - if true the first link in the target (sub)menu gets auto focused
     */

  }, {
    key: "_showMenu",
    value: function _showMenu($elem, autoFocus) {
      var _this = this; // Reset drilldown


      var $expandedSubmenus = this.$element.find('li[aria-expanded="true"] > ul[data-submenu]');
      $expandedSubmenus.each(function (index) {
        _this._setHideSubMenuClasses((0, _jquery2.default)(this));
      }); // Save the menu as the currently displayed one.

      this.$currentMenu = $elem; // If target menu is root, focus first link & exit

      if ($elem.is('[data-drilldown]')) {
        if (autoFocus === true) $elem.find('li[role="treeitem"] > a').first().focus();
        if (this.options.autoHeight) this.$wrapper.css('height', $elem.data('calcHeight'));
        return;
      } // Find all submenus on way to root incl. the element itself


      var $submenus = $elem.children().first().parentsUntil('[data-drilldown]', '[data-submenu]'); // Open target menu and all submenus on its way to root

      $submenus.each(function (index) {
        // Update height of first child (target menu) if autoHeight option true
        if (index === 0 && _this.options.autoHeight) {
          _this.$wrapper.css('height', (0, _jquery2.default)(this).data('calcHeight'));
        }

        var isLastChild = index == $submenus.length - 1; // Add transitionsend listener to last child (root due to reverse order) to open target menu's first link
        // Last child makes sure the event gets always triggered even if going through several menus

        if (isLastChild === true) {
          (0, _jquery2.default)(this).one(transitionend((0, _jquery2.default)(this)), function () {
            if (autoFocus === true) {
              $elem.find('li[role="treeitem"] > a').first().focus();
            }
          });
        }

        _this._setShowSubMenuClasses((0, _jquery2.default)(this), isLastChild);
      });
    }
    /**
     * Opens a submenu.
     * @function
     * @fires Drilldown#open
     * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.
     */

  }, {
    key: "_show",
    value: function _show($elem) {
      var $submenu = $elem.children('[data-submenu]');
      $elem.attr('aria-expanded', true);
      this.$currentMenu = $submenu;
      $submenu.addClass('is-active').removeClass('invisible').attr('aria-hidden', false);

      if (this.options.autoHeight) {
        this.$wrapper.css({
          height: $submenu.data('calcHeight')
        });
      }
      /**
       * Fires when the submenu has opened.
       * @event Drilldown#open
       */

      this.$element.trigger('open.zf.drilldown', [$elem]);
    }
    /**
     * Hides a submenu
     * @function
     * @fires Drilldown#hide
     * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.
     */

  }, {
    key: "_hide",
    value: function _hide($elem) {
      if (this.options.autoHeight) this.$wrapper.css({
        height: $elem.parent().closest('ul').data('calcHeight')
      });

      $elem.parent('li').attr('aria-expanded', false);
      $elem.attr('aria-hidden', true);
      $elem.addClass('is-closing').one(transitionend($elem), function () {
        $elem.removeClass('is-active is-closing');
        $elem.blur().addClass('invisible');
      });
      /**
       * Fires when the submenu has closed.
       * @event Drilldown#hide
       */

      $elem.trigger('hide.zf.drilldown', [$elem]);
    }
    /**
     * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
     * Prevents content jumping.
     * @function
     * @private
     */

  }, {
    key: "_getMaxDims",
    value: function _getMaxDims() {
      var maxHeight = 0,
          result = {},
          _this = this; // Recalculate menu heights and total max height


      this.$submenus.add(this.$element).each(function () {
        var numOfElems = (0, _jquery2.default)(this).children('li').length;
        var height = Box.GetDimensions(this).height;
        maxHeight = height > maxHeight ? height : maxHeight;

        if (_this.options.autoHeight) {
          (0, _jquery2.default)(this).data('calcHeight', height);
        }
      });
      if (this.options.autoHeight) result['height'] = this.$currentMenu.data('calcHeight');else result['min-height'] = "".concat(maxHeight, "px");
      result['max-width'] = "".concat(this.$element[0].getBoundingClientRect().width, "px");
      return result;
    }
    /**
     * Destroys the Drilldown Menu
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);

      this._hideAll();

      this.$element.off('mutateme.zf.trigger');
      Nest.Burn(this.$element, 'drilldown');
      this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');
      this.$submenuAnchors.each(function () {
        (0, _jquery2.default)(this).off('.zf.drilldown');
      });
      this.$element.find('[data-is-parent-link]').detach();
      this.$submenus.removeClass('drilldown-submenu-cover-previous invisible');
      this.$element.find('a').each(function () {
        var $link = (0, _jquery2.default)(this);
        $link.removeAttr('tabindex');

        if ($link.data('savedHref')) {
          $link.attr('href', $link.data('savedHref')).removeData('savedHref');
        } else {
          return;
        }
      });
    }
  }]);

  return Drilldown;
}(Plugin);

Drilldown.defaults = {
  /**
   * Drilldowns depend on styles in order to function properly; in the default build of Foundation these are
   * on the `drilldown` class. This option auto-applies this class to the drilldown upon initialization.
   * @option
   * @type {boolean}
   * @default true
   */
  autoApplyClass: true,

  /**
   * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @type {string}
   * @default '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>'
   */
  backButton: '<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',

  /**
   * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.
   * @option
   * @type {string}
   * @default top
   */
  backButtonPosition: 'top',

  /**
   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @type {string}
   * @default '<div></div>'
   */
  wrapper: '<div></div>',

  /**
   * Adds the parent link to the submenu.
   * @option
   * @type {boolean}
   * @default false
   */
  parentLink: false,

  /**
   * Allow the menu to return to root list on body click.
   * @option
   * @type {boolean}
   * @default false
   */
  closeOnClick: false,

  /**
   * Allow the menu to auto adjust height.
   * @option
   * @type {boolean}
   * @default false
   */
  autoHeight: false,

  /**
   * Animate the auto adjust height.
   * @option
   * @type {boolean}
   * @default false
   */
  animateHeight: false,

  /**
   * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button
   * @option
   * @type {boolean}
   * @default false
   */
  scrollTop: false,

  /**
   * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken
   * @option
   * @type {string}
   * @default ''
   */
  scrollTopElement: '',

  /**
   * ScrollTop offset
   * @option
   * @type {number}
   * @default 0
   */
  scrollTopOffset: 0,

  /**
   * Scroll animation duration
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Scroll animation easing. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @see {@link https://api.jquery.com/animate|JQuery animate}
   * @default 'swing'
   */
  animationEasing: 'swing' // holdOpen: false

};

var POSITIONS = ['left', 'right', 'top', 'bottom'];
var VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];
var HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];
var ALIGNMENTS = {
  'left': VERTICAL_ALIGNMENTS,
  'right': VERTICAL_ALIGNMENTS,
  'top': HORIZONTAL_ALIGNMENTS,
  'bottom': HORIZONTAL_ALIGNMENTS
};

function nextItem(item, array) {
  var currentIdx = array.indexOf(item);

  if (currentIdx === array.length - 1) {
    return array[0];
  } else {
    return array[currentIdx + 1];
  }
}

var Positionable =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Positionable, _Plugin);

  function Positionable() {
    _classCallCheck(this, Positionable);

    return _possibleConstructorReturn(this, _getPrototypeOf(Positionable).apply(this, arguments));
  }

  _createClass(Positionable, [{
    key: "_init",

    /**
     * Abstract class encapsulating the tether-like explicit positioning logic
     * including repositioning based on overlap.
     * Expects classes to define defaults for vOffset, hOffset, position,
     * alignment, allowOverlap, and allowBottomOverlap. They can do this by
     * extending the defaults, or (for now recommended due to the way docs are
     * generated) by explicitly declaring them.
     *
     **/
    value: function _init() {
      this.triedPositions = {};
      this.position = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;
      this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;
      this.originalPosition = this.position;
      this.originalAlignment = this.alignment;
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      return 'bottom';
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      switch (this.position) {
        case 'bottom':
        case 'top':
          return rtl() ? 'right' : 'left';

        case 'left':
        case 'right':
          return 'bottom';
      }
    }
    /**
     * Adjusts the positionable possible positions by iterating through alignments
     * and positions.
     * @function
     * @private
     */

  }, {
    key: "_reposition",
    value: function _reposition() {
      if (this._alignmentsExhausted(this.position)) {
        this.position = nextItem(this.position, POSITIONS);
        this.alignment = ALIGNMENTS[this.position][0];
      } else {
        this._realign();
      }
    }
    /**
     * Adjusts the dropdown pane possible positions by iterating through alignments
     * on the current position.
     * @function
     * @private
     */

  }, {
    key: "_realign",
    value: function _realign() {
      this._addTriedPosition(this.position, this.alignment);

      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);
    }
  }, {
    key: "_addTriedPosition",
    value: function _addTriedPosition(position, alignment) {
      this.triedPositions[position] = this.triedPositions[position] || [];
      this.triedPositions[position].push(alignment);
    }
  }, {
    key: "_positionsExhausted",
    value: function _positionsExhausted() {
      var isExhausted = true;

      for (var i = 0; i < POSITIONS.length; i++) {
        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);
      }

      return isExhausted;
    }
  }, {
    key: "_alignmentsExhausted",
    value: function _alignmentsExhausted(position) {
      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;
    } // When we're trying to center, we don't want to apply offset that's going to
    // take us just off center, so wrap around to return 0 for the appropriate
    // offset in those alignments.  TODO: Figure out if we want to make this
    // configurable behavior... it feels more intuitive, especially for tooltips, but
    // it's possible someone might actually want to start from center and then nudge
    // slightly off.

  }, {
    key: "_getVOffset",
    value: function _getVOffset() {
      return this.options.vOffset;
    }
  }, {
    key: "_getHOffset",
    value: function _getHOffset() {
      return this.options.hOffset;
    }
  }, {
    key: "_setPosition",
    value: function _setPosition($anchor, $element, $parent) {
      if ($anchor.attr('aria-expanded') === 'false') {
        return false;
      }

      if (!this.options.allowOverlap) {
        // restore original position & alignment before checking overlap
        this.position = this.originalPosition;
        this.alignment = this.originalAlignment;
      }

      $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));

      if (!this.options.allowOverlap) {
        var minOverlap = 100000000; // default coordinates to how we start, in case we can't figure out better

        var minCoordinates = {
          position: this.position,
          alignment: this.alignment
        };

        while (!this._positionsExhausted()) {
          var overlap = Box.OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);

          if (overlap === 0) {
            return;
          }

          if (overlap < minOverlap) {
            minOverlap = overlap;
            minCoordinates = {
              position: this.position,
              alignment: this.alignment
            };
          }

          this._reposition();

          $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
        } // If we get through the entire loop, there was no non-overlapping
        // position available. Pick the version with least overlap.


        this.position = minCoordinates.position;
        this.alignment = minCoordinates.alignment;
        $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));
      }
    }
  }]);

  return Positionable;
}(Plugin);

Positionable.defaults = {
  /**
   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, dropdown positionable first
   * try to position as defined by data-position and data-alignment, but
   * reposition if it would cause an overflow.
   * @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * @option
   * @type {boolean}
   * @default true
   */
  allowBottomOverlap: true,

  /**
   * Number of pixels the positionable should be separated vertically from anchor
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Number of pixels the positionable should be separated horizontally from anchor
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0
};

/**
 * Dropdown module.
 * @module foundation.dropdown
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.touch
 * @requires foundation.util.triggers
 */

var Dropdown =
/*#__PURE__*/
function (_Positionable) {
  _inherits(Dropdown, _Positionable);

  function Dropdown() {
    _classCallCheck(this, Dropdown);

    return _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).apply(this, arguments));
  }

  _createClass(Dropdown, [{
    key: "_setup",

    /**
     * Creates a new instance of a dropdown.
     * @class
     * @name Dropdown
     * @param {jQuery} element - jQuery object to make into a dropdown.
     *        Object should be of the dropdown panel, rather than its anchor.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Dropdown.defaults, this.$element.data(), options);
      this.className = 'Dropdown'; // ie9 back compat
      // Touch and Triggers init are idempotent, just need to make sure they are initialized

      Touch.init(_jquery2.default);
      Triggers.init(_jquery2.default);

      this._init();

      Keyboard.register('Dropdown', {
        'ENTER': 'toggle',
        'SPACE': 'toggle',
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var $id = this.$element.attr('id');
      this.$anchors = (0, _jquery2.default)("[data-toggle=\"".concat($id, "\"]")).length ? (0, _jquery2.default)("[data-toggle=\"".concat($id, "\"]")) : (0, _jquery2.default)("[data-open=\"".concat($id, "\"]"));
      this.$anchors.attr({
        'aria-controls': $id,
        'data-is-focus': false,
        'data-yeti-box': $id,
        'aria-haspopup': true,
        'aria-expanded': false
      });

      this._setCurrentAnchor(this.$anchors.first());

      if (this.options.parentClass) {
        this.$parent = this.$element.parents('.' + this.options.parentClass);
      } else {
        this.$parent = null;
      } // Set [aria-labelledby] on the Dropdown if it is not set


      if (typeof this.$element.attr('aria-labelledby') === 'undefined') {
        // Get the anchor ID or create one
        if (typeof this.$currentAnchor.attr('id') === 'undefined') {
          this.$currentAnchor.attr('id', GetYoDigits(6, 'dd-anchor'));
        }

        this.$element.attr('aria-labelledby', this.$currentAnchor.attr('id'));
      }

      this.$element.attr({
        'aria-hidden': 'true',
        'data-yeti-box': $id,
        'data-resize': $id
      });

      _get(_getPrototypeOf(Dropdown.prototype), "_init", this).call(this);

      this._events();
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      // handle legacy classnames
      var position = this.$element[0].className.match(/(top|left|right|bottom)/g);

      if (position) {
        return position[0];
      } else {
        return 'bottom';
      }
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      // handle legacy float approach
      var horizontalPosition = /float-(\S+)/.exec(this.$currentAnchor.attr('class'));

      if (horizontalPosition) {
        return horizontalPosition[1];
      }

      return _get(_getPrototypeOf(Dropdown.prototype), "_getDefaultAlignment", this).call(this);
    }
    /**
     * Sets the position and orientation of the dropdown pane, checks for collisions if allow-overlap is not true.
     * Recursively calls itself if a collision is detected, with a new position class.
     * @function
     * @private
     */

  }, {
    key: "_setPosition",
    value: function _setPosition() {
      this.$element.removeClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));

      _get(_getPrototypeOf(Dropdown.prototype), "_setPosition", this).call(this, this.$currentAnchor, this.$element, this.$parent);

      this.$element.addClass("has-position-".concat(this.position, " has-alignment-").concat(this.alignment));
    }
    /**
     * Make it a current anchor.
     * Current anchor as the reference for the position of Dropdown panes.
     * @param {HTML} el - DOM element of the anchor.
     * @function
     * @private
     */

  }, {
    key: "_setCurrentAnchor",
    value: function _setCurrentAnchor(el) {
      this.$currentAnchor = (0, _jquery2.default)(el);
    }
    /**
     * Adds event listeners to the element utilizing the triggers utility library.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this,
          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined';

      this.$element.on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': this.close.bind(this),
        'toggle.zf.trigger': this.toggle.bind(this),
        'resizeme.zf.trigger': this._setPosition.bind(this)
      });
      this.$anchors.off('click.zf.trigger').on('click.zf.trigger', function (e) {
        _this._setCurrentAnchor(this);

        if ( // if forceFollow false, always prevent default action
        _this.options.forceFollow === false || // if forceFollow true and hover option true, only prevent default action on 1st click
        // on 2nd click (dropown opened) the default action (e.g. follow a href) gets executed
        hasTouch && _this.options.hover && _this.$element.hasClass('is-open') === false) {
          e.preventDefault();
        }
      });

      if (this.options.hover) {
        this.$anchors.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
          _this._setCurrentAnchor(this);

          var bodyData = (0, _jquery2.default)('body').data();

          if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.open();

              _this.$anchors.data('hover', true);
            }, _this.options.hoverDelay);
          }
        }).on('mouseleave.zf.dropdown', ignoreMousedisappear(function () {
          clearTimeout(_this.timeout);
          _this.timeout = setTimeout(function () {
            _this.close();

            _this.$anchors.data('hover', false);
          }, _this.options.hoverDelay);
        }));

        if (this.options.hoverPane) {
          this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {
            clearTimeout(_this.timeout);
          }).on('mouseleave.zf.dropdown', ignoreMousedisappear(function () {
            clearTimeout(_this.timeout);
            _this.timeout = setTimeout(function () {
              _this.close();

              _this.$anchors.data('hover', false);
            }, _this.options.hoverDelay);
          }));
        }
      }

      this.$anchors.add(this.$element).on('keydown.zf.dropdown', function (e) {
        var $target = (0, _jquery2.default)(this),
            visibleFocusableElements = Keyboard.findFocusable(_this.$element);
        Keyboard.handleKey(e, 'Dropdown', {
          open: function open() {
            if ($target.is(_this.$anchors) && !$target.is('input, textarea')) {
              _this.open();

              _this.$element.attr('tabindex', -1).focus();

              e.preventDefault();
            }
          },
          close: function close() {
            _this.close();

            _this.$anchors.focus();
          }
        });
      });
    }
    /**
     * Adds an event handler to the body to close any dropdowns on a click.
     * @function
     * @private
     */

  }, {
    key: "_addBodyHandler",
    value: function _addBodyHandler() {
      var $body = (0, _jquery2.default)(document.body).not(this.$element),
          _this = this;

      $body.off('click.zf.dropdown tap.zf.dropdown').on('click.zf.dropdown tap.zf.dropdown', function (e) {
        if (_this.$anchors.is(e.target) || _this.$anchors.find(e.target).length) {
          return;
        }

        if (_this.$element.is(e.target) || _this.$element.find(e.target).length) {
          return;
        }

        _this.close();

        $body.off('click.zf.dropdown tap.zf.dropdown');
      });
    }
    /**
     * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
     * @function
     * @fires Dropdown#closeme
     * @fires Dropdown#show
     */

  }, {
    key: "open",
    value: function open() {
      // var _this = this;

      /**
       * Fires to close other open dropdowns, typically when dropdown is opening
       * @event Dropdown#closeme
       */
      this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));
      this.$anchors.addClass('hover').attr({
        'aria-expanded': true
      }); // this.$element/*.show()*/;

      this.$element.addClass('is-opening');

      this._setPosition();

      this.$element.removeClass('is-opening').addClass('is-open').attr({
        'aria-hidden': false
      });

      if (this.options.autoFocus) {
        var $focusable = Keyboard.findFocusable(this.$element);

        if ($focusable.length) {
          $focusable.eq(0).focus();
        }
      }

      if (this.options.closeOnClick) {
        this._addBodyHandler();
      }

      if (this.options.trapFocus) {
        Keyboard.trapFocus(this.$element);
      }
      /**
       * Fires once the dropdown is visible.
       * @event Dropdown#show
       */

      this.$element.trigger('show.zf.dropdown', [this.$element]);
    }
    /**
     * Closes the open dropdown pane.
     * @function
     * @fires Dropdown#hide
     */

  }, {
    key: "close",
    value: function close() {
      if (!this.$element.hasClass('is-open')) {
        return false;
      }

      this.$element.removeClass('is-open').attr({
        'aria-hidden': true
      });
      this.$anchors.removeClass('hover').attr('aria-expanded', false);
      /**
       * Fires once the dropdown is no longer visible.
       * @event Dropdown#hide
       */

      this.$element.trigger('hide.zf.dropdown', [this.$element]);

      if (this.options.trapFocus) {
        Keyboard.releaseFocus(this.$element);
      }
    }
    /**
     * Toggles the dropdown pane's visibility.
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.$element.hasClass('is-open')) {
        if (this.$anchors.data('hover')) return;
        this.close();
      } else {
        this.open();
      }
    }
    /**
     * Destroys the dropdown.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.trigger').hide();
      this.$anchors.off('.zf.dropdown');
      (0, _jquery2.default)(document.body).off('click.zf.dropdown tap.zf.dropdown');
    }
  }]);

  return Dropdown;
}(Positionable);

Dropdown.defaults = {
  /**
   * Class that designates bounding container of Dropdown (default: window)
   * @option
   * @type {?string}
   * @default null
   */
  parentClass: null,

  /**
   * Amount of time to delay opening a submenu on hover event.
   * @option
   * @type {number}
   * @default 250
   */
  hoverDelay: 250,

  /**
   * Allow submenus to open on hover events
   * @option
   * @type {boolean}
   * @default false
   */
  hover: false,

  /**
   * Don't close dropdown when hovering over dropdown pane
   * @option
   * @type {boolean}
   * @default false
   */
  hoverPane: false,

  /**
   * Number of pixels between the dropdown pane and the triggering element on open.
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Number of pixels between the dropdown pane and the triggering element on open.
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0,

  /**
   * Position of dropdown. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of dropdown relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, dropdown will first try to position as defined by data-position and data-alignment, but reposition if it would cause an overflow.
   * @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * @option
   * @type {boolean}
   * @default true
   */
  allowBottomOverlap: true,

  /**
   * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.
   * @option
   * @type {boolean}
   * @default false
   */
  trapFocus: false,

  /**
   * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.
   * @option
   * @type {boolean}
   * @default false
   */
  autoFocus: false,

  /**
   * Allows a click on the body to close the dropdown.
   * @option
   * @type {boolean}
   * @default false
   */
  closeOnClick: false,

  /**
   * If true the default action of the toggle (e.g. follow a link with href) gets executed on click. If hover option is also true the default action gets prevented on first click for mobile / touch devices and executed on second click.
   * @option
   * @type {boolean}
   * @default true
   */
  forceFollow: true
};

/**
 * DropdownMenu module.
 * @module foundation.dropdownMenu
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.nest
 * @requires foundation.util.touch
 */

var DropdownMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(DropdownMenu, _Plugin);

  function DropdownMenu() {
    _classCallCheck(this, DropdownMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(DropdownMenu).apply(this, arguments));
  }

  _createClass(DropdownMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of DropdownMenu.
     * @class
     * @name DropdownMenu
     * @fires DropdownMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, DropdownMenu.defaults, this.$element.data(), options);
      this.className = 'DropdownMenu'; // ie9 back compat

      Touch.init(_jquery2.default); // Touch init is idempotent, we just need to make sure it's initialied.

      this._init();

      Keyboard.register('DropdownMenu', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'up',
        'ARROW_DOWN': 'down',
        'ARROW_LEFT': 'previous',
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the plugin, and calls _prepareMenu
     * @private
     * @function
     */

  }, {
    key: "_init",
    value: function _init() {
      Nest.Feather(this.$element, 'dropdown');
      var subs = this.$element.find('li.is-dropdown-submenu-parent');
      this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');
      this.$menuItems = this.$element.find('li[role="none"]');
      this.$tabs = this.$element.children('li[role="none"]');
      this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);

      if (this.options.alignment === 'auto') {
        if (this.$element.hasClass(this.options.rightClass) || rtl() || this.$element.parents('.top-bar-right').is('*')) {
          this.options.alignment = 'right';
          subs.addClass('opens-left');
        } else {
          this.options.alignment = 'left';
          subs.addClass('opens-right');
        }
      } else {
        if (this.options.alignment === 'right') {
          subs.addClass('opens-left');
        } else {
          subs.addClass('opens-right');
        }
      }

      this.changed = false;

      this._events();
    }
  }, {
    key: "_isVertical",
    value: function _isVertical() {
      return this.$tabs.css('display') === 'block' || this.$element.css('flex-direction') === 'column';
    }
  }, {
    key: "_isRtl",
    value: function _isRtl() {
      return this.$element.hasClass('align-right') || rtl() && !this.$element.hasClass('align-left');
    }
    /**
     * Adds event listeners to elements within the menu
     * @private
     * @function
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this,
          hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',
          parClass = 'is-dropdown-submenu-parent'; // used for onClick and in the keyboard handlers


      var handleClickFn = function handleClickFn(e) {
        var $elem = (0, _jquery2.default)(e.target).parentsUntil('ul', ".".concat(parClass)),
            hasSub = $elem.hasClass(parClass),
            hasClicked = $elem.attr('data-is-click') === 'true',
            $sub = $elem.children('.is-dropdown-submenu');

        if (hasSub) {
          if (hasClicked) {
            if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {
              return;
            }

            e.stopImmediatePropagation();
            e.preventDefault();

            _this._hide($elem);
          } else {
            e.stopImmediatePropagation();
            e.preventDefault();

            _this._show($sub);

            $elem.add($elem.parentsUntil(_this.$element, ".".concat(parClass))).attr('data-is-click', true);
          }
        }
      };

      if (this.options.clickOpen || hasTouch) {
        this.$menuItems.on('click.zf.dropdownMenu touchstart.zf.dropdownMenu', handleClickFn);
      } // Handle Leaf element Clicks


      if (_this.options.closeOnClickInside) {
        this.$menuItems.on('click.zf.dropdownMenu', function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (!hasSub) {
            _this._hide();
          }
        });
      }

      if (!this.options.disableHover) {
        this.$menuItems.on('mouseenter.zf.dropdownMenu', function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (hasSub) {
            clearTimeout($elem.data('_delay'));
            $elem.data('_delay', setTimeout(function () {
              _this._show($elem.children('.is-dropdown-submenu'));
            }, _this.options.hoverDelay));
          }
        }).on('mouseleave.zf.dropdownMenu', ignoreMousedisappear(function (e) {
          var $elem = (0, _jquery2.default)(this),
              hasSub = $elem.hasClass(parClass);

          if (hasSub && _this.options.autoclose) {
            if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {
              return false;
            }

            clearTimeout($elem.data('_delay'));
            $elem.data('_delay', setTimeout(function () {
              _this._hide($elem);
            }, _this.options.closingTime));
          }
        }));
      }

      this.$menuItems.on('keydown.zf.dropdownMenu', function (e) {
        var $element = (0, _jquery2.default)(e.target).parentsUntil('ul', '[role="none"]'),
            isTab = _this.$tabs.index($element) > -1,
            $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            $prevElement = $elements.eq(i - 1);
            $nextElement = $elements.eq(i + 1);
            return;
          }
        });

        var nextSibling = function nextSibling() {
          $nextElement.children('a:first').focus();
          e.preventDefault();
        },
            prevSibling = function prevSibling() {
          $prevElement.children('a:first').focus();
          e.preventDefault();
        },
            openSub = function openSub() {
          var $sub = $element.children('ul.is-dropdown-submenu');

          if ($sub.length) {
            _this._show($sub);

            $element.find('li > a:first').focus();
            e.preventDefault();
          } else {
            return;
          }
        },
            closeSub = function closeSub() {
          //if ($element.is(':first-child')) {
          var close = $element.parent('ul').parent('li');
          close.children('a:first').focus();

          _this._hide(close);

          e.preventDefault(); //}
        };

        var functions = {
          open: openSub,
          close: function close() {
            _this._hide(_this.$element);

            _this.$menuItems.eq(0).children('a').focus(); // focus to first element


            e.preventDefault();
          }
        };

        if (isTab) {
          if (_this._isVertical()) {
            // vertical menu
            if (_this._isRtl()) {
              // right aligned
              _jquery2.default.extend(functions, {
                down: nextSibling,
                up: prevSibling,
                next: closeSub,
                previous: openSub
              });
            } else {
              // left aligned
              _jquery2.default.extend(functions, {
                down: nextSibling,
                up: prevSibling,
                next: openSub,
                previous: closeSub
              });
            }
          } else {
            // horizontal menu
            if (_this._isRtl()) {
              // right aligned
              _jquery2.default.extend(functions, {
                next: prevSibling,
                previous: nextSibling,
                down: openSub,
                up: closeSub
              });
            } else {
              // left aligned
              _jquery2.default.extend(functions, {
                next: nextSibling,
                previous: prevSibling,
                down: openSub,
                up: closeSub
              });
            }
          }
        } else {
          // not tabs -> one sub
          if (_this._isRtl()) {
            // right aligned
            _jquery2.default.extend(functions, {
              next: closeSub,
              previous: openSub,
              down: nextSibling,
              up: prevSibling
            });
          } else {
            // left aligned
            _jquery2.default.extend(functions, {
              next: openSub,
              previous: closeSub,
              down: nextSibling,
              up: prevSibling
            });
          }
        }

        Keyboard.handleKey(e, 'DropdownMenu', functions);
      });
    }
    /**
     * Adds an event handler to the body to close any dropdowns on a click.
     * @function
     * @private
     */

  }, {
    key: "_addBodyHandler",
    value: function _addBodyHandler() {
      var _this2 = this;

      var $body = (0, _jquery2.default)(document.body);

      this._removeBodyHandler();

      $body.on('click.zf.dropdownMenu tap.zf.dropdownMenu', function (e) {
        var isItself = !!(0, _jquery2.default)(e.target).closest(_this2.$element).length;
        if (isItself) return;

        _this2._hide();

        _this2._removeBodyHandler();
      });
    }
    /**
     * Remove the body event handler. See `_addBodyHandler`.
     * @function
     * @private
     */

  }, {
    key: "_removeBodyHandler",
    value: function _removeBodyHandler() {
      (0, _jquery2.default)(document.body).off('click.zf.dropdownMenu tap.zf.dropdownMenu');
    }
    /**
     * Opens a dropdown pane, and checks for collisions first.
     * @param {jQuery} $sub - ul element that is a submenu to show
     * @function
     * @private
     * @fires DropdownMenu#show
     */

  }, {
    key: "_show",
    value: function _show($sub) {
      var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {
        return (0, _jquery2.default)(el).find($sub).length > 0;
      }));
      var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');

      this._hide($sibs, idx);

      $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');
      var clear = Box.ImNotTouchingYou($sub, null, true);

      if (!clear) {
        var oldClass = this.options.alignment === 'left' ? '-right' : '-left',
            $parentLi = $sub.parent('.is-dropdown-submenu-parent');
        $parentLi.removeClass("opens".concat(oldClass)).addClass("opens-".concat(this.options.alignment));
        clear = Box.ImNotTouchingYou($sub, null, true);

        if (!clear) {
          $parentLi.removeClass("opens-".concat(this.options.alignment)).addClass('opens-inner');
        }

        this.changed = true;
      }

      $sub.css('visibility', '');

      if (this.options.closeOnClick) {
        this._addBodyHandler();
      }
      /**
       * Fires when the new dropdown pane is visible.
       * @event DropdownMenu#show
       */

      this.$element.trigger('show.zf.dropdownMenu', [$sub]);
    }
    /**
     * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.
     * @function
     * @param {jQuery} $elem - element with a submenu to hide
     * @param {Number} idx - index of the $tabs collection to hide
     * @fires DropdownMenu#hide
     * @private
     */

  }, {
    key: "_hide",
    value: function _hide($elem, idx) {
      var $toClose;

      if ($elem && $elem.length) {
        $toClose = $elem;
      } else if (typeof idx !== 'undefined') {
        $toClose = this.$tabs.not(function (i, el) {
          return i === idx;
        });
      } else {
        $toClose = this.$element;
      }

      var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;

      if (somethingToClose) {
        var $activeItem = $toClose.find('li.is-active');
        $activeItem.add($toClose).attr({
          'data-is-click': false
        }).removeClass('is-active');
        $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');

        if (this.changed || $toClose.find('opens-inner').length) {
          var oldClass = this.options.alignment === 'left' ? 'right' : 'left';
          $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass("opens-inner opens-".concat(this.options.alignment)).addClass("opens-".concat(oldClass));
          this.changed = false;
        }

        clearTimeout($activeItem.data('_delay'));

        this._removeBodyHandler();
        /**
         * Fires when the open menus are closed.
         * @event DropdownMenu#hide
         */

        this.$element.trigger('hide.zf.dropdownMenu', [$toClose]);
      }
    }
    /**
     * Destroys the plugin.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$menuItems.off('.zf.dropdownMenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');
      (0, _jquery2.default)(document.body).off('.zf.dropdownMenu');
      Nest.Burn(this.$element, 'dropdown');
    }
  }]);

  return DropdownMenu;
}(Plugin);
/**
 * Default settings for plugin
 */

DropdownMenu.defaults = {
  /**
   * Disallows hover events from opening submenus
   * @option
   * @type {boolean}
   * @default false
   */
  disableHover: false,

  /**
   * Allow a submenu to automatically close on a mouseleave event, if not clicked open.
   * @option
   * @type {boolean}
   * @default true
   */
  autoclose: true,

  /**
   * Amount of time to delay opening a submenu on hover event.
   * @option
   * @type {number}
   * @default 50
   */
  hoverDelay: 50,

  /**
   * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
   * @option
   * @type {boolean}
   * @default false
   */
  clickOpen: false,

  /**
   * Amount of time to delay closing a submenu on a mouseleave event.
   * @option
   * @type {number}
   * @default 500
   */
  closingTime: 500,

  /**
   * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'auto'`, `'left'` or `'right'`.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow clicks on the body to close any open submenus.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Allow clicks on leaf anchor links to close any open submenus.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClickInside: true,

  /**
   * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
   * @option
   * @type {string}
   * @default 'vertical'
   */
  verticalClass: 'vertical',

  /**
   * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
   * @option
   * @type {string}
   * @default 'align-right'
   */
  rightClass: 'align-right',

  /**
   * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.
   * @option
   * @type {boolean}
   * @default true
   */
  forceFollow: true
};

/**
 * Equalizer module.
 * @module foundation.equalizer
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.imageLoader if equalizer contains images
 */

var Equalizer =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Equalizer, _Plugin);

  function Equalizer() {
    _classCallCheck(this, Equalizer);

    return _possibleConstructorReturn(this, _getPrototypeOf(Equalizer).apply(this, arguments));
  }

  _createClass(Equalizer, [{
    key: "_setup",

    /**
     * Creates a new instance of Equalizer.
     * @class
     * @name Equalizer
     * @fires Equalizer#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Equalizer.defaults, this.$element.data(), options);
      this.className = 'Equalizer'; // ie9 back compat

      this._init();
    }
    /**
     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var eqId = this.$element.attr('data-equalizer') || '';
      var $watched = this.$element.find("[data-equalizer-watch=\"".concat(eqId, "\"]"));

      MediaQuery._init();

      this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');
      this.$element.attr('data-resize', eqId || GetYoDigits(6, 'eq'));
      this.$element.attr('data-mutate', eqId || GetYoDigits(6, 'eq'));
      this.hasNested = this.$element.find('[data-equalizer]').length > 0;
      this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;
      this.isOn = false;
      this._bindHandler = {
        onResizeMeBound: this._onResizeMe.bind(this),
        onPostEqualizedBound: this._onPostEqualized.bind(this)
      };
      var imgs = this.$element.find('img');
      var tooSmall;

      if (this.options.equalizeOn) {
        tooSmall = this._checkMQ();
        (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));
      } else {
        this._events();
      }

      if (typeof tooSmall !== 'undefined' && tooSmall === false || typeof tooSmall === 'undefined') {
        if (imgs.length) {
          onImagesLoaded(imgs, this._reflow.bind(this));
        } else {
          this._reflow();
        }
      }
    }
    /**
     * Removes event listeners if the breakpoint is too small.
     * @private
     */

  }, {
    key: "_pauseEvents",
    value: function _pauseEvents() {
      this.isOn = false;
      this.$element.off({
        '.zf.equalizer': this._bindHandler.onPostEqualizedBound,
        'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,
        'mutateme.zf.trigger': this._bindHandler.onResizeMeBound
      });
    }
    /**
     * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound
     * @private
     */

  }, {
    key: "_onResizeMe",
    value: function _onResizeMe(e) {
      this._reflow();
    }
    /**
     * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound
     * @private
     */

  }, {
    key: "_onPostEqualized",
    value: function _onPostEqualized(e) {
      if (e.target !== this.$element[0]) {
        this._reflow();
      }
    }
    /**
     * Initializes events for Equalizer.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {

      this._pauseEvents();

      if (this.hasNested) {
        this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);
      } else {
        this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);
        this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);
      }

      this.isOn = true;
    }
    /**
     * Checks the current breakpoint to the minimum required size.
     * @private
     */

  }, {
    key: "_checkMQ",
    value: function _checkMQ() {
      var tooSmall = !MediaQuery.is(this.options.equalizeOn);

      if (tooSmall) {
        if (this.isOn) {
          this._pauseEvents();

          this.$watched.css('height', 'auto');
        }
      } else {
        if (!this.isOn) {
          this._events();
        }
      }

      return tooSmall;
    }
    /**
     * A noop version for the plugin
     * @private
     */

  }, {
    key: "_killswitch",
    value: function _killswitch() {
      return;
    }
    /**
     * Calls necessary functions to update Equalizer upon DOM change
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      if (!this.options.equalizeOnStack) {
        if (this._isStacked()) {
          this.$watched.css('height', 'auto');
          return false;
        }
      }

      if (this.options.equalizeByRow) {
        this.getHeightsByRow(this.applyHeightByRow.bind(this));
      } else {
        this.getHeights(this.applyHeight.bind(this));
      }
    }
    /**
     * Manually determines if the first 2 elements are *NOT* stacked.
     * @private
     */

  }, {
    key: "_isStacked",
    value: function _isStacked() {
      if (!this.$watched[0] || !this.$watched[1]) {
        return true;
      }

      return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;
    }
    /**
     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
     * @param {Function} cb - A non-optional callback to return the heights array to.
     * @returns {Array} heights - An array of heights of children within Equalizer container
     */

  }, {
    key: "getHeights",
    value: function getHeights(cb) {
      var heights = [];

      for (var i = 0, len = this.$watched.length; i < len; i++) {
        this.$watched[i].style.height = 'auto';
        heights.push(this.$watched[i].offsetHeight);
      }

      cb(heights);
    }
    /**
     * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
     * @param {Function} cb - A non-optional callback to return the heights array to.
     * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
     */

  }, {
    key: "getHeightsByRow",
    value: function getHeightsByRow(cb) {
      var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,
          groups = [],
          group = 0; //group by Row

      groups[group] = [];

      for (var i = 0, len = this.$watched.length; i < len; i++) {
        this.$watched[i].style.height = 'auto'; //maybe could use this.$watched[i].offsetTop

        var elOffsetTop = (0, _jquery2.default)(this.$watched[i]).offset().top;

        if (elOffsetTop != lastElTopOffset) {
          group++;
          groups[group] = [];
          lastElTopOffset = elOffsetTop;
        }

        groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);
      }

      for (var j = 0, ln = groups.length; j < ln; j++) {
        var heights = (0, _jquery2.default)(groups[j]).map(function () {
          return this[1];
        }).get();
        var max = Math.max.apply(null, heights);
        groups[j].push(max);
      }

      cb(groups);
    }
    /**
     * Changes the CSS height property of each child in an Equalizer parent to match the tallest
     * @param {array} heights - An array of heights of children within Equalizer container
     * @fires Equalizer#preequalized
     * @fires Equalizer#postequalized
     */

  }, {
    key: "applyHeight",
    value: function applyHeight(heights) {
      var max = Math.max.apply(null, heights);
      /**
       * Fires before the heights are applied
       * @event Equalizer#preequalized
       */

      this.$element.trigger('preequalized.zf.equalizer');
      this.$watched.css('height', max);
      /**
       * Fires when the heights have been applied
       * @event Equalizer#postequalized
       */

      this.$element.trigger('postequalized.zf.equalizer');
    }
    /**
     * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row
     * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
     * @fires Equalizer#preequalized
     * @fires Equalizer#preequalizedrow
     * @fires Equalizer#postequalizedrow
     * @fires Equalizer#postequalized
     */

  }, {
    key: "applyHeightByRow",
    value: function applyHeightByRow(groups) {
      /**
       * Fires before the heights are applied
       */
      this.$element.trigger('preequalized.zf.equalizer');

      for (var i = 0, len = groups.length; i < len; i++) {
        var groupsILength = groups[i].length,
            max = groups[i][groupsILength - 1];

        if (groupsILength <= 2) {
          (0, _jquery2.default)(groups[i][0][0]).css({
            'height': 'auto'
          });
          continue;
        }
        /**
          * Fires before the heights per row are applied
          * @event Equalizer#preequalizedrow
          */

        this.$element.trigger('preequalizedrow.zf.equalizer');

        for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {
          (0, _jquery2.default)(groups[i][j][0]).css({
            'height': max
          });
        }
        /**
          * Fires when the heights per row have been applied
          * @event Equalizer#postequalizedrow
          */

        this.$element.trigger('postequalizedrow.zf.equalizer');
      }
      /**
       * Fires when the heights have been applied
       */

      this.$element.trigger('postequalized.zf.equalizer');
    }
    /**
     * Destroys an instance of Equalizer.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this._pauseEvents();

      this.$watched.css('height', 'auto');
    }
  }]);

  return Equalizer;
}(Plugin);
/**
 * Default settings for plugin
 */

Equalizer.defaults = {
  /**
   * Enable height equalization when stacked on smaller screens.
   * @option
   * @type {boolean}
   * @default false
   */
  equalizeOnStack: false,

  /**
   * Enable height equalization row by row.
   * @option
   * @type {boolean}
   * @default false
   */
  equalizeByRow: false,

  /**
   * String representing the minimum breakpoint size the plugin should equalize heights on.
   * @option
   * @type {string}
   * @default ''
   */
  equalizeOn: ''
};

/**
 * Interchange module.
 * @module foundation.interchange
 * @requires foundation.util.mediaQuery
 */

var Interchange =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Interchange, _Plugin);

  function Interchange() {
    _classCallCheck(this, Interchange);

    return _possibleConstructorReturn(this, _getPrototypeOf(Interchange).apply(this, arguments));
  }

  _createClass(Interchange, [{
    key: "_setup",

    /**
     * Creates a new instance of Interchange.
     * @class
     * @name Interchange
     * @fires Interchange#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Interchange.defaults, this.$element.data(), options);
      this.rules = [];
      this.currentPath = '';
      this.className = 'Interchange'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();

      this._events();
    }
    /**
     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var id = this.$element[0].id || GetYoDigits(6, 'interchange');
      this.$element.attr({
        'data-resize': id,
        'id': id
      });

      this._parseOptions();

      this._addBreakpoints();

      this._generateRules();

      this._reflow();
    }
    /**
     * Initializes events for Interchange.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function () {
        return _this._reflow();
      });
    }
    /**
     * Calls necessary functions to update Interchange upon DOM change
     * @function
     * @private
     */

  }, {
    key: "_reflow",
    value: function _reflow() {
      var match; // Iterate through each rule, but only save the last match

      for (var i in this.rules) {
        if (this.rules.hasOwnProperty(i)) {
          var rule = this.rules[i];

          if (window.matchMedia(rule.query).matches) {
            match = rule;
          }
        }
      }

      if (match) {
        this.replace(match.path);
      }
    }
    /**
     * Check options valifity and set defaults for:
     * - `data-interchange-type`: if set, enforce the type of replacement (auto, src, background or html)
     * @function
     * @private
     */

  }, {
    key: "_parseOptions",
    value: function _parseOptions() {
      var types = ['auto', 'src', 'background', 'html'];
      if (typeof this.options.type === 'undefined') this.options.type = 'auto';else if (types.indexOf(this.options.type) === -1) {
        console.log("Warning: invalid value \"".concat(this.options.type, "\" for Interchange option \"type\""));
        this.options.type = 'auto';
      }
    }
    /**
     * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
     * @function
     * @private
     */

  }, {
    key: "_addBreakpoints",
    value: function _addBreakpoints() {
      for (var i in MediaQuery.queries) {
        if (MediaQuery.queries.hasOwnProperty(i)) {
          var query = MediaQuery.queries[i];
          Interchange.SPECIAL_QUERIES[query.name] = query.value;
        }
      }
    }
    /**
     * Checks the Interchange element for the provided media query + content pairings
     * @function
     * @private
     * @param {Object} element - jQuery object that is an Interchange instance
     * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
     */

  }, {
    key: "_generateRules",
    value: function _generateRules(element) {
      var rulesList = [];
      var rules;

      if (this.options.rules) {
        rules = this.options.rules;
      } else {
        rules = this.$element.data('interchange');
      }

      rules = typeof rules === 'string' ? rules.match(/\[.*?, .*?\]/g) : rules;

      for (var i in rules) {
        if (rules.hasOwnProperty(i)) {
          var rule = rules[i].slice(1, -1).split(', ');
          var path = rule.slice(0, -1).join('');
          var query = rule[rule.length - 1];

          if (Interchange.SPECIAL_QUERIES[query]) {
            query = Interchange.SPECIAL_QUERIES[query];
          }

          rulesList.push({
            path: path,
            query: query
          });
        }
      }

      this.rules = rulesList;
    }
    /**
     * Update the `src` property of an image, or change the HTML of a container, to the specified path.
     * @function
     * @param {String} path - Path to the image or HTML partial.
     * @fires Interchange#replaced
     */

  }, {
    key: "replace",
    value: function replace(path) {
      var _this2 = this;

      if (this.currentPath === path) return;
      var trigger = 'replaced.zf.interchange';
      var type = this.options.type;

      if (type === 'auto') {
        if (this.$element[0].nodeName === 'IMG') type = 'src';else if (path.match(/\.(gif|jpe?g|png|svg|tiff)([?#].*)?/i)) type = 'background';else type = 'html';
      } // Replacing images


      if (type === 'src') {
        this.$element.attr('src', path).on('load', function () {
          _this2.currentPath = path;
        }).trigger(trigger);
      } // Replacing background images
      else if (type === 'background') {
          path = path.replace(/\(/g, '%28').replace(/\)/g, '%29');
          this.$element.css({
            'background-image': 'url(' + path + ')'
          }).trigger(trigger);
        } // Replacing HTML
        else if (type === 'html') {
            _jquery2.default.get(path, function (response) {
              _this2.$element.html(response).trigger(trigger);

              (0, _jquery2.default)(response).foundation();
              _this2.currentPath = path;
            });
          }
      /**
       * Fires when content in an Interchange element is done being loaded.
       * @event Interchange#replaced
       */
      // this.$element.trigger('replaced.zf.interchange');
    }
    /**
     * Destroys an instance of interchange.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('resizeme.zf.trigger');
    }
  }]);

  return Interchange;
}(Plugin);
/**
 * Default settings for plugin
 */

Interchange.defaults = {
  /**
   * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
   * @option
   * @type {?array}
   * @default null
   */
  rules: null,

  /**
   * Type of the responsive ressource to replace. It can take the following options:
   * - `auto` (default): choose the type according to the element tag or the ressource extension,
   * - `src`: replace the `[src]` attribute, recommended for images `<img>`.
   * - `background`: replace the `background-image` CSS property.
   * - `html`: replace the element content.
   * @option
   * @type {string}
   * @default 'auto'
   */
  type: 'auto'
};
Interchange.SPECIAL_QUERIES = {
  'landscape': 'screen and (orientation: landscape)',
  'portrait': 'screen and (orientation: portrait)',
  'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'
};

/**
 * SmoothScroll module.
 * @module foundation.smoothScroll
 */

var SmoothScroll =
/*#__PURE__*/
function (_Plugin) {
  _inherits(SmoothScroll, _Plugin);

  function SmoothScroll() {
    _classCallCheck(this, SmoothScroll);

    return _possibleConstructorReturn(this, _getPrototypeOf(SmoothScroll).apply(this, arguments));
  }

  _createClass(SmoothScroll, [{
    key: "_setup",

    /**
     * Creates a new instance of SmoothScroll.
     * @class
     * @name SmoothScroll
     * @fires SmoothScroll#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, SmoothScroll.defaults, this.$element.data(), options);
      this.className = 'SmoothScroll'; // ie9 back compat

      this._init();
    }
    /**
     * Initialize the SmoothScroll plugin
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element[0].id || GetYoDigits(6, 'smooth-scroll');
      this.$element.attr({
        id: id
      });

      this._events();
    }
    /**
     * Initializes events for SmoothScroll.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._linkClickListener = this._handleLinkClick.bind(this);
      this.$element.on('click.zf.smoothScroll', this._linkClickListener);
      this.$element.on('click.zf.smoothScroll', 'a[href^="#"]', this._linkClickListener);
    }
    /**
     * Handle the given event to smoothly scroll to the anchor pointed by the event target.
     * @param {*} e - event
     * @function
     * @private
     */

  }, {
    key: "_handleLinkClick",
    value: function _handleLinkClick(e) {
      var _this = this;

      // Follow the link if it does not point to an anchor.
      if (!(0, _jquery2.default)(e.currentTarget).is('a[href^="#"]')) return;
      var arrival = e.currentTarget.getAttribute('href');
      this._inTransition = true;
      SmoothScroll.scrollToLoc(arrival, this.options, function () {
        _this._inTransition = false;
      });
      e.preventDefault();
    }
  }, {
    key: "_destroy",

    /**
     * Destroys the SmoothScroll instance.
     * @function
     */
    value: function _destroy() {
      this.$element.off('click.zf.smoothScroll', this._linkClickListener);
      this.$element.off('click.zf.smoothScroll', 'a[href^="#"]', this._linkClickListener);
    }
  }], [{
    key: "scrollToLoc",

    /**
     * Function to scroll to a given location on the page.
     * @param {String} loc - A properly formatted jQuery id selector. Example: '#foo'
     * @param {Object} options - The options to use.
     * @param {Function} callback - The callback function.
     * @static
     * @function
     */
    value: function scrollToLoc(loc) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SmoothScroll.defaults;
      var callback = arguments.length > 2 ? arguments[2] : undefined;
      var $loc = (0, _jquery2.default)(loc); // Do nothing if target does not exist to prevent errors

      if (!$loc.length) return false;
      var scrollPos = Math.round($loc.offset().top - options.threshold / 2 - options.offset);
      (0, _jquery2.default)('html, body').stop(true).animate({
        scrollTop: scrollPos
      }, options.animationDuration, options.animationEasing, function () {
        if (typeof callback === 'function') {
          callback();
        }
      });
    }
  }]);

  return SmoothScroll;
}(Plugin);
/**
 * Default settings for plugin.
 */

SmoothScroll.defaults = {
  /**
   * Amount of time, in ms, the animated scrolling should take between locations.
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @default 'linear'
   * @see {@link https://api.jquery.com/animate|Jquery animate}
   */
  animationEasing: 'linear',

  /**
   * Number of pixels to use as a marker for location changes.
   * @option
   * @type {number}
   * @default 50
   */
  threshold: 50,

  /**
   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
   * @option
   * @type {number}
   * @default 0
   */
  offset: 0
};

/**
 * Magellan module.
 * @module foundation.magellan
 * @requires foundation.smoothScroll
 * @requires foundation.util.triggers
 */

var Magellan =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Magellan, _Plugin);

  function Magellan() {
    _classCallCheck(this, Magellan);

    return _possibleConstructorReturn(this, _getPrototypeOf(Magellan).apply(this, arguments));
  }

  _createClass(Magellan, [{
    key: "_setup",

    /**
     * Creates a new instance of Magellan.
     * @class
     * @name Magellan
     * @fires Magellan#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Magellan.defaults, this.$element.data(), options);
      this.className = 'Magellan'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();

      this.calcPoints();
    }
    /**
     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element[0].id || GetYoDigits(6, 'magellan');

      this.$targets = (0, _jquery2.default)('[data-magellan-target]');
      this.$links = this.$element.find('a');
      this.$element.attr({
        'data-resize': id,
        'data-scroll': id,
        'id': id
      });
      this.$active = (0, _jquery2.default)();
      this.scrollPos = parseInt(window.pageYOffset, 10);

      this._events();
    }
    /**
     * Calculates an array of pixel values that are the demarcation lines between locations on the page.
     * Can be invoked if new elements are added or the size of a location changes.
     * @function
     */

  }, {
    key: "calcPoints",
    value: function calcPoints() {
      var _this = this,
          body = document.body,
          html = document.documentElement;

      this.points = [];
      this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));
      this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));
      this.$targets.each(function () {
        var $tar = (0, _jquery2.default)(this),
            pt = Math.round($tar.offset().top - _this.options.threshold);
        $tar.targetPoint = pt;

        _this.points.push(pt);
      });
    }
    /**
     * Initializes events for Magellan.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      (0, _jquery2.default)(window).one('load', function () {
        if (_this.options.deepLinking) {
          if (location.hash) {
            _this.scrollToLoc(location.hash);
          }
        }

        _this.calcPoints();

        _this._updateActive();
      });
      _this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        _this.$element.on({
          'resizeme.zf.trigger': _this.reflow.bind(_this),
          'scrollme.zf.trigger': _this._updateActive.bind(_this)
        }).on('click.zf.magellan', 'a[href^="#"]', function (e) {
          e.preventDefault();
          var arrival = this.getAttribute('href');

          _this.scrollToLoc(arrival);
        });
      });

      this._deepLinkScroll = function (e) {
        if (_this.options.deepLinking) {
          _this.scrollToLoc(window.location.hash);
        }
      };

      (0, _jquery2.default)(window).on('hashchange', this._deepLinkScroll);
    }
    /**
     * Function to scroll to a given location on the page.
     * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'
     * @function
     */

  }, {
    key: "scrollToLoc",
    value: function scrollToLoc(loc) {
      this._inTransition = true;

      var _this = this;

      var options = {
        animationEasing: this.options.animationEasing,
        animationDuration: this.options.animationDuration,
        threshold: this.options.threshold,
        offset: this.options.offset
      };
      SmoothScroll.scrollToLoc(loc, options, function () {
        _this._inTransition = false;
      });
    }
    /**
     * Calls necessary functions to update Magellan upon DOM change
     * @function
     */

  }, {
    key: "reflow",
    value: function reflow() {
      this.calcPoints();

      this._updateActive();
    }
    /**
     * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
     * @private
     * @function
     * @fires Magellan#update
     */

  }, {
    key: "_updateActive",
    value: function _updateActive()
    /*evt, elem, scrollPos*/
    {
      var _this2 = this;

      if (this._inTransition) return;
      var newScrollPos = parseInt(window.pageYOffset, 10);
      var isScrollingUp = this.scrollPos > newScrollPos;
      this.scrollPos = newScrollPos;
      var activeIdx; // Before the first point: no link

      if (newScrollPos < this.points[0]) ;
      /* do nothing */
      // At the bottom of the page: last link
      else if (newScrollPos + this.winHeight === this.docHeight) {
          activeIdx = this.points.length - 1;
        } // Otherwhise, use the last visible link
        else {
            var visibleLinks = this.points.filter(function (p, i) {
              return p - _this2.options.offset - (isScrollingUp ? _this2.options.threshold : 0) <= newScrollPos;
            });
            activeIdx = visibleLinks.length ? visibleLinks.length - 1 : 0;
          } // Get the new active link


      var $oldActive = this.$active;
      var activeHash = '';

      if (typeof activeIdx !== 'undefined') {
        this.$active = this.$links.filter('[href="#' + this.$targets.eq(activeIdx).data('magellan-target') + '"]');
        if (this.$active.length) activeHash = this.$active[0].getAttribute('href');
      } else {
        this.$active = (0, _jquery2.default)();
      }

      var isNewActive = !(!this.$active.length && !$oldActive.length) && !this.$active.is($oldActive);
      var isNewHash = activeHash !== window.location.hash; // Update the active link element

      if (isNewActive) {
        $oldActive.removeClass(this.options.activeClass);
        this.$active.addClass(this.options.activeClass);
      } // Update the hash (it may have changed with the same active link)


      if (this.options.deepLinking && isNewHash) {
        if (window.history.pushState) {
          // Set or remove the hash (see: https://stackoverflow.com/a/5298684/4317384
          var url = activeHash ? activeHash : window.location.pathname + window.location.search;

          if (this.options.updateHistory) {
            window.history.pushState({}, '', url);
          } else {
            window.history.replaceState({}, '', url);
          }
        } else {
          window.location.hash = activeHash;
        }
      }

      if (isNewActive) {
        /**
         * Fires when magellan is finished updating to the new active element.
         * @event Magellan#update
         */
        this.$element.trigger('update.zf.magellan', [this.$active]);
      }
    }
    /**
     * Destroys an instance of Magellan and resets the url of the window.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.trigger .zf.magellan').find(".".concat(this.options.activeClass)).removeClass(this.options.activeClass);

      if (this.options.deepLinking) {
        var hash = this.$active[0].getAttribute('href');
        window.location.hash.replace(hash, '');
      }

      (0, _jquery2.default)(window).off('hashchange', this._deepLinkScroll);
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);
    }
  }]);

  return Magellan;
}(Plugin);
/**
 * Default settings for plugin
 */

Magellan.defaults = {
  /**
   * Amount of time, in ms, the animated scrolling should take between locations.
   * @option
   * @type {number}
   * @default 500
   */
  animationDuration: 500,

  /**
   * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.
   * @option
   * @type {string}
   * @default 'linear'
   * @see {@link https://api.jquery.com/animate|Jquery animate}
   */
  animationEasing: 'linear',

  /**
   * Number of pixels to use as a marker for location changes.
   * @option
   * @type {number}
   * @default 50
   */
  threshold: 50,

  /**
   * Class applied to the active locations link on the magellan container.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  activeClass: 'is-active',

  /**
   * Allows the script to manipulate the url of the current page, and if supported, alter the history.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinking: false,

  /**
   * Update the browser history with the active link, if deep linking is enabled.
   * @option
   * @type {boolean}
   * @default false
   */
  updateHistory: false,

  /**
   * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
   * @option
   * @type {number}
   * @default 0
   */
  offset: 0
};

/**
 * OffCanvas module.
 * @module foundation.offCanvas
 * @requires foundation.util.keyboard
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.triggers
 */

var OffCanvas =
/*#__PURE__*/
function (_Plugin) {
  _inherits(OffCanvas, _Plugin);

  function OffCanvas() {
    _classCallCheck(this, OffCanvas);

    return _possibleConstructorReturn(this, _getPrototypeOf(OffCanvas).apply(this, arguments));
  }

  _createClass(OffCanvas, [{
    key: "_setup",

    /**
     * Creates a new instance of an off-canvas wrapper.
     * @class
     * @name OffCanvas
     * @fires OffCanvas#init
     * @param {Object} element - jQuery object to initialize.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      var _this2 = this;

      this.className = 'OffCanvas'; // ie9 back compat

      this.$element = element;
      this.options = _jquery2.default.extend({}, OffCanvas.defaults, this.$element.data(), options);
      this.contentClasses = {
        base: [],
        reveal: []
      };
      this.$lastTrigger = (0, _jquery2.default)();
      this.$triggers = (0, _jquery2.default)();
      this.position = 'left';
      this.$content = (0, _jquery2.default)();
      this.nested = !!this.options.nested;
      this.$sticky = (0, _jquery2.default)();
      this.isInCanvas = false; // Defines the CSS transition/position classes of the off-canvas content container.

      (0, _jquery2.default)(['push', 'overlap']).each(function (index, val) {
        _this2.contentClasses.base.push('has-transition-' + val);
      });
      (0, _jquery2.default)(['left', 'right', 'top', 'bottom']).each(function (index, val) {
        _this2.contentClasses.base.push('has-position-' + val);

        _this2.contentClasses.reveal.push('has-reveal-' + val);
      }); // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      MediaQuery._init();

      this._init();

      this._events();

      Keyboard.register('OffCanvas', {
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var id = this.$element.attr('id');
      this.$element.attr('aria-hidden', 'true'); // Find off-canvas content, either by ID (if specified), by siblings or by closest selector (fallback)

      if (this.options.contentId) {
        this.$content = (0, _jquery2.default)('#' + this.options.contentId);
      } else if (this.$element.siblings('[data-off-canvas-content]').length) {
        this.$content = this.$element.siblings('[data-off-canvas-content]').first();
      } else {
        this.$content = this.$element.closest('[data-off-canvas-content]').first();
      }

      if (!this.options.contentId) {
        // Assume that the off-canvas element is nested if it isn't a sibling of the content
        this.nested = this.$element.siblings('[data-off-canvas-content]').length === 0;
      } else if (this.options.contentId && this.options.nested === null) {
        // Warning if using content ID without setting the nested option
        // Once the element is nested it is required to work properly in this case
        console.warn('Remember to use the nested option if using the content ID option!');
      }

      if (this.nested === true) {
        // Force transition overlap if nested
        this.options.transition = 'overlap'; // Remove appropriate classes if already assigned in markup

        this.$element.removeClass('is-transition-push');
      }

      this.$element.addClass("is-transition-".concat(this.options.transition, " is-closed")); // Find triggers that affect this element and add aria-expanded to them

      this.$triggers = (0, _jquery2.default)(document).find('[data-open="' + id + '"], [data-close="' + id + '"], [data-toggle="' + id + '"]').attr('aria-expanded', 'false').attr('aria-controls', id); // Get position by checking for related CSS class

      this.position = this.$element.is('.position-left, .position-top, .position-right, .position-bottom') ? this.$element.attr('class').match(/position\-(left|top|right|bottom)/)[1] : this.position; // Add an overlay over the content if necessary

      if (this.options.contentOverlay === true) {
        var overlay = document.createElement('div');
        var overlayPosition = (0, _jquery2.default)(this.$element).css("position") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';
        overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);
        this.$overlay = (0, _jquery2.default)(overlay);

        if (overlayPosition === 'is-overlay-fixed') {
          (0, _jquery2.default)(this.$overlay).insertAfter(this.$element);
        } else {
          this.$content.append(this.$overlay);
        }
      } // Get the revealOn option from the class.


      var revealOnRegExp = new RegExp(RegExpEscape(this.options.revealClass) + '([^\\s]+)', 'g');
      var revealOnClass = revealOnRegExp.exec(this.$element[0].className);

      if (revealOnClass) {
        this.options.isRevealed = true;
        this.options.revealOn = this.options.revealOn || revealOnClass[1];
      } // Ensure the `reveal-on-*` class is set.


      if (this.options.isRevealed === true && this.options.revealOn) {
        this.$element.first().addClass("".concat(this.options.revealClass).concat(this.options.revealOn));

        this._setMQChecker();
      }

      if (this.options.transitionTime) {
        this.$element.css('transition-duration', this.options.transitionTime);
      } // Find fixed elements that should stay fixed while off-canvas is opened


      this.$sticky = this.$content.find('[data-off-canvas-sticky]');

      if (this.$sticky.length > 0 && this.options.transition === 'push') {
        // If there's at least one match force contentScroll:false because the absolute top value doesn't get recalculated on scroll
        // Limit to push transition since there's no transform scope for overlap
        this.options.contentScroll = false;
      }

      var inCanvasFor = this.$element.attr('class').match(/\bin-canvas-for-(\w+)/);

      if (inCanvasFor && inCanvasFor.length === 2) {
        // Set `inCanvasOn` option if found in-canvas-for-[BREAKPONT] CSS class
        this.options.inCanvasOn = inCanvasFor[1];
      } else if (this.options.inCanvasOn) {
        // Ensure the CSS class is set
        this.$element.addClass("in-canvas-for-".concat(this.options.inCanvasOn));
      }

      if (this.options.inCanvasOn) {
        this._checkInCanvas();
      } // Initally remove all transition/position CSS classes from off-canvas content container.


      this._removeContentClasses();
    }
    /**
     * Adds event handlers to the off-canvas wrapper and the exit overlay.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this3 = this;

      this.$element.off('.zf.trigger .zf.offCanvas').on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': this.close.bind(this),
        'toggle.zf.trigger': this.toggle.bind(this),
        'keydown.zf.offCanvas': this._handleKeyboard.bind(this)
      });

      if (this.options.closeOnClick === true) {
        var $target = this.options.contentOverlay ? this.$overlay : this.$content;
        $target.on({
          'click.zf.offCanvas': this.close.bind(this)
        });
      }

      if (this.options.inCanvasOn) {
        (0, _jquery2.default)(window).on('changed.zf.mediaquery', function () {
          _this3._checkInCanvas();
        });
      }
    }
    /**
     * Applies event listener for elements that will reveal at certain breakpoints.
     * @private
     */

  }, {
    key: "_setMQChecker",
    value: function _setMQChecker() {
      var _this = this;

      this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        if (MediaQuery.atLeast(_this.options.revealOn)) {
          _this.reveal(true);
        }
      });
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', function () {
        if (MediaQuery.atLeast(_this.options.revealOn)) {
          _this.reveal(true);
        } else {
          _this.reveal(false);
        }
      });
    }
    /**
     * Checks if InCanvas on current breakpoint and adjust off-canvas accordingly
     * @private
     */

  }, {
    key: "_checkInCanvas",
    value: function _checkInCanvas() {
      this.isInCanvas = MediaQuery.atLeast(this.options.inCanvasOn);

      if (this.isInCanvas === true) {
        this.close();
      }
    }
    /**
     * Removes the CSS transition/position classes of the off-canvas content container.
     * Removing the classes is important when another off-canvas gets opened that uses the same content container.
     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.
     * @private
     */

  }, {
    key: "_removeContentClasses",
    value: function _removeContentClasses(hasReveal) {
      if (typeof hasReveal !== 'boolean') {
        this.$content.removeClass(this.contentClasses.base.join(' '));
      } else if (hasReveal === false) {
        this.$content.removeClass("has-reveal-".concat(this.position));
      }
    }
    /**
     * Adds the CSS transition/position classes of the off-canvas content container, based on the opening off-canvas element.
     * Beforehand any transition/position class gets removed.
     * @param {Boolean} hasReveal - true if related off-canvas element is revealed.
     * @private
     */

  }, {
    key: "_addContentClasses",
    value: function _addContentClasses(hasReveal) {
      this._removeContentClasses(hasReveal);

      if (typeof hasReveal !== 'boolean') {
        this.$content.addClass("has-transition-".concat(this.options.transition, " has-position-").concat(this.position));
      } else if (hasReveal === true) {
        this.$content.addClass("has-reveal-".concat(this.position));
      }
    }
    /**
     * Preserves the fixed behavior of sticky elements on opening an off-canvas with push transition.
     * Since the off-canvas container has got a transform scope in such a case, it is done by calculating position absolute values.
     * @private
     */

  }, {
    key: "_fixStickyElements",
    value: function _fixStickyElements() {
      this.$sticky.each(function (_, el) {
        var $el = (0, _jquery2.default)(el); // If sticky element is currently fixed, adjust its top value to match absolute position due to transform scope
        // Limit to push transition because postion:fixed works without problems for overlap (no transform scope)

        if ($el.css('position') === 'fixed') {
          // Save current inline styling to restore it if undoing the absolute fixing
          var topVal = parseInt($el.css('top'), 10);
          $el.data('offCanvasSticky', {
            top: topVal
          });
          var absoluteTopVal = (0, _jquery2.default)(document).scrollTop() + topVal;
          $el.css({
            top: "".concat(absoluteTopVal, "px"),
            width: '100%',
            transition: 'none'
          });
        }
      });
    }
    /**
     * Restores the original fixed styling of sticky elements after having closed an off-canvas that got pseudo fixed beforehand.
     * This reverts the changes of _fixStickyElements()
     * @private
     */

  }, {
    key: "_unfixStickyElements",
    value: function _unfixStickyElements() {
      this.$sticky.each(function (_, el) {
        var $el = (0, _jquery2.default)(el);
        var stickyData = $el.data('offCanvasSticky'); // If sticky element has got data object with prior values (meaning it was originally fixed) restore these values once off-canvas is closed

        if (_typeof(stickyData) === 'object') {
          $el.css({
            top: "".concat(stickyData.top, "px"),
            width: '',
            transition: ''
          });
          $el.data('offCanvasSticky', '');
        }
      });
    }
    /**
     * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
     * @param {Boolean} isRevealed - true if element should be revealed.
     * @function
     */

  }, {
    key: "reveal",
    value: function reveal(isRevealed) {
      if (isRevealed) {
        this.close();
        this.isRevealed = true;
        this.$element.attr('aria-hidden', 'false');
        this.$element.off('open.zf.trigger toggle.zf.trigger');
        this.$element.removeClass('is-closed');
      } else {
        this.isRevealed = false;
        this.$element.attr('aria-hidden', 'true');
        this.$element.off('open.zf.trigger toggle.zf.trigger').on({
          'open.zf.trigger': this.open.bind(this),
          'toggle.zf.trigger': this.toggle.bind(this)
        });
        this.$element.addClass('is-closed');
      }

      this._addContentClasses(isRevealed);
    }
    /**
     * Stops scrolling of the body when OffCanvas is open on mobile Safari and other troublesome browsers.
     * @function
     * @private
     */

  }, {
    key: "_stopScrolling",
    value: function _stopScrolling(event) {
      return false;
    }
    /**
     * Tag the element given as context whether it can be scrolled up and down.
     * Used to allow or prevent it to scroll. See `_stopScrollPropagation`.
     *
     * Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios
     * Only really works for y, not sure how to extend to x or if we need to.
     *
     * @function
     * @private
     */

  }, {
    key: "_recordScrollable",
    value: function _recordScrollable(event) {
      var elem = this; // called from event handler context with this as elem
      // If the element is scrollable (content overflows), then...

      if (elem.scrollHeight !== elem.clientHeight) {
        // If we're at the top, scroll down one pixel to allow scrolling up
        if (elem.scrollTop === 0) {
          elem.scrollTop = 1;
        } // If we're at the bottom, scroll up one pixel to allow scrolling down


        if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {
          elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;
        }
      }

      elem.allowUp = elem.scrollTop > 0;
      elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;
      elem.lastY = event.originalEvent.pageY;
    }
    /**
     * Prevent the given event propagation if the element given as context can scroll.
     * Used to preserve the element scrolling on mobile (`touchmove`) when the document
     * scrolling is prevented. See https://git.io/zf-9707.
     * @function
     * @private
     */

  }, {
    key: "_stopScrollPropagation",
    value: function _stopScrollPropagation(event) {
      var elem = this; // called from event handler context with this as elem

      var parent; // off-canvas elem if called from inner scrollbox

      var up = event.pageY < elem.lastY;
      var down = !up;
      elem.lastY = event.pageY;

      if (up && elem.allowUp || down && elem.allowDown) {
        // It is not recommended to stop event propagation (the user cannot watch it),
        // but in this case this is the only solution we have.
        event.stopPropagation(); // If elem is inner scrollbox we are scrolling the outer off-canvas down/up once the box end has been reached
        // This lets the user continue to touch move the off-canvas without the need to place the finger outside the scrollbox

        if (elem.hasAttribute('data-off-canvas-scrollbox')) {
          parent = elem.closest('[data-off-canvas], [data-off-canvas-scrollbox-outer]');

          if (elem.scrollTop <= 1 && parent.scrollTop > 0) {
            parent.scrollTop--;
          } else if (elem.scrollTop >= elem.scrollHeight - elem.clientHeight - 1 && parent.scrollTop < parent.scrollHeight - parent.clientHeight) {
            parent.scrollTop++;
          }
        }
      } else {
        event.preventDefault();
      }
    }
    /**
     * Opens the off-canvas menu.
     * @function
     * @param {Object} event - Event object passed from listener.
     * @param {jQuery} trigger - element that triggered the off-canvas to open.
     * @fires OffCanvas#opened
     * @todo also trigger 'open' event?
     */

  }, {
    key: "open",
    value: function open(event, trigger) {
      var _this4 = this;

      if (this.$element.hasClass('is-open') || this.isRevealed || this.isInCanvas) {
        return;
      }

      var _this = this;

      if (trigger) {
        this.$lastTrigger = trigger;
      }

      if (this.options.forceTo === 'top') {
        window.scrollTo(0, 0);
      } else if (this.options.forceTo === 'bottom') {
        window.scrollTo(0, document.body.scrollHeight);
      }

      if (this.options.transitionTime && this.options.transition !== 'overlap') {
        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', this.options.transitionTime);
      } else {
        this.$element.siblings('[data-off-canvas-content]').css('transition-duration', '');
      }

      this.$element.addClass('is-open').removeClass('is-closed');
      this.$triggers.attr('aria-expanded', 'true');
      this.$element.attr('aria-hidden', 'false');
      this.$content.addClass('is-open-' + this.position); // If `contentScroll` is set to false, add class and disable scrolling on touch devices.

      if (this.options.contentScroll === false) {
        (0, _jquery2.default)('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);
        this.$element.on('touchstart', this._recordScrollable);
        this.$element.on('touchmove', this._stopScrollPropagation);
        this.$element.on('touchstart', '[data-off-canvas-scrollbox]', this._recordScrollable);
        this.$element.on('touchmove', '[data-off-canvas-scrollbox]', this._stopScrollPropagation);
      }

      if (this.options.contentOverlay === true) {
        this.$overlay.addClass('is-visible');
      }

      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {
        this.$overlay.addClass('is-closable');
      }

      if (this.options.autoFocus === true) {
        this.$element.one(transitionend(this.$element), function () {
          if (!_this.$element.hasClass('is-open')) {
            return; // exit if prematurely closed
          }

          var canvasFocus = _this.$element.find('[data-autofocus]');

          if (canvasFocus.length) {
            canvasFocus.eq(0).focus();
          } else {
            _this.$element.find('a, button').eq(0).focus();
          }
        });
      }

      if (this.options.trapFocus === true) {
        this.$content.attr('tabindex', '-1');
        Keyboard.trapFocus(this.$element);
      }

      if (this.options.transition === 'push') {
        this._fixStickyElements();
      }

      this._addContentClasses();
      /**
       * Fires when the off-canvas menu opens.
       * @event OffCanvas#opened
       */

      this.$element.trigger('opened.zf.offCanvas');
      /**
       * Fires when the off-canvas menu open transition is done.
       * @event OffCanvas#openedEnd
       */

      this.$element.one(transitionend(this.$element), function () {
        _this4.$element.trigger('openedEnd.zf.offCanvas');
      });
    }
    /**
     * Closes the off-canvas menu.
     * @function
     * @param {Function} cb - optional cb to fire after closure.
     * @fires OffCanvas#close
     * @fires OffCanvas#closed
     */

  }, {
    key: "close",
    value: function close(cb) {
      var _this5 = this;

      if (!this.$element.hasClass('is-open') || this.isRevealed) {
        return;
      }
      /**
       * Fires when the off-canvas menu closes.
       * @event OffCanvas#close
       */

      this.$element.trigger('close.zf.offCanvas');

      this.$element.removeClass('is-open');
      this.$element.attr('aria-hidden', 'true');
      this.$content.removeClass('is-open-left is-open-top is-open-right is-open-bottom');

      if (this.options.contentOverlay === true) {
        this.$overlay.removeClass('is-visible');
      }

      if (this.options.closeOnClick === true && this.options.contentOverlay === true) {
        this.$overlay.removeClass('is-closable');
      }

      this.$triggers.attr('aria-expanded', 'false'); // Listen to transitionEnd: add class, re-enable scrolling and release focus when done.

      this.$element.one(transitionend(this.$element), function (e) {
        _this5.$element.addClass('is-closed');

        _this5._removeContentClasses();

        if (_this5.options.transition === 'push') {
          _this5._unfixStickyElements();
        } // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.


        if (_this5.options.contentScroll === false) {
          (0, _jquery2.default)('body').removeClass('is-off-canvas-open').off('touchmove', _this5._stopScrolling);

          _this5.$element.off('touchstart', _this5._recordScrollable);

          _this5.$element.off('touchmove', _this5._stopScrollPropagation);

          _this5.$element.off('touchstart', '[data-off-canvas-scrollbox]', _this5._recordScrollable);

          _this5.$element.off('touchmove', '[data-off-canvas-scrollbox]', _this5._stopScrollPropagation);
        }

        if (_this5.options.trapFocus === true) {
          _this5.$content.removeAttr('tabindex');

          Keyboard.releaseFocus(_this5.$element);
        }
        /**
         * Fires when the off-canvas menu close transition is done.
         * @event OffCanvas#closed
         */

        _this5.$element.trigger('closed.zf.offCanvas');
      });
    }
    /**
     * Toggles the off-canvas menu open or closed.
     * @function
     * @param {Object} event - Event object passed from listener.
     * @param {jQuery} trigger - element that triggered the off-canvas to open.
     */

  }, {
    key: "toggle",
    value: function toggle(event, trigger) {
      if (this.$element.hasClass('is-open')) {
        this.close(event, trigger);
      } else {
        this.open(event, trigger);
      }
    }
    /**
     * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
     * @function
     * @private
     */

  }, {
    key: "_handleKeyboard",
    value: function _handleKeyboard(e) {
      var _this6 = this;

      Keyboard.handleKey(e, 'OffCanvas', {
        close: function close() {
          _this6.close();

          _this6.$lastTrigger.focus();

          return true;
        },
        handled: function handled() {
          e.preventDefault();
        }
      });
    }
    /**
     * Destroys the OffCanvas plugin.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.close();
      this.$element.off('.zf.trigger .zf.offCanvas');
      this.$overlay.off('.zf.offCanvas');
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);
    }
  }]);

  return OffCanvas;
}(Plugin);

OffCanvas.defaults = {
  /**
   * Allow the user to click outside of the menu to close it.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Adds an overlay on top of `[data-off-canvas-content]`.
   * @option
   * @type {boolean}
   * @default true
   */
  contentOverlay: true,

  /**
   * Target an off-canvas content container by ID that may be placed anywhere. If null the closest content container will be taken.
   * @option
   * @type {?string}
   * @default null
   */
  contentId: null,

  /**
   * Define the off-canvas element is nested in an off-canvas content. This is required when using the contentId option for a nested element.
   * @option
   * @type {boolean}
   * @default null
   */
  nested: null,

  /**
   * Enable/disable scrolling of the main content when an off canvas panel is open.
   * @option
   * @type {boolean}
   * @default true
   */
  contentScroll: true,

  /**
   * Amount of time the open and close transition requires, including the appropriate milliseconds (`ms`) or seconds (`s`) unit (e.g. `500ms`, `.75s`) If none selected, pulls from body style.
   * @option
   * @type {string}
   * @default null
   */
  transitionTime: null,

  /**
   * Type of transition for the OffCanvas menu. Options are 'push', 'detached' or 'slide'.
   * @option
   * @type {string}
   * @default push
   */
  transition: 'push',

  /**
   * Force the page to scroll to top or bottom on open.
   * @option
   * @type {?string}
   * @default null
   */
  forceTo: null,

  /**
   * Allow the OffCanvas to remain open for certain breakpoints.
   * @option
   * @type {boolean}
   * @default false
   */
  isRevealed: false,

  /**
   * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.
   * @option
   * @type {?string}
   * @default null
   */
  revealOn: null,

  /**
   * Breakpoint at which the off-canvas gets moved into canvas content and acts as regular page element.
   * @option
   * @type {?string}
   * @default null
   */
  inCanvasOn: null,

  /**
   * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
   * @option
   * @type {boolean}
   * @default true
   */
  autoFocus: true,

  /**
   * Class used to force an OffCanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
   * @option
   * @type {string}
   * @default reveal-for-
   * @todo improve the regex testing for this.
   */
  revealClass: 'reveal-for-',

  /**
   * Triggers optional focus trapping when opening an OffCanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.
   * @option
   * @type {boolean}
   * @default false
   */
  trapFocus: false
};

/**
 * Orbit module.
 * @module foundation.orbit
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.timer
 * @requires foundation.util.imageLoader
 * @requires foundation.util.touch
 */

var Orbit =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Orbit, _Plugin);

  function Orbit() {
    _classCallCheck(this, Orbit);

    return _possibleConstructorReturn(this, _getPrototypeOf(Orbit).apply(this, arguments));
  }

  _createClass(Orbit, [{
    key: "_setup",

    /**
    * Creates a new instance of an orbit carousel.
    * @class
    * @name Orbit
    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.
    * @param {Object} options - Overrides to the default plugin settings.
    */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Orbit.defaults, this.$element.data(), options);
      this.className = 'Orbit'; // ie9 back compat

      Touch.init(_jquery2.default); // Touch init is idempotent, we just need to make sure it's initialied.

      this._init();

      Keyboard.register('Orbit', {
        'ltr': {
          'ARROW_RIGHT': 'next',
          'ARROW_LEFT': 'previous'
        },
        'rtl': {
          'ARROW_LEFT': 'next',
          'ARROW_RIGHT': 'previous'
        }
      });
    }
    /**
    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
    * @function
    * @private
    */

  }, {
    key: "_init",
    value: function _init() {
      // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide
      this._reset();

      this.$wrapper = this.$element.find(".".concat(this.options.containerClass));
      this.$slides = this.$element.find(".".concat(this.options.slideClass));
      var $images = this.$element.find('img'),
          initActive = this.$slides.filter('.is-active'),
          id = this.$element[0].id || GetYoDigits(6, 'orbit');
      this.$element.attr({
        'data-resize': id,
        'id': id
      });

      if (!initActive.length) {
        this.$slides.eq(0).addClass('is-active');
      }

      if (!this.options.useMUI) {
        this.$slides.addClass('no-motionui');
      }

      if ($images.length) {
        onImagesLoaded($images, this._prepareForOrbit.bind(this));
      } else {
        this._prepareForOrbit(); //hehe
      }

      if (this.options.bullets) {
        this._loadBullets();
      }

      this._events();

      if (this.options.autoPlay && this.$slides.length > 1) {
        this.geoSync();
      }

      if (this.options.accessible) {
        // allow wrapper to be focusable to enable arrow navigation
        this.$wrapper.attr('tabindex', 0);
      }
    }
    /**
    * Creates a jQuery collection of bullets, if they are being used.
    * @function
    * @private
    */

  }, {
    key: "_loadBullets",
    value: function _loadBullets() {
      this.$bullets = this.$element.find(".".concat(this.options.boxOfBullets)).find('button');
    }
    /**
    * Sets a `timer` object on the orbit, and starts the counter for the next slide.
    * @function
    */

  }, {
    key: "geoSync",
    value: function geoSync() {
      var _this = this;

      this.timer = new Timer(this.$element, {
        duration: this.options.timerDelay,
        infinite: false
      }, function () {
        _this.changeSlide(true);
      });
      this.timer.start();
    }
    /**
    * Sets wrapper and slide heights for the orbit.
    * @function
    * @private
    */

  }, {
    key: "_prepareForOrbit",
    value: function _prepareForOrbit() {

      this._setWrapperHeight();
    }
    /**
    * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
    * @function
    * @private
    * @param {Function} cb - a callback function to fire when complete.
    */

  }, {
    key: "_setWrapperHeight",
    value: function _setWrapperHeight(cb) {
      //rewrite this to `for` loop
      var max = 0,
          temp,
          counter = 0,
          _this = this;

      this.$slides.each(function () {
        temp = this.getBoundingClientRect().height;
        (0, _jquery2.default)(this).attr('data-slide', counter); // hide all slides but the active one

        if (!/mui/g.test((0, _jquery2.default)(this)[0].className) && _this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {
          (0, _jquery2.default)(this).css({
            'display': 'none'
          });
        }

        max = temp > max ? temp : max;
        counter++;
      });

      if (counter === this.$slides.length) {
        this.$wrapper.css({
          'height': max
        }); //only change the wrapper height property once.

        if (cb) {
          cb(max);
        } //fire callback with max height dimension.
      }
    }
    /**
    * Sets the max-height of each slide.
    * @function
    * @private
    */

  }, {
    key: "_setSlideHeight",
    value: function _setSlideHeight(height) {
      this.$slides.each(function () {
        (0, _jquery2.default)(this).css('max-height', height);
      });
    }
    /**
    * Adds event listeners to basically everything within the element.
    * @function
    * @private
    */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this; //***************************************
      //**Now using custom event - thanks to:**
      //**      Yohai Ararat of Toronto      **
      //***************************************
      //


      this.$element.off('.resizeme.zf.trigger').on({
        'resizeme.zf.trigger': this._prepareForOrbit.bind(this)
      });

      if (this.$slides.length > 1) {
        if (this.options.swipe) {
          this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide(true);
          }).on('swiperight.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide(false);
          });
        } //***************************************


        if (this.options.autoPlay) {
          this.$slides.on('click.zf.orbit', function () {
            _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);

            _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();
          });

          if (this.options.pauseOnHover) {
            this.$element.on('mouseenter.zf.orbit', function () {
              _this.timer.pause();
            }).on('mouseleave.zf.orbit', function () {
              if (!_this.$element.data('clickedOn')) {
                _this.timer.start();
              }
            });
          }
        }

        if (this.options.navButtons) {
          var $controls = this.$element.find(".".concat(this.options.nextClass, ", .").concat(this.options.prevClass));
          $controls.attr('tabindex', 0) //also need to handle enter/return and spacebar key presses
          .on('click.zf.orbit touchend.zf.orbit', function (e) {
            e.preventDefault();

            _this.changeSlide((0, _jquery2.default)(this).hasClass(_this.options.nextClass));
          });
        }

        if (this.options.bullets) {
          this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {
            if (/is-active/g.test(this.className)) {
              return false;
            } //if this is active, kick out of function.


            var idx = (0, _jquery2.default)(this).data('slide'),
                ltr = idx > _this.$slides.filter('.is-active').data('slide'),
                $slide = _this.$slides.eq(idx);

            _this.changeSlide(ltr, $slide, idx);
          });
        }

        if (this.options.accessible) {
          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {
            // handle keyboard event with keyboard util
            Keyboard.handleKey(e, 'Orbit', {
              next: function next() {
                _this.changeSlide(true);
              },
              previous: function previous() {
                _this.changeSlide(false);
              },
              handled: function handled() {
                // if bullet is focused, make sure focus moves
                if ((0, _jquery2.default)(e.target).is(_this.$bullets)) {
                  _this.$bullets.filter('.is-active').focus();
                }
              }
            });
          });
        }
      }
    }
    /**
     * Resets Orbit so it can be reinitialized
     */

  }, {
    key: "_reset",
    value: function _reset() {
      // Don't do anything if there are no slides (first run)
      if (typeof this.$slides == 'undefined') {
        return;
      }

      if (this.$slides.length > 1) {
        // Remove old events
        this.$element.off('.zf.orbit').find('*').off('.zf.orbit'); // Restart timer if autoPlay is enabled

        if (this.options.autoPlay) {
          this.timer.restart();
        } // Reset all sliddes


        this.$slides.each(function (el) {
          (0, _jquery2.default)(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();
        }); // Show the first slide

        this.$slides.first().addClass('is-active').show(); // Triggers when the slide has finished animating

        this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]); // Select first bullet if bullets are present

        if (this.options.bullets) {
          this._updateBullets(0);
        }
      }
    }
    /**
    * Changes the current slide to a new one.
    * @function
    * @param {Boolean} isLTR - if true the slide moves from right to left, if false the slide moves from left to right.
    * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
    * @param {Number} idx - the index of the new slide in its collection, if one chosen.
    * @fires Orbit#slidechange
    */

  }, {
    key: "changeSlide",
    value: function changeSlide(isLTR, chosenSlide, idx) {
      if (!this.$slides) {
        return;
      } // Don't freak out if we're in the middle of cleanup


      var $curSlide = this.$slides.filter('.is-active').eq(0);

      if (/mui/g.test($curSlide[0].className)) {
        return false;
      } //if the slide is currently animating, kick out of the function


      var $firstSlide = this.$slides.first(),
          $lastSlide = this.$slides.last(),
          dirIn = isLTR ? 'Right' : 'Left',
          dirOut = isLTR ? 'Left' : 'Right',
          _this = this,
          $newSlide;

      if (!chosenSlide) {
        //most of the time, this will be auto played or clicked from the navButtons.
        $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
        this.options.infiniteWrap ? $curSlide.next(".".concat(this.options.slideClass)).length ? $curSlide.next(".".concat(this.options.slideClass)) : $firstSlide : $curSlide.next(".".concat(this.options.slideClass)) : //pick next slide if moving left to right
        this.options.infiniteWrap ? $curSlide.prev(".".concat(this.options.slideClass)).length ? $curSlide.prev(".".concat(this.options.slideClass)) : $lastSlide : $curSlide.prev(".".concat(this.options.slideClass)); //pick prev slide if moving right to left
      } else {
        $newSlide = chosenSlide;
      }

      if ($newSlide.length) {
        /**
        * Triggers before the next slide starts animating in and only if a next slide has been found.
        * @event Orbit#beforeslidechange
        */
        this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);

        if (this.options.bullets) {
          idx = idx || this.$slides.index($newSlide); //grab index to update bullets

          this._updateBullets(idx);
        }

        if (this.options.useMUI && !this.$element.is(':hidden')) {
          Motion.animateIn($newSlide.addClass('is-active'), this.options["animInFrom".concat(dirIn)], function () {
            $newSlide.css({
              'display': 'block'
            }).attr('aria-live', 'polite');
          });
          Motion.animateOut($curSlide.removeClass('is-active'), this.options["animOutTo".concat(dirOut)], function () {
            $curSlide.removeAttr('aria-live');

            if (_this.options.autoPlay && !_this.timer.isPaused) {
              _this.timer.restart();
            } //do stuff?
          });
        } else {
          $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();
          $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();

          if (this.options.autoPlay && !this.timer.isPaused) {
            this.timer.restart();
          }
        }
        /**
        * Triggers when the slide has finished animating in.
        * @event Orbit#slidechange
        */

        this.$element.trigger('slidechange.zf.orbit', [$newSlide]);
      }
    }
    /**
    * Updates the active state of the bullets, if displayed.
    * Move the descriptor of the current slide `[data-slide-active-label]` to the newly active bullet.
    * If no `[data-slide-active-label]` is set, will move the exceeding `span` element.
    *
    * @function
    * @private
    * @param {Number} idx - the index of the current slide.
    */

  }, {
    key: "_updateBullets",
    value: function _updateBullets(idx) {
      var $oldBullet = this.$bullets.filter('.is-active');
      var $othersBullets = this.$bullets.not('.is-active');
      var $newBullet = this.$bullets.eq(idx);
      $oldBullet.removeClass('is-active').blur();
      $newBullet.addClass('is-active'); // Find the descriptor for the current slide to move it to the new slide button

      var activeStateDescriptor = $oldBullet.children('[data-slide-active-label]').last(); // If not explicitely given, search for the last "exceeding" span element (compared to others bullets).

      if (!activeStateDescriptor.length) {
        var spans = $oldBullet.children('span');
        var spanCountInOthersBullets = $othersBullets.toArray().map(function (b) {
          return (0, _jquery2.default)(b).children('span').length;
        }); // If there is an exceeding span element, use it as current slide descriptor

        if (spanCountInOthersBullets.every(function (count) {
          return count < spans.length;
        })) {
          activeStateDescriptor = spans.last();
          activeStateDescriptor.attr('data-slide-active-label', '');
        }
      } // Move the current slide descriptor to the new slide button


      if (activeStateDescriptor.length) {
        activeStateDescriptor.detach();
        $newBullet.append(activeStateDescriptor);
      }
    }
    /**
    * Destroys the carousel and hides the element.
    * @function
    */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();
    }
  }]);

  return Orbit;
}(Plugin);

Orbit.defaults = {
  /**
  * Tells the JS to look for and loadBullets.
  * @option
   * @type {boolean}
  * @default true
  */
  bullets: true,

  /**
  * Tells the JS to apply event listeners to nav buttons
  * @option
   * @type {boolean}
  * @default true
  */
  navButtons: true,

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-in-right'
  */
  animInFromRight: 'slide-in-right',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-out-right'
  */
  animOutToRight: 'slide-out-right',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-in-left'
  *
  */
  animInFromLeft: 'slide-in-left',

  /**
  * motion-ui animation class to apply
  * @option
   * @type {string}
  * @default 'slide-out-left'
  */
  animOutToLeft: 'slide-out-left',

  /**
  * Allows Orbit to automatically animate on page load.
  * @option
   * @type {boolean}
  * @default true
  */
  autoPlay: true,

  /**
  * Amount of time, in ms, between slide transitions
  * @option
   * @type {number}
  * @default 5000
  */
  timerDelay: 5000,

  /**
  * Allows Orbit to infinitely loop through the slides
  * @option
   * @type {boolean}
  * @default true
  */
  infiniteWrap: true,

  /**
  * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
  * @option
   * @type {boolean}
  * @default true
  */
  swipe: true,

  /**
  * Allows the timing function to pause animation on hover.
  * @option
   * @type {boolean}
  * @default true
  */
  pauseOnHover: true,

  /**
  * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
  * @option
   * @type {boolean}
  * @default true
  */
  accessible: true,

  /**
  * Class applied to the container of Orbit
  * @option
   * @type {string}
  * @default 'orbit-container'
  */
  containerClass: 'orbit-container',

  /**
  * Class applied to individual slides.
  * @option
   * @type {string}
  * @default 'orbit-slide'
  */
  slideClass: 'orbit-slide',

  /**
  * Class applied to the bullet container. You're welcome.
  * @option
   * @type {string}
  * @default 'orbit-bullets'
  */
  boxOfBullets: 'orbit-bullets',

  /**
  * Class applied to the `next` navigation button.
  * @option
   * @type {string}
  * @default 'orbit-next'
  */
  nextClass: 'orbit-next',

  /**
  * Class applied to the `previous` navigation button.
  * @option
   * @type {string}
  * @default 'orbit-previous'
  */
  prevClass: 'orbit-previous',

  /**
  * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatibility.
  * @option
   * @type {boolean}
  * @default true
  */
  useMUI: true
};

var MenuPlugins = {
  dropdown: {
    cssClass: 'dropdown',
    plugin: DropdownMenu
  },
  drilldown: {
    cssClass: 'drilldown',
    plugin: Drilldown
  },
  accordion: {
    cssClass: 'accordion-menu',
    plugin: AccordionMenu
  }
}; // import "foundation.util.triggers.js";

/**
 * ResponsiveMenu module.
 * @module foundation.responsiveMenu
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 */

var ResponsiveMenu =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveMenu, _Plugin);

  function ResponsiveMenu() {
    _classCallCheck(this, ResponsiveMenu);

    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveMenu).apply(this, arguments));
  }

  _createClass(ResponsiveMenu, [{
    key: "_setup",

    /**
     * Creates a new instance of a responsive menu.
     * @class
     * @name ResponsiveMenu
     * @fires ResponsiveMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.rules = this.$element.data('responsive-menu');
      this.currentMq = null;
      this.currentPlugin = null;
      this.className = 'ResponsiveMenu'; // ie9 back compat

      this._init();

      this._events();
    }
    /**
     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules


      if (typeof this.rules === 'string') {
        var rulesTree = {}; // Parse rules from "classes" pulled from data attribute

        var rules = this.rules.split(' '); // Iterate through every rule found

        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i].split('-');
          var ruleSize = rule.length > 1 ? rule[0] : 'small';
          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

          if (MenuPlugins[rulePlugin] !== null) {
            rulesTree[ruleSize] = MenuPlugins[rulePlugin];
          }
        }

        this.rules = rulesTree;
      }

      if (!_jquery2.default.isEmptyObject(this.rules)) {
        this._checkMediaQueries();
      } // Add data-mutate since children may need it.


      this.$element.attr('data-mutate', this.$element.attr('data-mutate') || GetYoDigits(6, 'responsive-menu'));
    }
    /**
     * Initializes events for the Menu.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      (0, _jquery2.default)(window).on('changed.zf.mediaquery', function () {
        _this._checkMediaQueries();
      }); // $(window).on('resize.zf.ResponsiveMenu', function() {
      //   _this._checkMediaQueries();
      // });
    }
    /**
     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
     * @function
     * @private
     */

  }, {
    key: "_checkMediaQueries",
    value: function _checkMediaQueries() {
      var matchedMq,
          _this = this; // Iterate through each rule and find the last matching rule


      _jquery2.default.each(this.rules, function (key) {
        if (MediaQuery.atLeast(key)) {
          matchedMq = key;
        }
      }); // No match? No dice

      if (!matchedMq) return; // Plugin already initialized? We good

      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes

      _jquery2.default.each(MenuPlugins, function (key, value) {
        _this.$element.removeClass(value.cssClass);
      }); // Add the CSS class for the new plugin

      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin

      if (this.currentPlugin) this.currentPlugin.destroy();
      this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});
    }
    /**
     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.currentPlugin.destroy();
      (0, _jquery2.default)(window).off('.zf.ResponsiveMenu');
    }
  }]);

  return ResponsiveMenu;
}(Plugin);

ResponsiveMenu.defaults = {};

/**
 * ResponsiveToggle module.
 * @module foundation.responsiveToggle
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion
 */

var ResponsiveToggle =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveToggle, _Plugin);

  function ResponsiveToggle() {
    _classCallCheck(this, ResponsiveToggle);

    return _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveToggle).apply(this, arguments));
  }

  _createClass(ResponsiveToggle, [{
    key: "_setup",

    /**
     * Creates a new instance of Tab Bar.
     * @class
     * @name ResponsiveToggle
     * @fires ResponsiveToggle#init
     * @param {jQuery} element - jQuery object to attach tab bar functionality to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.options = _jquery2.default.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);
      this.className = 'ResponsiveToggle'; // ie9 back compat

      this._init();

      this._events();
    }
    /**
     * Initializes the tab bar by finding the target element, toggling element, and running update().
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var targetID = this.$element.data('responsive-toggle');

      if (!targetID) {
        console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');
      }

      this.$targetMenu = (0, _jquery2.default)("#".concat(targetID));
      this.$toggler = this.$element.find('[data-toggle]').filter(function () {
        var target = (0, _jquery2.default)(this).data('toggle');
        return target === targetID || target === "";
      });
      this.options = _jquery2.default.extend({}, this.options, this.$targetMenu.data()); // If they were set, parse the animation classes

      if (this.options.animate) {
        var input = this.options.animate.split(' ');
        this.animationIn = input[0];
        this.animationOut = input[1] || null;
      }

      this._update();
    }
    /**
     * Adds necessary event handlers for the tab bar to work.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {

      this._updateMqHandler = this._update.bind(this);
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._updateMqHandler);
      this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));
    }
    /**
     * Checks the current media query to determine if the tab bar should be visible or hidden.
     * @function
     * @private
     */

  }, {
    key: "_update",
    value: function _update() {
      // Mobile
      if (!MediaQuery.atLeast(this.options.hideFor)) {
        this.$element.show();
        this.$targetMenu.hide();
      } // Desktop
      else {
          this.$element.hide();
          this.$targetMenu.show();
        }
    }
    /**
     * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
     * @function
     * @fires ResponsiveToggle#toggled
     */

  }, {
    key: "toggleMenu",
    value: function toggleMenu() {
      var _this2 = this;

      if (!MediaQuery.atLeast(this.options.hideFor)) {
        /**
         * Fires when the element attached to the tab bar toggles.
         * @event ResponsiveToggle#toggled
         */
        if (this.options.animate) {
          if (this.$targetMenu.is(':hidden')) {
            Motion.animateIn(this.$targetMenu, this.animationIn, function () {
              _this2.$element.trigger('toggled.zf.responsiveToggle');

              _this2.$targetMenu.find('[data-mutate]').triggerHandler('mutateme.zf.trigger');
            });
          } else {
            Motion.animateOut(this.$targetMenu, this.animationOut, function () {
              _this2.$element.trigger('toggled.zf.responsiveToggle');
            });
          }
        } else {
          this.$targetMenu.toggle(0);
          this.$targetMenu.find('[data-mutate]').trigger('mutateme.zf.trigger');
          this.$element.trigger('toggled.zf.responsiveToggle');
        }
      }
    }
  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.responsiveToggle');
      this.$toggler.off('.zf.responsiveToggle');
      (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._updateMqHandler);
    }
  }]);

  return ResponsiveToggle;
}(Plugin);

ResponsiveToggle.defaults = {
  /**
   * The breakpoint after which the menu is always shown, and the tab bar is hidden.
   * @option
   * @type {string}
   * @default 'medium'
   */
  hideFor: 'medium',

  /**
   * To decide if the toggle should be animated or not.
   * @option
   * @type {boolean}
   * @default false
   */
  animate: false
};

/**
 * Reveal module.
 * @module foundation.reveal
 * @requires foundation.util.keyboard
 * @requires foundation.util.touch
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion if using animations
 */

var Reveal =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Reveal, _Plugin);

  function Reveal() {
    _classCallCheck(this, Reveal);

    return _possibleConstructorReturn(this, _getPrototypeOf(Reveal).apply(this, arguments));
  }

  _createClass(Reveal, [{
    key: "_setup",

    /**
     * Creates a new instance of Reveal.
     * @class
     * @name Reveal
     * @param {jQuery} element - jQuery object to use for the modal.
     * @param {Object} options - optional parameters.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Reveal.defaults, this.$element.data(), options);
      this.className = 'Reveal'; // ie9 back compat

      this._init(); // Touch and Triggers init are idempotent, just need to make sure they are initialized


      Touch.init(_jquery2.default);
      Triggers.init(_jquery2.default);
      Keyboard.register('Reveal', {
        'ESCAPE': 'close'
      });
    }
    /**
     * Initializes the modal by adding the overlay and close buttons, (if selected).
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      MediaQuery._init();

      this.id = this.$element.attr('id');
      this.isActive = false;
      this.cached = {
        mq: MediaQuery.current
      };
      this.$anchor = (0, _jquery2.default)("[data-open=\"".concat(this.id, "\"]")).length ? (0, _jquery2.default)("[data-open=\"".concat(this.id, "\"]")) : (0, _jquery2.default)("[data-toggle=\"".concat(this.id, "\"]"));
      this.$anchor.attr({
        'aria-controls': this.id,
        'aria-haspopup': true,
        'tabindex': 0
      });

      if (this.options.fullScreen || this.$element.hasClass('full')) {
        this.options.fullScreen = true;
        this.options.overlay = false;
      }

      if (this.options.overlay && !this.$overlay) {
        this.$overlay = this._makeOverlay(this.id);
      }

      this.$element.attr({
        'role': 'dialog',
        'aria-hidden': true,
        'data-yeti-box': this.id,
        'data-resize': this.id
      });

      if (this.$overlay) {
        this.$element.detach().appendTo(this.$overlay);
      } else {
        this.$element.detach().appendTo((0, _jquery2.default)(this.options.appendTo));
        this.$element.addClass('without-overlay');
      }

      this._events();

      if (this.options.deepLink && window.location.hash === "#".concat(this.id)) {
        this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
          return _this2.open();
        });
      }
    }
    /**
     * Creates an overlay div to display behind the modal.
     * @private
     */

  }, {
    key: "_makeOverlay",
    value: function _makeOverlay() {
      var additionalOverlayClasses = '';

      if (this.options.additionalOverlayClasses) {
        additionalOverlayClasses = ' ' + this.options.additionalOverlayClasses;
      }

      return (0, _jquery2.default)('<div></div>').addClass('reveal-overlay' + additionalOverlayClasses).appendTo(this.options.appendTo);
    }
    /**
     * Updates position of modal
     * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
     * @private
     */

  }, {
    key: "_updatePosition",
    value: function _updatePosition() {
      var width = this.$element.outerWidth();
      var outerWidth = (0, _jquery2.default)(window).width();
      var height = this.$element.outerHeight();
      var outerHeight = (0, _jquery2.default)(window).height();
      var left,
          top = null;

      if (this.options.hOffset === 'auto') {
        left = parseInt((outerWidth - width) / 2, 10);
      } else {
        left = parseInt(this.options.hOffset, 10);
      }

      if (this.options.vOffset === 'auto') {
        if (height > outerHeight) {
          top = parseInt(Math.min(100, outerHeight / 10), 10);
        } else {
          top = parseInt((outerHeight - height) / 4, 10);
        }
      } else if (this.options.vOffset !== null) {
        top = parseInt(this.options.vOffset, 10);
      }

      if (top !== null) {
        this.$element.css({
          top: top + 'px'
        });
      } // only worry about left if we don't have an overlay or we have a horizontal offset,
      // otherwise we're perfectly in the middle


      if (!this.$overlay || this.options.hOffset !== 'auto') {
        this.$element.css({
          left: left + 'px'
        });
        this.$element.css({
          margin: '0px'
        });
      }
    }
    /**
     * Adds event handlers for the modal.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this3 = this;

      var _this = this;

      this.$element.on({
        'open.zf.trigger': this.open.bind(this),
        'close.zf.trigger': function closeZfTrigger(event, $element) {
          if (event.target === _this.$element[0] || (0, _jquery2.default)(event.target).parents('[data-closable]')[0] === $element) {
            // only close reveal when it's explicitly called
            return _this3.close.apply(_this3);
          }
        },
        'toggle.zf.trigger': this.toggle.bind(this),
        'resizeme.zf.trigger': function resizemeZfTrigger() {
          _this._updatePosition();
        }
      });

      if (this.options.closeOnClick && this.options.overlay) {
        this.$overlay.off('.zf.reveal').on('click.zf.dropdown tap.zf.dropdown', function (e) {
          if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target) || !_jquery2.default.contains(document, e.target)) {
            return;
          }

          _this.close();
        });
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on("hashchange.zf.reveal:".concat(this.id), this._handleState.bind(this));
      }
    }
    /**
     * Handles modal methods on back/forward button clicks or any other event that triggers hashchange.
     * @private
     */

  }, {
    key: "_handleState",
    value: function _handleState(e) {
      if (window.location.hash === '#' + this.id && !this.isActive) {
        this.open();
      } else {
        this.close();
      }
    }
    /**
    * Disables the scroll when Reveal is shown to prevent the background from shifting
    * @param {number} scrollTop - Scroll to visually apply, window current scroll by default
    */

  }, {
    key: "_disableScroll",
    value: function _disableScroll(scrollTop) {
      scrollTop = scrollTop || (0, _jquery2.default)(window).scrollTop();

      if ((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()) {
        (0, _jquery2.default)("html").css("top", -scrollTop);
      }
    }
    /**
    * Reenables the scroll when Reveal closes
    * @param {number} scrollTop - Scroll to restore, html "top" property by default (as set by `_disableScroll`)
    */

  }, {
    key: "_enableScroll",
    value: function _enableScroll(scrollTop) {
      scrollTop = scrollTop || parseInt((0, _jquery2.default)("html").css("top"));

      if ((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()) {
        (0, _jquery2.default)("html").css("top", "");
        (0, _jquery2.default)(window).scrollTop(-scrollTop);
      }
    }
    /**
     * Opens the modal controlled by `this.$anchor`, and closes all others by default.
     * @function
     * @fires Reveal#closeme
     * @fires Reveal#open
     */

  }, {
    key: "open",
    value: function open() {
      var _this4 = this;

      // either update or replace browser history
      var hash = "#".concat(this.id);

      if (this.options.deepLink && window.location.hash !== hash) {
        if (window.history.pushState) {
          if (this.options.updateHistory) {
            window.history.pushState({}, '', hash);
          } else {
            window.history.replaceState({}, '', hash);
          }
        } else {
          window.location.hash = hash;
        }
      } // Remember anchor that opened it to set focus back later, have general anchors as fallback


      this.$activeAnchor = (0, _jquery2.default)(document.activeElement).is(this.$anchor) ? (0, _jquery2.default)(document.activeElement) : this.$anchor;
      this.isActive = true; // Make elements invisible, but remove display: none so we can get size and positioning

      this.$element.css({
        'visibility': 'hidden'
      }).show().scrollTop(0);

      if (this.options.overlay) {
        this.$overlay.css({
          'visibility': 'hidden'
        }).show();
      }

      this._updatePosition();

      this.$element.hide().css({
        'visibility': ''
      });

      if (this.$overlay) {
        this.$overlay.css({
          'visibility': ''
        }).hide();

        if (this.$element.hasClass('fast')) {
          this.$overlay.addClass('fast');
        } else if (this.$element.hasClass('slow')) {
          this.$overlay.addClass('slow');
        }
      }

      if (!this.options.multipleOpened) {
        /**
         * Fires immediately before the modal opens.
         * Closes any other modals that are currently open
         * @event Reveal#closeme
         */
        this.$element.trigger('closeme.zf.reveal', this.id);
      }

      if ((0, _jquery2.default)('.reveal:visible').length === 0) {
        this._disableScroll();
      }

      var _this = this; // Motion UI method of reveal


      if (this.options.animationIn) {
        var afterAnimation = function afterAnimation() {
          _this.$element.attr({
            'aria-hidden': false,
            'tabindex': -1
          }).focus();

          _this._addGlobalClasses();

          Keyboard.trapFocus(_this.$element);
        };

        if (this.options.overlay) {
          Motion.animateIn(this.$overlay, 'fade-in');
        }

        Motion.animateIn(this.$element, this.options.animationIn, function () {
          if (_this4.$element) {
            // protect against object having been removed
            _this4.focusableElements = Keyboard.findFocusable(_this4.$element);
            afterAnimation();
          }
        });
      } // jQuery method of reveal
      else {
          if (this.options.overlay) {
            this.$overlay.show(0);
          }

          this.$element.show(this.options.showDelay);
        } // handle accessibility


      this.$element.attr({
        'aria-hidden': false,
        'tabindex': -1
      }).focus();
      Keyboard.trapFocus(this.$element);

      this._addGlobalClasses();

      this._addGlobalListeners();
      /**
       * Fires when the modal has successfully opened.
       * @event Reveal#open
       */

      this.$element.trigger('open.zf.reveal');
    }
    /**
     * Adds classes and listeners on document required by open modals.
     *
     * The following classes are added and updated:
     * - `.is-reveal-open` - Prevents the scroll on document
     * - `.zf-has-scroll`  - Displays a disabled scrollbar on document if required like if the
     *                       scroll was not disabled. This prevent a "shift" of the page content due
     *                       the scrollbar disappearing when the modal opens.
     *
     * @private
     */

  }, {
    key: "_addGlobalClasses",
    value: function _addGlobalClasses() {
      var updateScrollbarClass = function updateScrollbarClass() {
        (0, _jquery2.default)('html').toggleClass('zf-has-scroll', !!((0, _jquery2.default)(document).height() > (0, _jquery2.default)(window).height()));
      };

      this.$element.on('resizeme.zf.trigger.revealScrollbarListener', function () {
        return updateScrollbarClass();
      });
      updateScrollbarClass();
      (0, _jquery2.default)('html').addClass('is-reveal-open');
    }
    /**
     * Removes classes and listeners on document that were required by open modals.
     * @private
     */

  }, {
    key: "_removeGlobalClasses",
    value: function _removeGlobalClasses() {
      this.$element.off('resizeme.zf.trigger.revealScrollbarListener');
      (0, _jquery2.default)('html').removeClass('is-reveal-open');
      (0, _jquery2.default)('html').removeClass('zf-has-scroll');
    }
    /**
     * Adds extra event handlers for the body and window if necessary.
     * @private
     */

  }, {
    key: "_addGlobalListeners",
    value: function _addGlobalListeners() {
      var _this = this;

      if (!this.$element) {
        return;
      } // If we're in the middle of cleanup, don't freak out


      this.focusableElements = Keyboard.findFocusable(this.$element);

      if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {
        (0, _jquery2.default)('body').on('click.zf.dropdown tap.zf.dropdown', function (e) {
          if (e.target === _this.$element[0] || _jquery2.default.contains(_this.$element[0], e.target) || !_jquery2.default.contains(document, e.target)) {
            return;
          }

          _this.close();
        });
      }

      if (this.options.closeOnEsc) {
        (0, _jquery2.default)(window).on('keydown.zf.reveal', function (e) {
          Keyboard.handleKey(e, 'Reveal', {
            close: function close() {
              if (_this.options.closeOnEsc) {
                _this.close();
              }
            }
          });
        });
      }
    }
    /**
     * Closes the modal.
     * @function
     * @fires Reveal#closed
     */

  }, {
    key: "close",
    value: function close() {
      if (!this.isActive || !this.$element.is(':visible')) {
        return false;
      }

      var _this = this; // Motion UI method of hiding


      if (this.options.animationOut) {
        if (this.options.overlay) {
          Motion.animateOut(this.$overlay, 'fade-out');
        }

        Motion.animateOut(this.$element, this.options.animationOut, finishUp);
      } // jQuery method of hiding
      else {
          this.$element.hide(this.options.hideDelay);

          if (this.options.overlay) {
            this.$overlay.hide(0, finishUp);
          } else {
            finishUp();
          }
        } // Conditionals to remove extra event listeners added on open


      if (this.options.closeOnEsc) {
        (0, _jquery2.default)(window).off('keydown.zf.reveal');
      }

      if (!this.options.overlay && this.options.closeOnClick) {
        (0, _jquery2.default)('body').off('click.zf.dropdown tap.zf.dropdown');
      }

      this.$element.off('keydown.zf.reveal');

      function finishUp() {
        // Get the current top before the modal is closed and restore the scroll after.
        // TODO: use component properties instead of HTML properties
        // See https://github.com/foundation/foundation-sites/pull/10786
        var scrollTop = parseInt((0, _jquery2.default)("html").css("top"));

        if ((0, _jquery2.default)('.reveal:visible').length === 0) {
          _this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal
        }

        Keyboard.releaseFocus(_this.$element);

        _this.$element.attr('aria-hidden', true);

        if ((0, _jquery2.default)('.reveal:visible').length === 0) {
          _this._enableScroll(scrollTop);
        }
        /**
        * Fires when the modal is done closing.
        * @event Reveal#closed
        */

        _this.$element.trigger('closed.zf.reveal');
      }
      /**
      * Resets the modal content
      * This prevents a running video to keep going in the background
      */

      if (this.options.resetOnClose) {
        this.$element.html(this.$element.html());
      }

      this.isActive = false; // If deepLink and we did not switched to an other modal...

      if (_this.options.deepLink && window.location.hash === "#".concat(this.id)) {
        // Remove the history hash
        if (window.history.replaceState) {
          var urlWithoutHash = window.location.pathname + window.location.search;

          if (this.options.updateHistory) {
            window.history.pushState({}, '', urlWithoutHash); // remove the hash
          } else {
            window.history.replaceState('', document.title, urlWithoutHash);
          }
        } else {
          window.location.hash = '';
        }
      }

      this.$activeAnchor.focus();
    }
    /**
     * Toggles the open/closed state of a modal.
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.isActive) {
        this.close();
      } else {
        this.open();
      }
    }
  }, {
    key: "_destroy",

    /**
     * Destroys an instance of a modal.
     * @function
     */
    value: function _destroy() {
      if (this.options.overlay) {
        this.$element.appendTo((0, _jquery2.default)(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()

        this.$overlay.hide().off().remove();
      }

      this.$element.hide().off();
      this.$anchor.off('.zf');
      (0, _jquery2.default)(window).off(".zf.reveal:".concat(this.id));
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);

      if ((0, _jquery2.default)('.reveal:visible').length === 0) {
        this._removeGlobalClasses(); // also remove .is-reveal-open from the html element when there is no opened reveal
      }
    }
  }]);

  return Reveal;
}(Plugin);

Reveal.defaults = {
  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @type {string}
   * @default ''
   */
  animationIn: '',

  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @type {string}
   * @default ''
   */
  animationOut: '',

  /**
   * Time, in ms, to delay the opening of a modal after a click if no animation used.
   * @option
   * @type {number}
   * @default 0
   */
  showDelay: 0,

  /**
   * Time, in ms, to delay the closing of a modal after a click if no animation used.
   * @option
   * @type {number}
   * @default 0
   */
  hideDelay: 0,

  /**
   * Allows a click on the body/overlay to close the modal.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnClick: true,

  /**
   * Allows the modal to close if the user presses the `ESCAPE` key.
   * @option
   * @type {boolean}
   * @default true
   */
  closeOnEsc: true,

  /**
   * If true, allows multiple modals to be displayed at once.
   * @option
   * @type {boolean}
   * @default false
   */
  multipleOpened: false,

  /**
   * Distance, in pixels, the modal should push down from the top of the screen.
   * @option
   * @type {number|string}
   * @default auto
   */
  vOffset: 'auto',

  /**
   * Distance, in pixels, the modal should push in from the side of the screen.
   * @option
   * @type {number|string}
   * @default auto
   */
  hOffset: 'auto',

  /**
   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
   * @option
   * @type {boolean}
   * @default false
   */
  fullScreen: false,

  /**
   * Allows the modal to generate an overlay div, which will cover the view when modal opens.
   * @option
   * @type {boolean}
   * @default true
   */
  overlay: true,

  /**
   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
   * @option
   * @type {boolean}
   * @default false
   */
  resetOnClose: false,

  /**
   * Link the location hash to the modal.
   * Set the location hash when the modal is opened/closed, and open/close the modal when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, update the browser history with the open modal
   * @option
   * @default false
   */
  updateHistory: false,

  /**
  * Allows the modal to append to custom div.
  * @option
  * @type {string}
  * @default "body"
  */
  appendTo: "body",

  /**
   * Allows adding additional class names to the reveal overlay.
   * @option
   * @type {string}
   * @default ''
   */
  additionalOverlayClasses: ''
};

/**
 * Slider module.
 * @module foundation.slider
 * @requires foundation.util.motion
 * @requires foundation.util.triggers
 * @requires foundation.util.keyboard
 * @requires foundation.util.touch
 */

var Slider =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Slider, _Plugin);

  function Slider() {
    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, _getPrototypeOf(Slider).apply(this, arguments));
  }

  _createClass(Slider, [{
    key: "_setup",

    /**
     * Creates a new instance of a slider control.
     * @class
     * @name Slider
     * @param {jQuery} element - jQuery object to make into a slider control.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Slider.defaults, this.$element.data(), options);
      this.className = 'Slider'; // ie9 back compat
      // Touch and Triggers inits are idempotent, we just need to make sure it's initialied.

      Touch.init(_jquery2.default);
      Triggers.init(_jquery2.default);

      this._init();

      Keyboard.register('Slider', {
        'ltr': {
          'ARROW_RIGHT': 'increase',
          'ARROW_UP': 'increase',
          'ARROW_DOWN': 'decrease',
          'ARROW_LEFT': 'decrease',
          'SHIFT_ARROW_RIGHT': 'increase_fast',
          'SHIFT_ARROW_UP': 'increase_fast',
          'SHIFT_ARROW_DOWN': 'decrease_fast',
          'SHIFT_ARROW_LEFT': 'decrease_fast',
          'HOME': 'min',
          'END': 'max'
        },
        'rtl': {
          'ARROW_LEFT': 'increase',
          'ARROW_RIGHT': 'decrease',
          'SHIFT_ARROW_LEFT': 'increase_fast',
          'SHIFT_ARROW_RIGHT': 'decrease_fast'
        }
      });
    }
    /**
     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      this.inputs = this.$element.find('input');
      this.handles = this.$element.find('[data-slider-handle]');
      this.$handle = this.handles.eq(0);
      this.$input = this.inputs.length ? this.inputs.eq(0) : (0, _jquery2.default)("#".concat(this.$handle.attr('aria-controls')));
      this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);

      if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {
        this.options.disabled = true;
        this.$element.addClass(this.options.disabledClass);
      }

      if (!this.inputs.length) {
        this.inputs = (0, _jquery2.default)().add(this.$input);
        this.options.binding = true;
      }

      this._setInitAttr(0);

      if (this.handles[1]) {
        this.options.doubleSided = true;
        this.$handle2 = this.handles.eq(1);
        this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : (0, _jquery2.default)("#".concat(this.$handle2.attr('aria-controls')));

        if (!this.inputs[1]) {
          this.inputs = this.inputs.add(this.$input2);
        } // this.$handle.triggerHandler('click.zf.slider');


        this._setInitAttr(1);
      } // Set handle positions


      this.setHandles();

      this._events();
    }
  }, {
    key: "setHandles",
    value: function setHandles() {
      var _this2 = this;

      if (this.handles[1]) {
        this._setHandlePos(this.$handle, this.inputs.eq(0).val(), function () {
          _this2._setHandlePos(_this2.$handle2, _this2.inputs.eq(1).val());
        });
      } else {
        this._setHandlePos(this.$handle, this.inputs.eq(0).val());
      }
    }
  }, {
    key: "_reflow",
    value: function _reflow() {
      this.setHandles();
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)
    */

  }, {
    key: "_pctOfBar",
    value: function _pctOfBar(value) {
      var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);

      switch (this.options.positionValueFunction) {
        case "pow":
          pctOfBar = this._logTransform(pctOfBar);
          break;

        case "log":
          pctOfBar = this._powTransform(pctOfBar);
          break;
      }

      return pctOfBar.toFixed(2);
    }
    /**
    * @function
    * @private
    * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value
    */

  }, {
    key: "_value",
    value: function _value(pctOfBar) {
      switch (this.options.positionValueFunction) {
        case "pow":
          pctOfBar = this._powTransform(pctOfBar);
          break;

        case "log":
          pctOfBar = this._logTransform(pctOfBar);
          break;
      }

      var value;

      if (this.options.vertical) {
        // linear interpolation which is working with negative values for start
        // https://math.stackexchange.com/a/1019084
        value = parseFloat(this.options.end) + pctOfBar * (this.options.start - this.options.end);
      } else {
        value = (this.options.end - this.options.start) * pctOfBar + parseFloat(this.options.start);
      }

      return value;
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function
    */

  }, {
    key: "_logTransform",
    value: function _logTransform(value) {
      return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);
    }
    /**
    * @function
    * @private
    * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function
    */

  }, {
    key: "_powTransform",
    value: function _powTransform(value) {
      return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);
    }
    /**
     * Sets the position of the selected handle and fill bar.
     * @function
     * @private
     * @param {jQuery} $hndl - the selected handle to move.
     * @param {Number} location - floating point between the start and end values of the slider bar.
     * @param {Function} cb - callback function to fire on completion.
     * @fires Slider#moved
     * @fires Slider#changed
     */

  }, {
    key: "_setHandlePos",
    value: function _setHandlePos($hndl, location, cb) {
      // don't move if the slider has been disabled since its initialization
      if (this.$element.hasClass(this.options.disabledClass)) {
        return;
      } //might need to alter that slightly for bars that will have odd number selections.


      location = parseFloat(location); //on input change events, convert string to number...grumble.
      // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max

      if (location < this.options.start) {
        location = this.options.start;
      } else if (location > this.options.end) {
        location = this.options.end;
      }

      var isDbl = this.options.doubleSided;

      if (isDbl) {
        //this block is to prevent 2 handles from crossing eachother. Could/should be improved.
        if (this.handles.index($hndl) === 0) {
          var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));
          location = location >= h2Val ? h2Val - this.options.step : location;
        } else {
          var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));
          location = location <= h1Val ? h1Val + this.options.step : location;
        }
      }

      var _this = this,
          vert = this.options.vertical,
          hOrW = vert ? 'height' : 'width',
          lOrT = vert ? 'top' : 'left',
          handleDim = $hndl[0].getBoundingClientRect()[hOrW],
          elemDim = this.$element[0].getBoundingClientRect()[hOrW],

      //percentage of bar min/max value based on click or drag point
      pctOfBar = this._pctOfBar(location),

      //number of actual pixels to shift the handle, based on the percentage obtained above
      pxToMove = (elemDim - handleDim) * pctOfBar,

      //percentage of bar to shift the handle
      movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal); //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value


      location = parseFloat(location.toFixed(this.options.decimal)); // declare empty object for css adjustments, only used with 2 handled-sliders

      var css = {};

      this._setValues($hndl, location); // TODO update to calculate based on values set to respective inputs??


      if (isDbl) {
        var isLeftHndl = this.handles.index($hndl) === 0,

        //empty variable, will be used for min-height/width for fill bar
        dim,

        //percentage w/h of the handle compared to the slider bar
        handlePct = ~~(percent(handleDim, elemDim) * 100); //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar

        if (isLeftHndl) {
          //left or top percentage value to apply to the fill bar.
          css[lOrT] = "".concat(movement, "%"); //calculate the new min-height/width for the fill bar.

          dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct; //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider
          //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.

          if (cb && typeof cb === 'function') {
            cb();
          } //this is only needed for the initialization of 2 handled sliders
        } else {
          //just caching the value of the left/bottom handle's left/top property
          var handlePos = parseFloat(this.$handle[0].style[lOrT]); //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0
          //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself

          dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;
        } // assign the min-height/width to our css object


        css["min-".concat(hOrW)] = "".concat(dim, "%");
      }

      this.$element.one('finished.zf.animate', function () {
        /**
         * Fires when the handle is done moving.
         * @event Slider#moved
         */
        _this.$element.trigger('moved.zf.slider', [$hndl]);
      }); //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.

      var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;
      Move(moveTime, $hndl, function () {
        // adjusting the left/top property of the handle, based on the percentage calculated above
        // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,
        // fall back to next best guess.
        if (isNaN(movement)) {
          $hndl.css(lOrT, "".concat(pctOfBar * 100, "%"));
        } else {
          $hndl.css(lOrT, "".concat(movement, "%"));
        }

        if (!_this.options.doubleSided) {
          //if single-handled, a simple method to expand the fill bar
          _this.$fill.css(hOrW, "".concat(pctOfBar * 100, "%"));
        } else {
          //otherwise, use the css object we created above
          _this.$fill.css(css);
        }
      });
      /**
       * Fires when the value has not been change for a given time.
       * @event Slider#changed
       */

      clearTimeout(_this.timeout);
      _this.timeout = setTimeout(function () {
        _this.$element.trigger('changed.zf.slider', [$hndl]);
      }, _this.options.changedDelay);
    }
    /**
     * Sets the initial attribute for the slider element.
     * @function
     * @private
     * @param {Number} idx - index of the current handle/input to use.
     */

  }, {
    key: "_setInitAttr",
    value: function _setInitAttr(idx) {
      var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;
      var id = this.inputs.eq(idx).attr('id') || GetYoDigits(6, 'slider');
      this.inputs.eq(idx).attr({
        'id': id,
        'max': this.options.end,
        'min': this.options.start,
        'step': this.options.step
      });
      this.inputs.eq(idx).val(initVal);
      this.handles.eq(idx).attr({
        'role': 'slider',
        'aria-controls': id,
        'aria-valuemax': this.options.end,
        'aria-valuemin': this.options.start,
        'aria-valuenow': initVal,
        'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',
        'tabindex': 0
      });
    }
    /**
     * Sets the input and `aria-valuenow` values for the slider element.
     * @function
     * @private
     * @param {jQuery} $handle - the currently selected handle.
     * @param {Number} val - floating point of the new value.
     */

  }, {
    key: "_setValues",
    value: function _setValues($handle, val) {
      var idx = this.options.doubleSided ? this.handles.index($handle) : 0;
      this.inputs.eq(idx).val(val);
      $handle.attr('aria-valuenow', val);
    }
    /**
     * Handles events on the slider element.
     * Calculates the new location of the current handle.
     * If there are two handles and the bar was clicked, it determines which handle to move.
     * @function
     * @private
     * @param {Object} e - the `event` object passed from the listener.
     * @param {jQuery} $handle - the current handle to calculate for, if selected.
     * @param {Number} val - floating point number for the new value of the slider.
     * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.
     */

  }, {
    key: "_handleEvent",
    value: function _handleEvent(e, $handle, val) {
      var value;

      if (!val) {
        //click or drag events
        e.preventDefault();

        var _this = this,
            vertical = this.options.vertical,
            param = vertical ? 'height' : 'width',
            direction = vertical ? 'top' : 'left',
            eventOffset = vertical ? e.pageY : e.pageX,
            barDim = this.$element[0].getBoundingClientRect()[param],
            windowScroll = vertical ? (0, _jquery2.default)(window).scrollTop() : (0, _jquery2.default)(window).scrollLeft();

        var elemOffset = this.$element.offset()[direction]; // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...
        // best way to guess this is simulated is if clientY == pageY

        if (e.clientY === e.pageY) {
          eventOffset = eventOffset + windowScroll;
        }

        var eventFromBar = eventOffset - elemOffset;
        var barXY;

        if (eventFromBar < 0) {
          barXY = 0;
        } else if (eventFromBar > barDim) {
          barXY = barDim;
        } else {
          barXY = eventFromBar;
        }

        var offsetPct = percent(barXY, barDim);
        value = this._value(offsetPct); // turn everything around for RTL, yay math!

        if (rtl() && !this.options.vertical) {
          value = this.options.end - value;
        }

        value = _this._adjustValue(null, value); //boolean flag for the setHandlePos fn, specifically for vertical sliders

        if (!$handle) {
          //figure out which handle it is, pass it to the next function.
          var firstHndlPos = absPosition(this.$handle, direction, barXY, param),
              secndHndlPos = absPosition(this.$handle2, direction, barXY, param);
          $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;
        }
      } else {
        //change event on input
        value = this._adjustValue(null, val);
      }

      this._setHandlePos($handle, value);
    }
    /**
     * Adjustes value for handle in regard to step value. returns adjusted value
     * @function
     * @private
     * @param {jQuery} $handle - the selected handle.
     * @param {Number} value - value to adjust. used if $handle is falsy
     */

  }, {
    key: "_adjustValue",
    value: function _adjustValue($handle, value) {
      var val,
          step = this.options.step,
          div = parseFloat(step / 2),
          left,
          prev_val,
          next_val;

      if (!!$handle) {
        val = parseFloat($handle.attr('aria-valuenow'));
      } else {
        val = value;
      }

      if (val >= 0) {
        left = val % step;
      } else {
        left = step + val % step;
      }

      prev_val = val - left;
      next_val = prev_val + step;

      if (left === 0) {
        return val;
      }

      val = val >= prev_val + div ? next_val : prev_val;
      return val;
    }
    /**
     * Adds event listeners to the slider elements.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._eventsForHandle(this.$handle);

      if (this.handles[1]) {
        this._eventsForHandle(this.$handle2);
      }
    }
    /**
     * Adds event listeners a particular handle
     * @function
     * @private
     * @param {jQuery} $handle - the current handle to apply listeners to.
     */

  }, {
    key: "_eventsForHandle",
    value: function _eventsForHandle($handle) {
      var _this = this,
          curHandle;

      var handleChangeEvent = function handleChangeEvent(e) {
        var idx = _this.inputs.index((0, _jquery2.default)(this));

        _this._handleEvent(e, _this.handles.eq(idx), (0, _jquery2.default)(this).val());
      }; // IE only triggers the change event when the input loses focus which strictly follows the HTML specification
      // listen for the enter key and trigger a change
      // @see https://html.spec.whatwg.org/multipage/input.html#common-input-element-events


      this.inputs.off('keyup.zf.slider').on('keyup.zf.slider', function (e) {
        if (e.keyCode == 13) handleChangeEvent.call(this, e);
      });
      this.inputs.off('change.zf.slider').on('change.zf.slider', handleChangeEvent);

      if (this.options.clickSelect) {
        this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {
          if (_this.$element.data('dragging')) {
            return false;
          }

          if (!(0, _jquery2.default)(e.target).is('[data-slider-handle]')) {
            if (_this.options.doubleSided) {
              _this._handleEvent(e);
            } else {
              _this._handleEvent(e, _this.$handle);
            }
          }
        });
      }

      if (this.options.draggable) {
        this.handles.addTouch();
        var $body = (0, _jquery2.default)('body');
        $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {
          $handle.addClass('is-dragging');

          _this.$fill.addClass('is-dragging'); //


          _this.$element.data('dragging', true);

          curHandle = (0, _jquery2.default)(e.currentTarget);
          $body.on('mousemove.zf.slider', function (e) {
            e.preventDefault();

            _this._handleEvent(e, curHandle);
          }).on('mouseup.zf.slider', function (e) {
            _this._handleEvent(e, curHandle);

            $handle.removeClass('is-dragging');

            _this.$fill.removeClass('is-dragging');

            _this.$element.data('dragging', false);

            $body.off('mousemove.zf.slider mouseup.zf.slider');
          });
        }) // prevent events triggered by touch
        .on('selectstart.zf.slider touchmove.zf.slider', function (e) {
          e.preventDefault();
        });
      }

      $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {
        var _$handle = (0, _jquery2.default)(this),
            idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,
            oldValue = parseFloat(_this.inputs.eq(idx).val()),
            newValue; // handle keyboard event with keyboard util


        Keyboard.handleKey(e, 'Slider', {
          decrease: function decrease() {
            newValue = oldValue - _this.options.step;
          },
          increase: function increase() {
            newValue = oldValue + _this.options.step;
          },
          decrease_fast: function decrease_fast() {
            newValue = oldValue - _this.options.step * 10;
          },
          increase_fast: function increase_fast() {
            newValue = oldValue + _this.options.step * 10;
          },
          min: function min() {
            newValue = _this.options.start;
          },
          max: function max() {
            newValue = _this.options.end;
          },
          handled: function handled() {
            // only set handle pos when event was handled specially
            e.preventDefault();

            _this._setHandlePos(_$handle, newValue);
          }
        });
        /*if (newValue) { // if pressed key has special function, update value
          e.preventDefault();
          _this._setHandlePos(_$handle, newValue);
        }*/
      });
    }
    /**
     * Destroys the slider plugin.
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.handles.off('.zf.slider');
      this.inputs.off('.zf.slider');
      this.$element.off('.zf.slider');
      clearTimeout(this.timeout);
    }
  }]);

  return Slider;
}(Plugin);

Slider.defaults = {
  /**
   * Minimum value for the slider scale.
   * @option
   * @type {number}
   * @default 0
   */
  start: 0,

  /**
   * Maximum value for the slider scale.
   * @option
   * @type {number}
   * @default 100
   */
  end: 100,

  /**
   * Minimum value change per change event.
   * @option
   * @type {number}
   * @default 1
   */
  step: 1,

  /**
   * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
   * @option
   * @type {number}
   * @default 0
   */
  initialStart: 0,

  /**
   * Value at which the right handle/second input should be set to on initialization.
   * @option
   * @type {number}
   * @default 100
   */
  initialEnd: 100,

  /**
   * Allows the input to be located outside the container and visible. Set to by the JS
   * @option
   * @type {boolean}
   * @default false
   */
  binding: false,

  /**
   * Allows the user to click/tap on the slider bar to select a value.
   * @option
   * @type {boolean}
   * @default true
   */
  clickSelect: true,

  /**
   * Set to true and use the `vertical` class to change alignment to vertical.
   * @option
   * @type {boolean}
   * @default false
   */
  vertical: false,

  /**
   * Allows the user to drag the slider handle(s) to select a value.
   * @option
   * @type {boolean}
   * @default true
   */
  draggable: true,

  /**
   * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
   * @option
   * @type {boolean}
   * @default false
   */
  disabled: false,

  /**
   * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
   * @option
   * @type {boolean}
   * @default false
   */
  doubleSided: false,

  /**
   * Potential future feature.
   */
  // steps: 100,

  /**
   * Number of decimal places the plugin should go to for floating point precision.
   * @option
   * @type {number}
   * @default 2
   */
  decimal: 2,

  /**
   * Time delay for dragged elements.
   */
  // dragDelay: 0,

  /**
   * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
   * @option
   * @type {number}
   * @default 200
   */
  moveTime: 200,
  //update this if changing the transition time in the sass

  /**
   * Class applied to disabled sliders.
   * @option
   * @type {string}
   * @default 'disabled'
   */
  disabledClass: 'disabled',

  /**
   * Will invert the default layout for a vertical<span data-tooltip title="who would do this???"> </span>slider.
   * @option
   * @type {boolean}
   * @default false
   */
  invertVertical: false,

  /**
   * Milliseconds before the `changed.zf-slider` event is triggered after value change.
   * @option
   * @type {number}
   * @default 500
   */
  changedDelay: 500,

  /**
  * Basevalue for non-linear sliders
  * @option
  * @type {number}
  * @default 5
  */
  nonLinearBase: 5,

  /**
  * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.
  * @option
  * @type {string}
  * @default 'linear'
  */
  positionValueFunction: 'linear'
};

function percent(frac, num) {
  return frac / num;
}

function absPosition($handle, dir, clickPos, param) {
  return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);
}

function baseLog(base, value) {
  return Math.log(value) / Math.log(base);
}

/**
 * Sticky module.
 * @module foundation.sticky
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 */

var Sticky =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Sticky, _Plugin);

  function Sticky() {
    _classCallCheck(this, Sticky);

    return _possibleConstructorReturn(this, _getPrototypeOf(Sticky).apply(this, arguments));
  }

  _createClass(Sticky, [{
    key: "_setup",

    /**
     * Creates a new instance of a sticky thing.
     * @class
     * @name Sticky
     * @param {jQuery} element - jQuery object to make sticky.
     * @param {Object} options - options object passed when creating the element programmatically.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Sticky.defaults, this.$element.data(), options);
      this.className = 'Sticky'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();
    }
    /**
     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var $parent = this.$element.parent('[data-sticky-container]'),
          id = this.$element[0].id || GetYoDigits(6, 'sticky'),
          _this = this;

      if ($parent.length) {
        this.$container = $parent;
      } else {
        this.wasWrapped = true;
        this.$element.wrap(this.options.container);
        this.$container = this.$element.parent();
      }

      this.$container.addClass(this.options.containerClass);
      this.$element.addClass(this.options.stickyClass).attr({
        'data-resize': id,
        'data-mutate': id
      });

      if (this.options.anchor !== '') {
        (0, _jquery2.default)('#' + _this.options.anchor).attr({
          'data-mutate': id
        });
      }

      this.scrollCount = this.options.checkEvery;
      this.isStuck = false;
      this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
        //We calculate the container height to have correct values for anchor points offset calculation.
        _this.containerHeight = _this.$element.css("display") == "none" ? 0 : _this.$element[0].getBoundingClientRect().height;

        _this.$container.css('height', _this.containerHeight);

        _this.elemHeight = _this.containerHeight;

        if (_this.options.anchor !== '') {
          _this.$anchor = (0, _jquery2.default)('#' + _this.options.anchor);
        } else {
          _this._parsePoints();
        }

        _this._setSizes(function () {
          var scroll = window.pageYOffset;

          _this._calc(false, scroll); //Unstick the element will ensure that proper classes are set.


          if (!_this.isStuck) {
            _this._removeSticky(scroll >= _this.topPoint ? false : true);
          }
        });

        _this._events(id.split('-').reverse().join('-'));
      });
    }
    /**
     * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
     * @function
     * @private
     */

  }, {
    key: "_parsePoints",
    value: function _parsePoints() {
      var top = this.options.topAnchor == "" ? 1 : this.options.topAnchor,
          btm = this.options.btmAnchor == "" ? document.documentElement.scrollHeight : this.options.btmAnchor,
          pts = [top, btm],
          breaks = {};

      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {
        var pt;

        if (typeof pts[i] === 'number') {
          pt = pts[i];
        } else {
          var place = pts[i].split(':'),
              anchor = (0, _jquery2.default)("#".concat(place[0]));
          pt = anchor.offset().top;

          if (place[1] && place[1].toLowerCase() === 'bottom') {
            pt += anchor[0].getBoundingClientRect().height;
          }
        }

        breaks[i] = pt;
      }

      this.points = breaks;
      return;
    }
    /**
     * Adds event handlers for the scrolling element.
     * @private
     * @param {String} id - pseudo-random id for unique scroll event listener.
     */

  }, {
    key: "_events",
    value: function _events(id) {
      var _this = this,
          scrollListener = this.scrollListener = "scroll.zf.".concat(id);

      if (this.isOn) {
        return;
      }

      if (this.canStick) {
        this.isOn = true;
        (0, _jquery2.default)(window).off(scrollListener).on(scrollListener, function (e) {
          if (_this.scrollCount === 0) {
            _this.scrollCount = _this.options.checkEvery;

            _this._setSizes(function () {
              _this._calc(false, window.pageYOffset);
            });
          } else {
            _this.scrollCount--;

            _this._calc(false, window.pageYOffset);
          }
        });
      }

      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {
        _this._eventsHandler(id);
      });
      this.$element.on('mutateme.zf.trigger', function (e, el) {
        _this._eventsHandler(id);
      });

      if (this.$anchor) {
        this.$anchor.on('mutateme.zf.trigger', function (e, el) {
          _this._eventsHandler(id);
        });
      }
    }
    /**
     * Handler for events.
     * @private
     * @param {String} id - pseudo-random id for unique scroll event listener.
     */

  }, {
    key: "_eventsHandler",
    value: function _eventsHandler(id) {
      var _this = this,
          scrollListener = this.scrollListener = "scroll.zf.".concat(id);

      _this._setSizes(function () {
        _this._calc(false);

        if (_this.canStick) {
          if (!_this.isOn) {
            _this._events(id);
          }
        } else if (_this.isOn) {
          _this._pauseListeners(scrollListener);
        }
      });
    }
    /**
     * Removes event handlers for scroll and change events on anchor.
     * @fires Sticky#pause
     * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
     */

  }, {
    key: "_pauseListeners",
    value: function _pauseListeners(scrollListener) {
      this.isOn = false;
      (0, _jquery2.default)(window).off(scrollListener);
      /**
       * Fires when the plugin is paused due to resize event shrinking the view.
       * @event Sticky#pause
       * @private
       */

      this.$element.trigger('pause.zf.sticky');
    }
    /**
     * Called on every `scroll` event and on `_init`
     * fires functions based on booleans and cached values
     * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
     * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
     */

  }, {
    key: "_calc",
    value: function _calc(checkSizes, scroll) {
      if (checkSizes) {
        this._setSizes();
      }

      if (!this.canStick) {
        if (this.isStuck) {
          this._removeSticky(true);
        }

        return false;
      }

      if (!scroll) {
        scroll = window.pageYOffset;
      }

      if (scroll >= this.topPoint) {
        if (scroll <= this.bottomPoint) {
          if (!this.isStuck) {
            this._setSticky();
          }
        } else {
          if (this.isStuck) {
            this._removeSticky(false);
          }
        }
      } else {
        if (this.isStuck) {
          this._removeSticky(true);
        }
      }
    }
    /**
     * Causes the $element to become stuck.
     * Adds `position: fixed;`, and helper classes.
     * @fires Sticky#stuckto
     * @function
     * @private
     */

  }, {
    key: "_setSticky",
    value: function _setSticky() {
      var _this = this,
          stickTo = this.options.stickTo,
          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',
          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',
          css = {};

      css[mrgn] = "".concat(this.options[mrgn], "em");
      css[stickTo] = 0;
      css[notStuckTo] = 'auto';
      this.isStuck = true;
      this.$element.removeClass("is-anchored is-at-".concat(notStuckTo)).addClass("is-stuck is-at-".concat(stickTo)).css(css)
      /**
       * Fires when the $element has become `position: fixed;`
       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`
       * @event Sticky#stuckto
       */
      .trigger("sticky.zf.stuckto:".concat(stickTo));
      this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd", function () {
        _this._setSizes();
      });
    }
    /**
     * Causes the $element to become unstuck.
     * Removes `position: fixed;`, and helper classes.
     * Adds other helper classes.
     * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
     * @fires Sticky#unstuckfrom
     * @private
     */

  }, {
    key: "_removeSticky",
    value: function _removeSticky(isTop) {
      var stickTo = this.options.stickTo,
          stickToTop = stickTo === 'top',
          css = {},
          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,
          mrgn = stickToTop ? 'marginTop' : 'marginBottom',
          topOrBottom = isTop ? 'top' : 'bottom';
      css[mrgn] = 0;
      css['bottom'] = 'auto';

      if (isTop) {
        css['top'] = 0;
      } else {
        css['top'] = anchorPt;
      }

      this.isStuck = false;
      this.$element.removeClass("is-stuck is-at-".concat(stickTo)).addClass("is-anchored is-at-".concat(topOrBottom)).css(css)
      /**
       * Fires when the $element has become anchored.
       * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`
       * @event Sticky#unstuckfrom
       */
      .trigger("sticky.zf.unstuckfrom:".concat(topOrBottom));
    }
    /**
     * Sets the $element and $container sizes for plugin.
     * Calls `_setBreakPoints`.
     * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
     * @private
     */

  }, {
    key: "_setSizes",
    value: function _setSizes(cb) {
      this.canStick = MediaQuery.is(this.options.stickyOn);

      if (!this.canStick) {
        if (cb && typeof cb === 'function') {
          cb();
        }
      }

      var newElemWidth = this.$container[0].getBoundingClientRect().width,
          comp = window.getComputedStyle(this.$container[0]),
          pdngl = parseInt(comp['padding-left'], 10),
          pdngr = parseInt(comp['padding-right'], 10);

      if (this.$anchor && this.$anchor.length) {
        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;
      } else {
        this._parsePoints();
      }

      this.$element.css({
        'max-width': "".concat(newElemWidth - pdngl - pdngr, "px")
      }); // Recalculate the height only if it is "dynamic"

      if (this.options.dynamicHeight || !this.containerHeight) {
        // Get the sticked element height and apply it to the container to "hold the place"
        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;
        newContainerHeight = this.$element.css("display") == "none" ? 0 : newContainerHeight;
        this.$container.css('height', newContainerHeight);
        this.containerHeight = newContainerHeight;
      }

      this.elemHeight = this.containerHeight;

      if (!this.isStuck) {
        if (this.$element.hasClass('is-at-bottom')) {
          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;
          this.$element.css('top', anchorPt);
        }
      }

      this._setBreakPoints(this.containerHeight, function () {
        if (cb && typeof cb === 'function') {
          cb();
        }
      });
    }
    /**
     * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
     * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
     * @param {Function} cb - optional callback function to be called on completion.
     * @private
     */

  }, {
    key: "_setBreakPoints",
    value: function _setBreakPoints(elemHeight, cb) {
      if (!this.canStick) {
        if (cb && typeof cb === 'function') {
          cb();
        } else {
          return false;
        }
      }

      var mTop = emCalc(this.options.marginTop),
          mBtm = emCalc(this.options.marginBottom),
          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,
          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,

      // topPoint = this.$anchor.offset().top || this.points[0],
      // bottomPoint = topPoint + this.anchorHeight || this.points[1],
      winHeight = window.innerHeight;

      if (this.options.stickTo === 'top') {
        topPoint -= mTop;
        bottomPoint -= elemHeight + mTop;
      } else if (this.options.stickTo === 'bottom') {
        topPoint -= winHeight - (elemHeight + mBtm);
        bottomPoint -= winHeight - mBtm;
      }

      this.topPoint = topPoint;
      this.bottomPoint = bottomPoint;

      if (cb && typeof cb === 'function') {
        cb();
      }
    }
    /**
     * Destroys the current sticky element.
     * Resets the element to the top position first.
     * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this._removeSticky(true);

      this.$element.removeClass("".concat(this.options.stickyClass, " is-anchored is-at-top")).css({
        height: '',
        top: '',
        bottom: '',
        'max-width': ''
      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');

      if (this.$anchor && this.$anchor.length) {
        this.$anchor.off('change.zf.sticky');
      }

      if (this.scrollListener) (0, _jquery2.default)(window).off(this.scrollListener);
      if (this.onLoadListener) (0, _jquery2.default)(window).off(this.onLoadListener);

      if (this.wasWrapped) {
        this.$element.unwrap();
      } else {
        this.$container.removeClass(this.options.containerClass).css({
          height: ''
        });
      }
    }
  }]);

  return Sticky;
}(Plugin);

Sticky.defaults = {
  /**
   * Customizable container template. Add your own classes for styling and sizing.
   * @option
   * @type {string}
   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'
   */
  container: '<div data-sticky-container></div>',

  /**
   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.
   * @option
   * @type {string}
   * @default 'top'
   */
  stickTo: 'top',

  /**
   * If anchored to a single element, the id of that element.
   * @option
   * @type {string}
   * @default ''
   */
  anchor: '',

  /**
   * If using more than one element as anchor points, the id of the top anchor.
   * @option
   * @type {string}
   * @default ''
   */
  topAnchor: '',

  /**
   * If using more than one element as anchor points, the id of the bottom anchor.
   * @option
   * @type {string}
   * @default ''
   */
  btmAnchor: '',

  /**
   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
   * @option
   * @type {number}
   * @default 1
   */
  marginTop: 1,

  /**
   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
   * @option
   * @type {number}
   * @default 1
   */
  marginBottom: 1,

  /**
   * Breakpoint string that is the minimum screen size an element should become sticky.
   * @option
   * @type {string}
   * @default 'medium'
   */
  stickyOn: 'medium',

  /**
   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
   * @option
   * @type {string}
   * @default 'sticky'
   */
  stickyClass: 'sticky',

  /**
   * Class applied to sticky container. Foundation defaults to `sticky-container`.
   * @option
   * @type {string}
   * @default 'sticky-container'
   */
  containerClass: 'sticky-container',

  /**
   * If true (by default), keep the sticky container the same height as the element. Otherwise, the container height is set once and does not change.
   * @option
   * @type {boolean}
   * @default true
   */
  dynamicHeight: true,

  /**
   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
   * @option
   * @type {number}
   * @default -1
   */
  checkEvery: -1
};
/**
 * Helper function to calculate em values
 * @param Number {em} - number of em's to calculate into pixels
 */

function emCalc(em) {
  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;
}

/**
 * Tabs module.
 * @module foundation.tabs
 * @requires foundation.util.keyboard
 * @requires foundation.util.imageLoader if tabs contain images
 */

var Tabs =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Tabs, _Plugin);

  function Tabs() {
    _classCallCheck(this, Tabs);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tabs).apply(this, arguments));
  }

  _createClass(Tabs, [{
    key: "_setup",

    /**
     * Creates a new instance of tabs.
     * @class
     * @name Tabs
     * @fires Tabs#init
     * @param {jQuery} element - jQuery object to make into tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Tabs.defaults, this.$element.data(), options);
      this.className = 'Tabs'; // ie9 back compat

      this._init();

      Keyboard.register('Tabs', {
        'ENTER': 'open',
        'SPACE': 'open',
        'ARROW_RIGHT': 'next',
        'ARROW_UP': 'previous',
        'ARROW_DOWN': 'next',
        'ARROW_LEFT': 'previous' // 'TAB': 'next',
        // 'SHIFT_TAB': 'previous'

      });
    }
    /**
     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      var _this2 = this;

      var _this = this;

      this._isInitializing = true;
      this.$element.attr({
        'role': 'tablist'
      });
      this.$tabTitles = this.$element.find(".".concat(this.options.linkClass));
      this.$tabContent = (0, _jquery2.default)("[data-tabs-content=\"".concat(this.$element[0].id, "\"]"));
      this.$tabTitles.each(function () {
        var $elem = (0, _jquery2.default)(this),
            $link = $elem.find('a'),
            isActive = $elem.hasClass("".concat(_this.options.linkActiveClass)),
            hash = $link.attr('data-tabs-target') || $link[0].hash.slice(1),
            linkId = $link[0].id ? $link[0].id : "".concat(hash, "-label"),
            $tabContent = (0, _jquery2.default)("#".concat(hash));
        $elem.attr({
          'role': 'presentation'
        });
        $link.attr({
          'role': 'tab',
          'aria-controls': hash,
          'aria-selected': isActive,
          'id': linkId,
          'tabindex': isActive ? '0' : '-1'
        });
        $tabContent.attr({
          'role': 'tabpanel',
          'aria-labelledby': linkId
        }); // Save up the initial hash to return to it later when going back in history

        if (isActive) {
          _this._initialAnchor = "#".concat(hash);
        }

        if (!isActive) {
          $tabContent.attr('aria-hidden', 'true');
        }

        if (isActive && _this.options.autoFocus) {
          _this.onLoadListener = onLoad((0, _jquery2.default)(window), function () {
            (0, _jquery2.default)('html, body').animate({
              scrollTop: $elem.offset().top
            }, _this.options.deepLinkSmudgeDelay, function () {
              $link.focus();
            });
          });
        }
      });

      if (this.options.matchHeight) {
        var $images = this.$tabContent.find('img');

        if ($images.length) {
          onImagesLoaded($images, this._setHeight.bind(this));
        } else {
          this._setHeight();
        }
      } // Current context-bound function to open tabs on page load or history hashchange


      this._checkDeepLink = function () {
        var anchor = window.location.hash;

        if (!anchor.length) {
          // If we are still initializing and there is no anchor, then there is nothing to do
          if (_this2._isInitializing) return; // Otherwise, move to the initial anchor

          if (_this2._initialAnchor) anchor = _this2._initialAnchor;
        }

        var anchorNoHash = anchor.indexOf('#') >= 0 ? anchor.slice(1) : anchor;
        var $anchor = anchorNoHash && (0, _jquery2.default)("#".concat(anchorNoHash));

        var $link = anchor && _this2.$element.find("[href$=\"".concat(anchor, "\"],[data-tabs-target=\"").concat(anchorNoHash, "\"]")).first(); // Whether the anchor element that has been found is part of this element


        var isOwnAnchor = !!($anchor.length && $link.length);

        if (isOwnAnchor) {
          // If there is an anchor for the hash, select it
          if ($anchor && $anchor.length && $link && $link.length) {
            _this2.selectTab($anchor, true);
          } // Otherwise, collapse everything
          else {
              _this2._collapse();
            } // Roll up a little to show the titles


          if (_this2.options.deepLinkSmudge) {
            var offset = _this2.$element.offset();

            (0, _jquery2.default)('html, body').animate({
              scrollTop: offset.top
            }, _this2.options.deepLinkSmudgeDelay);
          }
          /**
           * Fires when the plugin has deeplinked at pageload
           * @event Tabs#deeplink
           */

          _this2.$element.trigger('deeplink.zf.tabs', [$link, $anchor]);
        }
      }; //use browser to open a tab, if it exists in this tabset


      if (this.options.deepLink) {
        this._checkDeepLink();
      }

      this._events();

      this._isInitializing = false;
    }
    /**
     * Adds event handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._addKeyHandler();

      this._addClickHandler();

      this._setHeightMqHandler = null;

      if (this.options.matchHeight) {
        this._setHeightMqHandler = this._setHeight.bind(this);
        (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._setHeightMqHandler);
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).on('hashchange', this._checkDeepLink);
      }
    }
    /**
     * Adds click handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_addClickHandler",
    value: function _addClickHandler() {
      var _this = this;

      this.$element.off('click.zf.tabs').on('click.zf.tabs', ".".concat(this.options.linkClass), function (e) {
        e.preventDefault();

        _this._handleTabChange((0, _jquery2.default)(this));
      });
    }
    /**
     * Adds keyboard event handlers for items within the tabs.
     * @private
     */

  }, {
    key: "_addKeyHandler",
    value: function _addKeyHandler() {
      var _this = this;

      this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {
        if (e.which === 9) return;
        var $element = (0, _jquery2.default)(this),
            $elements = $element.parent('ul').children('li'),
            $prevElement,
            $nextElement;
        $elements.each(function (i) {
          if ((0, _jquery2.default)(this).is($element)) {
            if (_this.options.wrapOnKeys) {
              $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);
              $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);
            } else {
              $prevElement = $elements.eq(Math.max(0, i - 1));
              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
            }

            return;
          }
        }); // handle keyboard event with keyboard util

        Keyboard.handleKey(e, 'Tabs', {
          open: function open() {
            $element.find('[role="tab"]').focus();

            _this._handleTabChange($element);
          },
          previous: function previous() {
            $prevElement.find('[role="tab"]').focus();

            _this._handleTabChange($prevElement);
          },
          next: function next() {
            $nextElement.find('[role="tab"]').focus();

            _this._handleTabChange($nextElement);
          },
          handled: function handled() {
            e.preventDefault();
          }
        });
      });
    }
    /**
     * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.
     * @param {jQuery} $target - Tab to open.
     * @param {boolean} historyHandled - browser has already handled a history update
     * @fires Tabs#change
     * @function
     */

  }, {
    key: "_handleTabChange",
    value: function _handleTabChange($target, historyHandled) {
      // With `activeCollapse`, if the target is the active Tab, collapse it.
      if ($target.hasClass("".concat(this.options.linkActiveClass))) {
        if (this.options.activeCollapse) {
          this._collapse();
        }

        return;
      }

      var $oldTab = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass)),
          $tabLink = $target.find('[role="tab"]'),
          target = $tabLink.attr('data-tabs-target'),
          anchor = target && target.length ? "#".concat(target) : $tabLink[0].hash,
          $targetContent = this.$tabContent.find(anchor); //close old tab

      this._collapseTab($oldTab); //open new tab


      this._openTab($target); //either replace or update browser history


      if (this.options.deepLink && !historyHandled) {
        if (this.options.updateHistory) {
          history.pushState({}, '', anchor);
        } else {
          history.replaceState({}, '', anchor);
        }
      }
      /**
       * Fires when the plugin has successfully changed tabs.
       * @event Tabs#change
       */

      this.$element.trigger('change.zf.tabs', [$target, $targetContent]); //fire to children a mutation event

      $targetContent.find("[data-mutate]").trigger("mutateme.zf.trigger");
    }
    /**
     * Opens the tab `$targetContent` defined by `$target`.
     * @param {jQuery} $target - Tab to open.
     * @function
     */

  }, {
    key: "_openTab",
    value: function _openTab($target) {
      var $tabLink = $target.find('[role="tab"]'),
          hash = $tabLink.attr('data-tabs-target') || $tabLink[0].hash.slice(1),
          $targetContent = this.$tabContent.find("#".concat(hash));
      $target.addClass("".concat(this.options.linkActiveClass));
      $tabLink.attr({
        'aria-selected': 'true',
        'tabindex': '0'
      });
      $targetContent.addClass("".concat(this.options.panelActiveClass)).removeAttr('aria-hidden');
    }
    /**
     * Collapses `$targetContent` defined by `$target`.
     * @param {jQuery} $target - Tab to collapse.
     * @function
     */

  }, {
    key: "_collapseTab",
    value: function _collapseTab($target) {
      var $target_anchor = $target.removeClass("".concat(this.options.linkActiveClass)).find('[role="tab"]').attr({
        'aria-selected': 'false',
        'tabindex': -1
      });
      (0, _jquery2.default)("#".concat($target_anchor.attr('aria-controls'))).removeClass("".concat(this.options.panelActiveClass)).attr({
        'aria-hidden': 'true'
      });
    }
    /**
     * Collapses the active Tab.
     * @fires Tabs#collapse
     * @function
     */

  }, {
    key: "_collapse",
    value: function _collapse() {
      var $activeTab = this.$element.find(".".concat(this.options.linkClass, ".").concat(this.options.linkActiveClass));

      if ($activeTab.length) {
        this._collapseTab($activeTab);
        /**
        * Fires when the plugin has successfully collapsed tabs.
        * @event Tabs#collapse
        */

        this.$element.trigger('collapse.zf.tabs', [$activeTab]);
      }
    }
    /**
     * Public method for selecting a content pane to display.
     * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
     * @param {boolean} historyHandled - browser has already handled a history update
     * @function
     */

  }, {
    key: "selectTab",
    value: function selectTab(elem, historyHandled) {
      var idStr, hashIdStr;

      if (_typeof(elem) === 'object') {
        idStr = elem[0].id;
      } else {
        idStr = elem;
      }

      if (idStr.indexOf('#') < 0) {
        hashIdStr = "#".concat(idStr);
      } else {
        hashIdStr = idStr;
        idStr = idStr.slice(1);
      }

      var $target = this.$tabTitles.has("[href$=\"".concat(hashIdStr, "\"],[data-tabs-target=\"").concat(idStr, "\"]")).first();

      this._handleTabChange($target, historyHandled);
    }
  }, {
    key: "_setHeight",

    /**
     * Sets the height of each panel to the height of the tallest panel.
     * If enabled in options, gets called on media query change.
     * If loading content via external source, can be called directly or with _reflow.
     * If enabled with `data-match-height="true"`, tabs sets to equal height
     * @function
     * @private
     */
    value: function _setHeight() {
      var max = 0,
          _this = this; // Lock down the `this` value for the root tabs object


      this.$tabContent.find(".".concat(this.options.panelClass)).css('height', '').each(function () {
        var panel = (0, _jquery2.default)(this),
            isActive = panel.hasClass("".concat(_this.options.panelActiveClass)); // get the options from the parent instead of trying to get them from the child

        if (!isActive) {
          panel.css({
            'visibility': 'hidden',
            'display': 'block'
          });
        }

        var temp = this.getBoundingClientRect().height;

        if (!isActive) {
          panel.css({
            'visibility': '',
            'display': ''
          });
        }

        max = temp > max ? temp : max;
      }).css('height', "".concat(max, "px"));
    }
    /**
     * Destroys an instance of tabs.
     * @fires Tabs#destroyed
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.find(".".concat(this.options.linkClass)).off('.zf.tabs').hide().end().find(".".concat(this.options.panelClass)).hide();

      if (this.options.matchHeight) {
        if (this._setHeightMqHandler != null) {
          (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._setHeightMqHandler);
        }
      }

      if (this.options.deepLink) {
        (0, _jquery2.default)(window).off('hashchange', this._checkDeepLink);
      }

      if (this.onLoadListener) {
        (0, _jquery2.default)(window).off(this.onLoadListener);
      }
    }
  }]);

  return Tabs;
}(Plugin);

Tabs.defaults = {
  /**
   * Link the location hash to the active pane.
   * Set the location hash when the active pane changes, and open the corresponding pane when the location changes.
   * @option
   * @type {boolean}
   * @default false
   */
  deepLink: false,

  /**
   * If `deepLink` is enabled, adjust the deep link scroll to make sure the top of the tab panel is visible
   * @option
   * @type {boolean}
   * @default false
   */
  deepLinkSmudge: false,

  /**
   * If `deepLinkSmudge` is enabled, animation time (ms) for the deep link adjustment
   * @option
   * @type {number}
   * @default 300
   */
  deepLinkSmudgeDelay: 300,

  /**
   * If `deepLink` is enabled, update the browser history with the open tab
   * @option
   * @type {boolean}
   * @default false
   */
  updateHistory: false,

  /**
   * Allows the window to scroll to content of active pane on load.
   * Not recommended if more than one tab panel per page.
   * @option
   * @type {boolean}
   * @default false
   */
  autoFocus: false,

  /**
   * Allows keyboard input to 'wrap' around the tab links.
   * @option
   * @type {boolean}
   * @default true
   */
  wrapOnKeys: true,

  /**
   * Allows the tab content panes to match heights if set to true.
   * @option
   * @type {boolean}
   * @default false
   */
  matchHeight: false,

  /**
   * Allows active tabs to collapse when clicked.
   * @option
   * @type {boolean}
   * @default false
   */
  activeCollapse: false,

  /**
   * Class applied to `li`'s in tab link list.
   * @option
   * @type {string}
   * @default 'tabs-title'
   */
  linkClass: 'tabs-title',

  /**
   * Class applied to the active `li` in tab link list.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  linkActiveClass: 'is-active',

  /**
   * Class applied to the content containers.
   * @option
   * @type {string}
   * @default 'tabs-panel'
   */
  panelClass: 'tabs-panel',

  /**
   * Class applied to the active content container.
   * @option
   * @type {string}
   * @default 'is-active'
   */
  panelActiveClass: 'is-active'
};

/**
 * Toggler module.
 * @module foundation.toggler
 * @requires foundation.util.motion
 * @requires foundation.util.triggers
 */

var Toggler =
/*#__PURE__*/
function (_Plugin) {
  _inherits(Toggler, _Plugin);

  function Toggler() {
    _classCallCheck(this, Toggler);

    return _possibleConstructorReturn(this, _getPrototypeOf(Toggler).apply(this, arguments));
  }

  _createClass(Toggler, [{
    key: "_setup",

    /**
     * Creates a new instance of Toggler.
     * @class
     * @name Toggler
     * @fires Toggler#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Toggler.defaults, element.data(), options);
      this.className = '';
      this.className = 'Toggler'; // ie9 back compat
      // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();

      this._events();
    }
    /**
     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      // Collect triggers to set ARIA attributes to
      var id = this.$element[0].id,
          $triggers = (0, _jquery2.default)("[data-open~=\"".concat(id, "\"], [data-close~=\"").concat(id, "\"], [data-toggle~=\"").concat(id, "\"]"));
      var input; // Parse animation classes if they were set

      if (this.options.animate) {
        input = this.options.animate.split(' ');
        this.animationIn = input[0];
        this.animationOut = input[1] || null; // - aria-expanded: according to the element visibility.

        $triggers.attr('aria-expanded', !this.$element.is(':hidden'));
      } // Otherwise, parse toggle class
      else {
          input = this.options.toggler;

          if (typeof input !== 'string' || !input.length) {
            throw new Error("The 'toogler' option containing the target class is required, got \"".concat(input, "\""));
          } // Allow for a . at the beginning of the string


          this.className = input[0] === '.' ? input.slice(1) : input; // - aria-expanded: according to the elements class set.

          $triggers.attr('aria-expanded', this.$element.hasClass(this.className));
        } // - aria-controls: adding the element id to it if not already in it.


      $triggers.each(function (index, trigger) {
        var $trigger = (0, _jquery2.default)(trigger);
        var controls = $trigger.attr('aria-controls') || '';
        var containsId = new RegExp("\\b".concat(RegExpEscape(id), "\\b")).test(controls);
        if (!containsId) $trigger.attr('aria-controls', controls ? "".concat(controls, " ").concat(id) : id);
      });
    }
    /**
     * Initializes events for the toggle trigger.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));
    }
    /**
     * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
     * @function
     * @fires Toggler#on
     * @fires Toggler#off
     */

  }, {
    key: "toggle",
    value: function toggle() {
      this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();
    }
  }, {
    key: "_toggleClass",
    value: function _toggleClass() {
      this.$element.toggleClass(this.className);
      var isOn = this.$element.hasClass(this.className);

      if (isOn) {
        /**
         * Fires if the target element has the class after a toggle.
         * @event Toggler#on
         */
        this.$element.trigger('on.zf.toggler');
      } else {
        /**
         * Fires if the target element does not have the class after a toggle.
         * @event Toggler#off
         */
        this.$element.trigger('off.zf.toggler');
      }

      this._updateARIA(isOn);

      this.$element.find('[data-mutate]').trigger('mutateme.zf.trigger');
    }
  }, {
    key: "_toggleAnimate",
    value: function _toggleAnimate() {
      var _this = this;

      if (this.$element.is(':hidden')) {
        Motion.animateIn(this.$element, this.animationIn, function () {
          _this._updateARIA(true);

          this.trigger('on.zf.toggler');
          this.find('[data-mutate]').trigger('mutateme.zf.trigger');
        });
      } else {
        Motion.animateOut(this.$element, this.animationOut, function () {
          _this._updateARIA(false);

          this.trigger('off.zf.toggler');
          this.find('[data-mutate]').trigger('mutateme.zf.trigger');
        });
      }
    }
  }, {
    key: "_updateARIA",
    value: function _updateARIA(isOn) {
      var id = this.$element[0].id;
      (0, _jquery2.default)("[data-open=\"".concat(id, "\"], [data-close=\"").concat(id, "\"], [data-toggle=\"").concat(id, "\"]")).attr({
        'aria-expanded': isOn ? true : false
      });
    }
    /**
     * Destroys the instance of Toggler on the element.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.off('.zf.toggler');
    }
  }]);

  return Toggler;
}(Plugin);

Toggler.defaults = {
  /**
   * Class of the element to toggle. It can be provided with or without "."
   * @option
   * @type {string}
   */
  toggler: undefined,

  /**
   * Tells the plugin if the element should animated when toggled.
   * @option
   * @type {boolean}
   * @default false
   */
  animate: false
};

/**
 * Tooltip module.
 * @module foundation.tooltip
 * @requires foundation.util.box
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.triggers
 */

var Tooltip =
/*#__PURE__*/
function (_Positionable) {
  _inherits(Tooltip, _Positionable);

  function Tooltip() {
    _classCallCheck(this, Tooltip);

    return _possibleConstructorReturn(this, _getPrototypeOf(Tooltip).apply(this, arguments));
  }

  _createClass(Tooltip, [{
    key: "_setup",

    /**
     * Creates a new instance of a Tooltip.
     * @class
     * @name Tooltip
     * @fires Tooltip#init
     * @param {jQuery} element - jQuery object to attach a tooltip to.
     * @param {Object} options - object to extend the default configuration.
     */
    value: function _setup(element, options) {
      this.$element = element;
      this.options = _jquery2.default.extend({}, Tooltip.defaults, this.$element.data(), options);
      this.className = 'Tooltip'; // ie9 back compat

      this.isActive = false;
      this.isClick = false; // Triggers init is idempotent, just need to make sure it is initialized

      Triggers.init(_jquery2.default);

      this._init();
    }
    /**
     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init();

      var elemId = this.$element.attr('aria-describedby') || GetYoDigits(6, 'tooltip');
      this.options.tipText = this.options.tipText || this.$element.attr('title');
      this.template = this.options.template ? (0, _jquery2.default)(this.options.template) : this._buildTemplate(elemId);

      if (this.options.allowHtml) {
        this.template.appendTo(document.body).html(this.options.tipText).hide();
      } else {
        this.template.appendTo(document.body).text(this.options.tipText).hide();
      }

      this.$element.attr({
        'title': '',
        'aria-describedby': elemId,
        'data-yeti-box': elemId,
        'data-toggle': elemId,
        'data-resize': elemId
      }).addClass(this.options.triggerClass);

      _get(_getPrototypeOf(Tooltip.prototype), "_init", this).call(this);

      this._events();
    }
  }, {
    key: "_getDefaultPosition",
    value: function _getDefaultPosition() {
      // handle legacy classnames
      var elementClassName = this.$element[0].className;

      if (this.$element[0] instanceof SVGElement) {
        elementClassName = elementClassName.baseVal;
      }

      var position = elementClassName.match(/\b(top|left|right|bottom)\b/g);
      return position ? position[0] : 'top';
    }
  }, {
    key: "_getDefaultAlignment",
    value: function _getDefaultAlignment() {
      return 'center';
    }
  }, {
    key: "_getHOffset",
    value: function _getHOffset() {
      if (this.position === 'left' || this.position === 'right') {
        return this.options.hOffset + this.options.tooltipWidth;
      } else {
        return this.options.hOffset;
      }
    }
  }, {
    key: "_getVOffset",
    value: function _getVOffset() {
      if (this.position === 'top' || this.position === 'bottom') {
        return this.options.vOffset + this.options.tooltipHeight;
      } else {
        return this.options.vOffset;
      }
    }
    /**
     * builds the tooltip element, adds attributes, and returns the template.
     * @private
     */

  }, {
    key: "_buildTemplate",
    value: function _buildTemplate(id) {
      var templateClasses = "".concat(this.options.tooltipClass, " ").concat(this.options.templateClasses).trim();
      var $template = (0, _jquery2.default)('<div></div>').addClass(templateClasses).attr({
        'role': 'tooltip',
        'aria-hidden': true,
        'data-is-active': false,
        'data-is-focus': false,
        'id': id
      });
      return $template;
    }
    /**
     * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
     * if the tooltip is larger than the screen width, default to full width - any user selected margin
     * @private
     */

  }, {
    key: "_setPosition",
    value: function _setPosition() {
      _get(_getPrototypeOf(Tooltip.prototype), "_setPosition", this).call(this, this.$element, this.template);
    }
    /**
     * reveals the tooltip, and fires an event to close any other open tooltips on the page
     * @fires Tooltip#closeme
     * @fires Tooltip#show
     * @function
     */

  }, {
    key: "show",
    value: function show() {
      if (this.options.showOn !== 'all' && !MediaQuery.is(this.options.showOn)) {
        // console.error('The screen is too small to display this tooltip');
        return false;
      }

      var _this = this;

      this.template.css('visibility', 'hidden').show();

      this._setPosition();

      this.template.removeClass('top bottom left right').addClass(this.position);
      this.template.removeClass('align-top align-bottom align-left align-right align-center').addClass('align-' + this.alignment);
      /**
       * Fires to close all other open tooltips on the page
       * @event Closeme#tooltip
       */

      this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));
      this.template.attr({
        'data-is-active': true,
        'aria-hidden': false
      });
      _this.isActive = true; // console.log(this.template);

      this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {//maybe do stuff?
      });
      /**
       * Fires when the tooltip is shown
       * @event Tooltip#show
       */

      this.$element.trigger('show.zf.tooltip');
    }
    /**
     * Hides the current tooltip, and resets the positioning class if it was changed due to collision
     * @fires Tooltip#hide
     * @function
     */

  }, {
    key: "hide",
    value: function hide() {
      // console.log('hiding', this.$element.data('yeti-box'));
      var _this = this;

      this.template.stop().attr({
        'aria-hidden': true,
        'data-is-active': false
      }).fadeOut(this.options.fadeOutDuration, function () {
        _this.isActive = false;
        _this.isClick = false;
      });
      /**
       * fires when the tooltip is hidden
       * @event Tooltip#hide
       */

      this.$element.trigger('hide.zf.tooltip');
    }
    /**
     * adds event listeners for the tooltip and its anchor
     * TODO combine some of the listeners like focus and mouseenter, etc.
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      var _this = this;

      var hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined';
      var $template = this.template;
      var isFocus = false; // `disableForTouch: Fully disable the tooltip on touch devices

      if (hasTouch && this.options.disableForTouch) return;

      if (!this.options.disableHover) {
        this.$element.on('mouseenter.zf.tooltip', function (e) {
          if (!_this.isActive) {
            _this.timeout = setTimeout(function () {
              _this.show();
            }, _this.options.hoverDelay);
          }
        }).on('mouseleave.zf.tooltip', ignoreMousedisappear(function (e) {
          clearTimeout(_this.timeout);

          if (!isFocus || _this.isClick && !_this.options.clickOpen) {
            _this.hide();
          }
        }));
      }

      if (hasTouch) {
        this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {
          _this.isActive ? _this.hide() : _this.show();
        });
      }

      if (this.options.clickOpen) {
        this.$element.on('mousedown.zf.tooltip', function (e) {
          if (_this.isClick) ;else {
            _this.isClick = true;

            if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {
              _this.show();
            }
          }
        });
      } else {
        this.$element.on('mousedown.zf.tooltip', function (e) {
          _this.isClick = true;
        });
      }

      this.$element.on({
        // 'toggle.zf.trigger': this.toggle.bind(this),
        // 'close.zf.trigger': this.hide.bind(this)
        'close.zf.trigger': this.hide.bind(this)
      });
      this.$element.on('focus.zf.tooltip', function (e) {
        isFocus = true;

        if (_this.isClick) {
          // If we're not showing open on clicks, we need to pretend a click-launched focus isn't
          // a real focus, otherwise on hover and come back we get bad behavior
          if (!_this.options.clickOpen) {
            isFocus = false;
          }

          return false;
        } else {
          _this.show();
        }
      }).on('focusout.zf.tooltip', function (e) {
        isFocus = false;
        _this.isClick = false;

        _this.hide();
      }).on('resizeme.zf.trigger', function () {
        if (_this.isActive) {
          _this._setPosition();
        }
      });
    }
    /**
     * adds a toggle method, in addition to the static show() & hide() functions
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle() {
      if (this.isActive) {
        this.hide();
      } else {
        this.show();
      }
    }
    /**
     * Destroys an instance of tooltip, removes template element from the view.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass(this.options.triggerClass).removeClass('top right left bottom').removeAttr('aria-describedby data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');
      this.template.remove();
    }
  }]);

  return Tooltip;
}(Positionable);

Tooltip.defaults = {
  /**
   * Time, in ms, before a tooltip should open on hover.
   * @option
   * @type {number}
   * @default 200
   */
  hoverDelay: 200,

  /**
   * Time, in ms, a tooltip should take to fade into view.
   * @option
   * @type {number}
   * @default 150
   */
  fadeInDuration: 150,

  /**
   * Time, in ms, a tooltip should take to fade out of view.
   * @option
   * @type {number}
   * @default 150
   */
  fadeOutDuration: 150,

  /**
   * Disables hover events from opening the tooltip if set to true
   * @option
   * @type {boolean}
   * @default false
   */
  disableHover: false,

  /**
   * Disable the tooltip for touch devices.
   * This can be useful to make elements with a tooltip on it trigger their
   * action on the first tap instead of displaying the tooltip.
   * @option
   * @type {booelan}
   * @default false
   */
  disableForTouch: false,

  /**
   * Optional addtional classes to apply to the tooltip template on init.
   * @option
   * @type {string}
   * @default ''
   */
  templateClasses: '',

  /**
   * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
   * @option
   * @type {string}
   * @default 'tooltip'
   */
  tooltipClass: 'tooltip',

  /**
   * Class applied to the tooltip anchor element.
   * @option
   * @type {string}
   * @default 'has-tip'
   */
  triggerClass: 'has-tip',

  /**
   * Minimum breakpoint size at which to open the tooltip.
   * @option
   * @type {string}
   * @default 'small'
   */
  showOn: 'small',

  /**
   * Custom template to be used to generate markup for tooltip.
   * @option
   * @type {string}
   * @default ''
   */
  template: '',

  /**
   * Text displayed in the tooltip template on open.
   * @option
   * @type {string}
   * @default ''
   */
  tipText: '',
  touchCloseText: 'Tap to close.',

  /**
   * Allows the tooltip to remain open if triggered with a click or touch event.
   * @option
   * @type {boolean}
   * @default true
   */
  clickOpen: true,

  /**
   * Position of tooltip. Can be left, right, bottom, top, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  position: 'auto',

  /**
   * Alignment of tooltip relative to anchor. Can be left, right, bottom, top, center, or auto.
   * @option
   * @type {string}
   * @default 'auto'
   */
  alignment: 'auto',

  /**
   * Allow overlap of container/window. If false, tooltip will first try to
   * position as defined by data-position and data-alignment, but reposition if
   * it would cause an overflow.  @option
   * @type {boolean}
   * @default false
   */
  allowOverlap: false,

  /**
   * Allow overlap of only the bottom of the container. This is the most common
   * behavior for dropdowns, allowing the dropdown to extend the bottom of the
   * screen but not otherwise influence or break out of the container.
   * Less common for tooltips.
   * @option
   * @type {boolean}
   * @default false
   */
  allowBottomOverlap: false,

  /**
   * Distance, in pixels, the template should push away from the anchor on the Y axis.
   * @option
   * @type {number}
   * @default 0
   */
  vOffset: 0,

  /**
   * Distance, in pixels, the template should push away from the anchor on the X axis
   * @option
   * @type {number}
   * @default 0
   */
  hOffset: 0,

  /**
   * Distance, in pixels, the template spacing auto-adjust for a vertical tooltip
   * @option
   * @type {number}
   * @default 14
   */
  tooltipHeight: 14,

  /**
   * Distance, in pixels, the template spacing auto-adjust for a horizontal tooltip
   * @option
   * @type {number}
   * @default 12
   */
  tooltipWidth: 12,

  /**
  * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,
  * allowing HTML may open yourself up to XSS attacks.
  * @option
  * @type {boolean}
  * @default false
  */
  allowHtml: false
};

var MenuPlugins$1 = {
  tabs: {
    cssClass: 'tabs',
    plugin: Tabs,
    open: function open(plugin, target) {
      return plugin.selectTab(target);
    },
    close: null
    /* not supported */

    , toggle: null
    /* not supported */

  },
  accordion: {
    cssClass: 'accordion',
    plugin: Accordion,
    open: function open(plugin, target) {
      return plugin.down((0, _jquery2.default)(target));
    },
    close: function close(plugin, target) {
      return plugin.up((0, _jquery2.default)(target));
    },
    toggle: function toggle(plugin, target) {
      return plugin.toggle((0, _jquery2.default)(target));
    }
  }
};
/**
 * ResponsiveAccordionTabs module.
 * @module foundation.responsiveAccordionTabs
 * @requires foundation.util.motion
 * @requires foundation.accordion
 * @requires foundation.tabs
 */

var ResponsiveAccordionTabs =
/*#__PURE__*/
function (_Plugin) {
  _inherits(ResponsiveAccordionTabs, _Plugin);

  function ResponsiveAccordionTabs(element, options) {
    var _this2;

    _classCallCheck(this, ResponsiveAccordionTabs);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ResponsiveAccordionTabs).call(this, element, options));
    return _possibleConstructorReturn(_this2, _this2.options.reflow && _this2.storezfData || _assertThisInitialized(_this2));
  }
  /**
   * Creates a new instance of a responsive accordion tabs.
   * @class
   * @name ResponsiveAccordionTabs
   * @fires ResponsiveAccordionTabs#init
   * @param {jQuery} element - jQuery object to make into Responsive Accordion Tabs.
   * @param {Object} options - Overrides to the default plugin settings.
   */

  _createClass(ResponsiveAccordionTabs, [{
    key: "_setup",
    value: function _setup(element, options) {
      this.$element = (0, _jquery2.default)(element);
      this.$element.data('zfPluginBase', this);
      this.options = _jquery2.default.extend({}, ResponsiveAccordionTabs.defaults, this.$element.data(), options);
      this.rules = this.$element.data('responsive-accordion-tabs');
      this.currentMq = null;
      this.currentRule = null;
      this.currentPlugin = null;
      this.className = 'ResponsiveAccordionTabs'; // ie9 back compat

      if (!this.$element.attr('id')) {
        this.$element.attr('id', GetYoDigits(6, 'responsiveaccordiontabs'));
      }

      this._init();

      this._events();
    }
    /**
     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.
     * @function
     * @private
     */

  }, {
    key: "_init",
    value: function _init() {
      MediaQuery._init(); // The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules


      if (typeof this.rules === 'string') {
        var rulesTree = {}; // Parse rules from "classes" pulled from data attribute

        var rules = this.rules.split(' '); // Iterate through every rule found

        for (var i = 0; i < rules.length; i++) {
          var rule = rules[i].split('-');
          var ruleSize = rule.length > 1 ? rule[0] : 'small';
          var rulePlugin = rule.length > 1 ? rule[1] : rule[0];

          if (MenuPlugins$1[rulePlugin] !== null) {
            rulesTree[ruleSize] = MenuPlugins$1[rulePlugin];
          }
        }

        this.rules = rulesTree;
      }

      this._getAllOptions();

      if (!_jquery2.default.isEmptyObject(this.rules)) {
        this._checkMediaQueries();
      }
    }
  }, {
    key: "_getAllOptions",
    value: function _getAllOptions() {
      //get all defaults and options
      var _this = this;

      _this.allOptions = {};

      for (var key in MenuPlugins$1) {
        if (MenuPlugins$1.hasOwnProperty(key)) {
          var obj = MenuPlugins$1[key];

          try {
            var dummyPlugin = (0, _jquery2.default)('<ul></ul>');
            var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);

            for (var keyKey in tmpPlugin.options) {
              if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {
                var objObj = tmpPlugin.options[keyKey];
                _this.allOptions[keyKey] = objObj;
              }
            }

            tmpPlugin.destroy();
          } catch (e) {}
        }
      }
    }
    /**
     * Initializes events for the Menu.
     * @function
     * @private
     */

  }, {
    key: "_events",
    value: function _events() {
      this._changedZfMediaQueryHandler = this._checkMediaQueries.bind(this);
      (0, _jquery2.default)(window).on('changed.zf.mediaquery', this._changedZfMediaQueryHandler);
    }
    /**
     * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
     * @function
     * @private
     */

  }, {
    key: "_checkMediaQueries",
    value: function _checkMediaQueries() {
      var matchedMq,
          _this = this; // Iterate through each rule and find the last matching rule


      _jquery2.default.each(this.rules, function (key) {
        if (MediaQuery.atLeast(key)) {
          matchedMq = key;
        }
      }); // No match? No dice

      if (!matchedMq) return; // Plugin already initialized? We good

      if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return; // Remove existing plugin-specific CSS classes

      _jquery2.default.each(MenuPlugins$1, function (key, value) {
        _this.$element.removeClass(value.cssClass);
      }); // Add the CSS class for the new plugin

      this.$element.addClass(this.rules[matchedMq].cssClass); // Create an instance of the new plugin

      if (this.currentPlugin) {
        //don't know why but on nested elements data zfPlugin get's lost
        if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);
        this.currentPlugin.destroy();
      }

      this._handleMarkup(this.rules[matchedMq].cssClass);

      this.currentRule = this.rules[matchedMq];
      this.currentPlugin = new this.currentRule.plugin(this.$element, this.options);
      this.storezfData = this.currentPlugin.$element.data('zfPlugin');
    }
  }, {
    key: "_handleMarkup",
    value: function _handleMarkup(toSet) {
      var _this = this,
          fromString = 'accordion';

      var $panels = (0, _jquery2.default)('[data-tabs-content=' + this.$element.attr('id') + ']');
      if ($panels.length) fromString = 'tabs';

      if (fromString === toSet) {
        return;
      }

      var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';
      var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';
      this.$element.removeAttr('role');
      var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');
      var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');

      if (fromString === 'tabs') {
        $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');
        $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');
      } else {
        $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');
      }

      $panels.css({
        display: '',
        visibility: ''
      });
      $liHeads.css({
        display: '',
        visibility: ''
      });

      if (toSet === 'accordion') {
        $panels.each(function (key, value) {
          (0, _jquery2.default)(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({
            height: ''
          });
          (0, _jquery2.default)('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id="tabs-placeholder-' + _this.$element.attr('id') + '"></div>').detach();
          $liHeads.addClass('accordion-item').attr('data-accordion-item', '');
          $liHeadsA.addClass('accordion-title');
        });
      } else if (toSet === 'tabs') {
        var $tabsContent = (0, _jquery2.default)('[data-tabs-content=' + _this.$element.attr('id') + ']');
        var $placeholder = (0, _jquery2.default)('#tabs-placeholder-' + _this.$element.attr('id'));

        if ($placeholder.length) {
          $tabsContent = (0, _jquery2.default)('<div class="tabs-content"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));
          $placeholder.remove();
        } else {
          $tabsContent = (0, _jquery2.default)('<div class="tabs-content"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));
        }

        $panels.each(function (key, value) {
          var tempValue = (0, _jquery2.default)(value).appendTo($tabsContent).addClass(tabsPanel);
          var hash = $liHeadsA.get(key).hash.slice(1);
          var id = (0, _jquery2.default)(value).attr('id') || GetYoDigits(6, 'accordion');

          if (hash !== id) {
            if (hash !== '') {
              (0, _jquery2.default)(value).attr('id', hash);
            } else {
              hash = id;
              (0, _jquery2.default)(value).attr('id', hash);
              (0, _jquery2.default)($liHeadsA.get(key)).attr('href', (0, _jquery2.default)($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);
            }
          }

          var isActive = (0, _jquery2.default)($liHeads.get(key)).hasClass('is-active');

          if (isActive) {
            tempValue.addClass('is-active');
          }
        });
        $liHeads.addClass(tabsTitle);
      }
    }
    /**
     * Opens the plugin pane defined by `target`.
     * @param {jQuery | String} target - jQuery object or string of the id of the pane to open.
     * @see Accordion.down
     * @see Tabs.selectTab
     * @function
     */

  }, {
    key: "open",
    value: function open(_target) {
      if (this.currentRule && typeof this.currentRule.open === 'function') {
        var _this$currentRule;

        return (_this$currentRule = this.currentRule).open.apply(_this$currentRule, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
      }
    }
    /**
     * Closes the plugin pane defined by `target`. Not availaible for Tabs.
     * @param {jQuery | String} target - jQuery object or string of the id of the pane to close.
     * @see Accordion.up
     * @function
     */

  }, {
    key: "close",
    value: function close(_target) {
      if (this.currentRule && typeof this.currentRule.close === 'function') {
        var _this$currentRule2;

        return (_this$currentRule2 = this.currentRule).close.apply(_this$currentRule2, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
      }
    }
    /**
     * Toggles the plugin pane defined by `target`. Not availaible for Tabs.
     * @param {jQuery | String} target - jQuery object or string of the id of the pane to toggle.
     * @see Accordion.toggle
     * @function
     */

  }, {
    key: "toggle",
    value: function toggle(_target) {
      if (this.currentRule && typeof this.currentRule.toggle === 'function') {
        var _this$currentRule3;

        return (_this$currentRule3 = this.currentRule).toggle.apply(_this$currentRule3, [this.currentPlugin].concat(Array.prototype.slice.call(arguments)));
      }
    }
    /**
     * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
     * @function
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      if (this.currentPlugin) this.currentPlugin.destroy();
      (0, _jquery2.default)(window).off('changed.zf.mediaquery', this._changedZfMediaQueryHandler);
    }
  }]);

  return ResponsiveAccordionTabs;
}(Plugin);

ResponsiveAccordionTabs.defaults = {};

Foundation.addToJquery(_jquery2.default); // Add Foundation Utils to Foundation global namespace for backwards
// compatibility.

Foundation.rtl = rtl;
Foundation.GetYoDigits = GetYoDigits;
Foundation.transitionend = transitionend;
Foundation.RegExpEscape = RegExpEscape;
Foundation.onLoad = onLoad;
Foundation.Box = Box;
Foundation.onImagesLoaded = onImagesLoaded;
Foundation.Keyboard = Keyboard;
Foundation.MediaQuery = MediaQuery;
Foundation.Motion = Motion;
Foundation.Move = Move;
Foundation.Nest = Nest;
Foundation.Timer = Timer; // Touch and Triggers previously were almost purely sede effect driven,
// so no need to add it to Foundation, just init them.

Touch.init(_jquery2.default);
Triggers.init(_jquery2.default, Foundation);

MediaQuery._init();

Foundation.plugin(Abide, 'Abide');
Foundation.plugin(Accordion, 'Accordion');
Foundation.plugin(AccordionMenu, 'AccordionMenu');
Foundation.plugin(Drilldown, 'Drilldown');
Foundation.plugin(Dropdown, 'Dropdown');
Foundation.plugin(DropdownMenu, 'DropdownMenu');
Foundation.plugin(Equalizer, 'Equalizer');
Foundation.plugin(Interchange, 'Interchange');
Foundation.plugin(Magellan, 'Magellan');
Foundation.plugin(OffCanvas, 'OffCanvas');
Foundation.plugin(Orbit, 'Orbit');
Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');
Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');
Foundation.plugin(Reveal, 'Reveal');
Foundation.plugin(Slider, 'Slider');
Foundation.plugin(SmoothScroll, 'SmoothScroll');
Foundation.plugin(Sticky, 'Sticky');
Foundation.plugin(Tabs, 'Tabs');
Foundation.plugin(Toggler, 'Toggler');
Foundation.plugin(Tooltip, 'Tooltip');
Foundation.plugin(ResponsiveAccordionTabs, 'ResponsiveAccordionTabs');

exports.default = Foundation;
exports.Abide = Abide;
exports.Accordion = Accordion;
exports.AccordionMenu = AccordionMenu;
exports.Box = Box;
exports.Core = Foundation;
exports.CoreUtils = foundation_core_utils;
exports.Drilldown = Drilldown;
exports.Dropdown = Dropdown;
exports.DropdownMenu = DropdownMenu;
exports.Equalizer = Equalizer;
exports.Foundation = Foundation;
exports.Interchange = Interchange;
exports.Keyboard = Keyboard;
exports.Magellan = Magellan;
exports.MediaQuery = MediaQuery;
exports.Motion = Motion;
exports.Move = Move;
exports.Nest = Nest;
exports.OffCanvas = OffCanvas;
exports.Orbit = Orbit;
exports.ResponsiveAccordionTabs = ResponsiveAccordionTabs;
exports.ResponsiveMenu = ResponsiveMenu;
exports.ResponsiveToggle = ResponsiveToggle;
exports.Reveal = Reveal;
exports.Slider = Slider;
exports.SmoothScroll = SmoothScroll;
exports.Sticky = Sticky;
exports.Tabs = Tabs;
exports.Timer = Timer;
exports.Toggler = Toggler;
exports.Tooltip = Tooltip;
exports.Touch = Touch;
exports.Triggers = Triggers;
exports.onImagesLoaded = onImagesLoaded;
//# sourceMappingURL=foundation.esm.js.map

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Slick Slider for Modules 
function moduleSlider(moduleName) {
	// alert(moduleNAme);
	var $slider = '.' + moduleName;

	$($slider).slick({
		slidesToShow: 1,
		slidesToScroll: 1,
		autoplay: false,
		autoplaySpeed: 2000,
		mobileFirst: true,
		arrows: false,
		dots: true,
		adaptiveHeight: true,
		responsive: [{
			breakpoint: 640,
			settings: "unslick"
		}]
	});
	// $($slider).slick({
	// 	arrows: false,
	// 	autoplay: false,
	// 	fade: true,
	// 	// lazyLoad: 'progressive',
	// 	speed: 100,
	// 	// adaptiveHeight: false,
	// 	responsive: [
	// 	    {
	// 	      breakpoint: 768,
	// 	      settings: {
	// 	          slidesToScroll: 1,
	// 	          autoplay: true,
	// 	          autoplaySpeed: 5000,
	// 	          fade: false,
	// 	          dots: true,
	// 	          speed: 1000,
	// 	          adaptiveHeight: true,
	// 	          easing: 'easeInOutSine',
	// 	      }
	// 	    }
	// 	  ]
	// });
}
// END SLIDER

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
Reference: http://jsfiddle.net/BB3JK/47/
*/

$('select').each(function () {
    var $this = $(this),
        numberOfOptions = $(this).children('option').length,
        name = $this.attr('name'),
        data_default = $this.attr('data-default');
    var select_class = '<div class="select ' + name + '"></div>';
    $this.addClass('select-hidden');
    $this.wrap(select_class);
    $this.after('<div class="select-styled" data-name="' + name + '" data-default="' + data_default + '" data-id="null"></div>');

    var $styledSelect = $this.next('div.select-styled');
    $styledSelect.text($this.children('option').eq(0).text());

    var $list = $('<ul />', {
        'class': 'select-options ng-binding ng-scope'
    }).insertAfter($styledSelect);

    for (var i = 0; i < numberOfOptions; i++) {
        var $class = void 0,
            $thisoption = $this.children('option').eq(i);
        if ($thisoption[0].hidden == true || $thisoption[0].disabled == true) {
            $class = 'ng-binding hide';
        } else {
            $class = 'ng-binding';
        }
        $('<li />', {
            // if ($this.children('option').eq(i).hidden == true),
            'class': $class,
            text: $thisoption.text(),
            rel: $thisoption.val()
        }).appendTo($list);
    }

    var $listItems = $list.children('li');

    $styledSelect.click(function (e) {
        e.stopPropagation();
        $('div.select-styled.active').not(this).each(function () {
            $(this).removeClass('active').next('ul.select-options').hide();
        });
        $(this).toggleClass('active').next('ul.select-options').toggle();
    });

    $listItems.click(function (e) {
        var rel = $(this).attr('rel');
        e.stopPropagation();
        $styledSelect.text($(this).text()).removeClass('active');
        $styledSelect.attr('data-id', rel);
        $this.val($(this).attr('rel'));

        $list.hide();

        // var selectName = $styledSelect.attr('data-name'),
        //     selectVal = $this.val();
        // console.log(selectName, selectVal);
        // $('#filter1 select[name="'+selectName+'"]').val(selectVal).trigger('change');
        $this.trigger('change');
    });

    $(document).click(function () {
        $styledSelect.removeClass('active');
        $list.hide();
        // console.log($this.val());
    });

    console.log('menu ready');
});

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2Q0NzQ4ZGUwYjgzZmExZDllNjQiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwialF1ZXJ5XCIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9qcy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9qcy9saWIvbW9iaWxlX21vZHVsZV9zbGlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Fzc2V0cy9qcy9saWIvZHJvcGRvd25fbWVudS5qcyJdLCJuYW1lcyI6WyJ3aW5kb3ciLCIkIiwiZG9jdW1lbnQiLCJmb3VuZGF0aW9uIiwicmVhZHkiLCJjb25zb2xlIiwibG9nIiwiY2xpY2siLCJzbGljayIsInNsaWRlc1RvU2hvdyIsInNsaWRlc1RvU2Nyb2xsIiwiYXV0b3BsYXkiLCJhdXRvcGxheVNwZWVkIiwibW9iaWxlRmlyc3QiLCJhcnJvd3MiLCJkb3RzIiwiYWRhcHRpdmVIZWlnaHQiLCJyZXNwb25zaXZlIiwiYnJlYWtwb2ludCIsInNldHRpbmdzIiwicm93cyIsInNsaWRlc1BlclJvdyIsImZhZGUiLCJoaWRlIiwiY2xpY2tDYXJkIiwibWV0YWNsaWNrIiwic2V0VGltZW91dCIsInVybCIsImRhdGEiLCJibGFuayIsIm9wZW4iLCJsb2NhdGlvbiIsImhyZWYiLCJlYWNoIiwiX3dpbiIsIl90aHMiLCJfcG9zIiwib2Zmc2V0IiwidG9wIiwiX3Njcm9sbCIsInNjcm9sbFRvcCIsIl9oZWlnaHQiLCJoZWlnaHQiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwic2Nyb2xsIiwiZm9vdGVyTWVudVRvZ2dsZSIsInRvZ2dsZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29udGFpbmVycyIsImZvckVhY2giLCJ0b2dnbGUiLCJpbmQiLCJhZGRFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwiX3R5cGVvZiIsIm9iaiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJ2YWx1ZSIsIl9zZXRQcm90b3R5cGVPZiIsIl9nZXRQcm90b3R5cGVPZiIsIm8iLCJzZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfc3VwZXJQcm9wQmFzZSIsIm9iamVjdCIsInByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJfZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZ2V0IiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfc2xpY2VkVG9BcnJheSIsImFyciIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl9ub25JdGVyYWJsZVJlc3QiLCJBcnJheSIsImlzQXJyYXkiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX2kiLCJfcyIsIm5leHQiLCJkb25lIiwicHVzaCIsImVyciIsInJ0bCIsImF0dHIiLCJHZXRZb0RpZ2l0cyIsImFyZ3VtZW50cyIsIm5hbWVzcGFjZSIsInN0ciIsImNoYXJzIiwiY2hhcnNMZW5ndGgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJjb25jYXQiLCJSZWdFeHBFc2NhcGUiLCJyZXBsYWNlIiwidHJhbnNpdGlvbmVuZCIsIiRlbGVtIiwidHJhbnNpdGlvbnMiLCJlbGVtIiwiY3JlYXRlRWxlbWVudCIsImVuZCIsInRyYW5zaXRpb24iLCJzdHlsZSIsInRyaWdnZXJIYW5kbGVyIiwib25Mb2FkIiwiaGFuZGxlciIsImRpZExvYWQiLCJyZWFkeVN0YXRlIiwiZXZlbnRUeXBlIiwiY2IiLCJvbmUiLCJpZ25vcmVNb3VzZWRpc2FwcGVhciIsIl9yZWYiLCJfcmVmJGlnbm9yZUxlYXZlV2luZG8iLCJpZ25vcmVMZWF2ZVdpbmRvdyIsIl9yZWYkaWdub3JlUmVhcHBlYXIiLCJpZ25vcmVSZWFwcGVhciIsImxlYXZlRXZlbnRIYW5kbGVyIiwiZUxlYXZlIiwiX2xlbiIsInJlc3QiLCJfa2V5IiwiY2FsbGJhY2siLCJiaW5kIiwiYXBwbHkiLCJyZWxhdGVkVGFyZ2V0IiwibGVhdmVFdmVudERlYm91bmNlciIsImhhc0ZvY3VzIiwicmVlbnRlckV2ZW50SGFuZGxlciIsImVSZWVudGVyIiwiY3VycmVudFRhcmdldCIsImhhcyIsImZvdW5kYXRpb25fY29yZV91dGlscyIsImZyZWV6ZSIsIm1hdGNoTWVkaWEiLCJzdHlsZU1lZGlhIiwibWVkaWEiLCJzY3JpcHQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImluZm8iLCJ0eXBlIiwiaWQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnROb2RlIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1cnJlbnRTdHlsZSIsIm1hdGNoTWVkaXVtIiwidGV4dCIsInN0eWxlU2hlZXQiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJ3aWR0aCIsIm1hdGNoZXMiLCJNZWRpYVF1ZXJ5IiwicXVlcmllcyIsImN1cnJlbnQiLCJfaW5pdCIsImlzSW5pdGlhbGl6ZWQiLCIkbWV0YSIsImFwcGVuZFRvIiwiZXh0cmFjdGVkU3R5bGVzIiwiY3NzIiwibmFtZWRRdWVyaWVzIiwicGFyc2VTdHlsZVRvT2JqZWN0IiwibmFtZSIsIl9nZXRDdXJyZW50U2l6ZSIsIl93YXRjaGVyIiwiX3JlSW5pdCIsImF0TGVhc3QiLCJzaXplIiwicXVlcnkiLCJvbmx5IiwidXBUbyIsIm5leHRTaXplIiwiaXMiLCJwYXJ0cyIsInRyaW0iLCJzcGxpdCIsImZpbHRlciIsIl9wYXJ0cyIsImJwU2l6ZSIsIl9wYXJ0cyQiLCJicE1vZGlmaWVyIiwiRXJyb3IiLCJfdGhpcyIsInF1ZXJ5SW5kZXgiLCJmaW5kSW5kZXgiLCJxIiwiX2dldFF1ZXJ5TmFtZSIsIm5leHRRdWVyeSIsIm1hdGNoZWQiLCJfdGhpczIiLCJvZmYiLCJvbiIsIm5ld1NpemUiLCJjdXJyZW50U2l6ZSIsInRyaWdnZXIiLCJzdHlsZU9iamVjdCIsInNsaWNlIiwicmVkdWNlIiwicmV0IiwicGFyYW0iLCJ2YWwiLCJkZWNvZGVVUklDb21wb25lbnQiLCJGT1VOREFUSU9OX1ZFUlNJT04iLCJGb3VuZGF0aW9uIiwidmVyc2lvbiIsIl9wbHVnaW5zIiwiX3V1aWRzIiwicGx1Z2luIiwiX3BsdWdpbiIsImNsYXNzTmFtZSIsImZ1bmN0aW9uTmFtZSIsImF0dHJOYW1lIiwiaHlwaGVuYXRlIiwicmVnaXN0ZXJQbHVnaW4iLCJwbHVnaW5OYW1lIiwidG9Mb3dlckNhc2UiLCJ1dWlkIiwiJGVsZW1lbnQiLCJ1bnJlZ2lzdGVyUGx1Z2luIiwic3BsaWNlIiwiaW5kZXhPZiIsInJlbW92ZUF0dHIiLCJyZW1vdmVEYXRhIiwicHJvcCIsInJlSW5pdCIsInBsdWdpbnMiLCJpc0pRIiwiZm5zIiwicGxncyIsInN0cmluZyIsInVuZGVmaW5lZCQxIiwia2V5cyIsImVycm9yIiwicmVmbG93IiwiZmluZCIsImFkZEJhY2siLCIkZWwiLCJvcHRzIiwib3B0aW9uIiwiX2luZGV4Iiwib3B0IiwibWFwIiwiZWwiLCJwYXJzZVZhbHVlIiwiZXIiLCJnZXRGbk5hbWUiLCJhZGRUb0pxdWVyeSIsIm1ldGhvZCIsIiRub0pTIiwiYXJncyIsInBsdWdDbGFzcyIsImZuIiwidXRpbCIsInRocm90dGxlIiwiZnVuYyIsImRlbGF5IiwidGltZXIiLCJjb250ZXh0IiwiRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJ2ZW5kb3JzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidnAiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJsYXN0VGltZSIsIm5leHRUaW1lIiwibWF4IiwiY2xlYXJUaW1lb3V0IiwicGVyZm9ybWFuY2UiLCJzdGFydCIsIkZ1bmN0aW9uIiwib1RoaXMiLCJhQXJncyIsImZUb0JpbmQiLCJmTk9QIiwiZkJvdW5kIiwiZnVuY05hbWVSZWdleCIsInJlc3VsdHMiLCJleGVjIiwidG9TdHJpbmciLCJpc05hTiIsInBhcnNlRmxvYXQiLCJCb3giLCJJbU5vdFRvdWNoaW5nWW91IiwiT3ZlcmxhcEFyZWEiLCJHZXREaW1lbnNpb25zIiwiR2V0RXhwbGljaXRPZmZzZXRzIiwiZWxlbWVudCIsInBhcmVudCIsImxyT25seSIsInRiT25seSIsImlnbm9yZUJvdHRvbSIsImVsZURpbXMiLCJ0b3BPdmVyIiwiYm90dG9tT3ZlciIsImxlZnRPdmVyIiwicmlnaHRPdmVyIiwicGFyRGltcyIsImxlZnQiLCJ3aW5kb3dEaW1zIiwibWluIiwic3FydCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYXJSZWN0Iiwid2luUmVjdCIsImJvZHkiLCJ3aW5ZIiwicGFnZVlPZmZzZXQiLCJ3aW5YIiwicGFnZVhPZmZzZXQiLCJwYXJlbnREaW1zIiwiYW5jaG9yIiwicG9zaXRpb24iLCJhbGlnbm1lbnQiLCJ2T2Zmc2V0IiwiaE9mZnNldCIsImlzT3ZlcmZsb3ciLCIkZWxlRGltcyIsIiRhbmNob3JEaW1zIiwidG9wVmFsIiwibGVmdFZhbCIsIm9uSW1hZ2VzTG9hZGVkIiwiaW1hZ2VzIiwidW5sb2FkZWQiLCJjb21wbGV0ZSIsIm5hdHVyYWxXaWR0aCIsInNpbmdsZUltYWdlTG9hZGVkIiwiaW1hZ2UiLCJJbWFnZSIsImV2ZW50cyIsIm1lIiwiZXZlbnQiLCJzcmMiLCJrZXlDb2RlcyIsImNvbW1hbmRzIiwiZmluZEZvY3VzYWJsZSIsInBhcnNlS2V5Iiwid2hpY2giLCJrZXlDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwidG9VcHBlckNhc2UiLCJzaGlmdEtleSIsImN0cmxLZXkiLCJhbHRLZXkiLCJLZXlib2FyZCIsImdldEtleUNvZGVzIiwiaGFuZGxlS2V5IiwiY29tcG9uZW50IiwiZnVuY3Rpb25zIiwiY29tbWFuZExpc3QiLCJjbWRzIiwiY29tbWFuZCIsIndhcm4iLCJ6ZklzS2V5SGFuZGxlZCIsImx0ciIsImV4dGVuZCIsInJldHVyblZhbHVlIiwiaGFuZGxlZCIsInVuaGFuZGxlZCIsInJlZ2lzdGVyIiwiY29tcG9uZW50TmFtZSIsInRyYXBGb2N1cyIsIiRmb2N1c2FibGUiLCIkZmlyc3RGb2N1c2FibGUiLCJlcSIsIiRsYXN0Rm9jdXNhYmxlIiwicHJldmVudERlZmF1bHQiLCJmb2N1cyIsInJlbGVhc2VGb2N1cyIsImtjcyIsImsiLCJrYyIsImluaXRDbGFzc2VzIiwiYWN0aXZlQ2xhc3NlcyIsIk1vdGlvbiIsImFuaW1hdGVJbiIsImFuaW1hdGlvbiIsImFuaW1hdGUiLCJhbmltYXRlT3V0IiwiTW92ZSIsImR1cmF0aW9uIiwiYW5pbSIsInByb2ciLCJtb3ZlIiwidHMiLCJpc0luIiwiaW5pdENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJyZXNldCIsInNob3ciLCJvZmZzZXRXaWR0aCIsImZpbmlzaCIsInRyYW5zaXRpb25EdXJhdGlvbiIsIk5lc3QiLCJGZWF0aGVyIiwibWVudSIsIml0ZW1zIiwic3ViTWVudUNsYXNzIiwic3ViSXRlbUNsYXNzIiwiaGFzU3ViQ2xhc3MiLCJhcHBseUFyaWEiLCIkaXRlbSIsIiRzdWIiLCJjaGlsZHJlbiIsIkJ1cm4iLCJUaW1lciIsIm9wdGlvbnMiLCJuYW1lU3BhY2UiLCJyZW1haW4iLCJpc1BhdXNlZCIsInJlc3RhcnQiLCJpbmZpbml0ZSIsInBhdXNlIiwiVG91Y2giLCJzdGFydFBvc1giLCJzdGFydFBvc1kiLCJzdGFydFRpbWUiLCJlbGFwc2VkVGltZSIsInN0YXJ0RXZlbnQiLCJpc01vdmluZyIsImRpZE1vdmVkIiwib25Ub3VjaEVuZCIsImUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25Ub3VjaE1vdmUiLCJ0YXBFdmVudCIsIkV2ZW50Iiwic3BvdFN3aXBlIiwieCIsInRvdWNoZXMiLCJwYWdlWCIsInkiLCJwYWdlWSIsImR4IiwiZGlyIiwiYWJzIiwibW92ZVRocmVzaG9sZCIsInRpbWVUaHJlc2hvbGQiLCJhc3NpZ24iLCJvblRvdWNoU3RhcnQiLCJpbml0IiwiU3BvdFN3aXBlIiwiZW5hYmxlZCIsImRvY3VtZW50RWxlbWVudCIsInNwZWNpYWwiLCJzd2lwZSIsInNldHVwIiwidGFwIiwibm9vcCIsInNldHVwU3BvdFN3aXBlIiwic2V0dXBUb3VjaEhhbmRsZXIiLCJhZGRUb3VjaCIsImhhbmRsZVRvdWNoIiwiY2hhbmdlZFRvdWNoZXMiLCJmaXJzdCIsImV2ZW50VHlwZXMiLCJ0b3VjaHN0YXJ0IiwidG91Y2htb3ZlIiwidG91Y2hlbmQiLCJzaW11bGF0ZWRFdmVudCIsIk1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJNdXRhdGlvbk9ic2VydmVyIiwicHJlZml4ZXMiLCJ0cmlnZ2VycyIsIlRyaWdnZXJzIiwiTGlzdGVuZXJzIiwiQmFzaWMiLCJHbG9iYWwiLCJJbml0aWFsaXplcnMiLCJvcGVuTGlzdGVuZXIiLCJjbG9zZUxpc3RlbmVyIiwidG9nZ2xlTGlzdGVuZXIiLCJjbG9zZWFibGVMaXN0ZW5lciIsInN0b3BQcm9wYWdhdGlvbiIsImZhZGVPdXQiLCJ0b2dnbGVGb2N1c0xpc3RlbmVyIiwiYWRkT3Blbkxpc3RlbmVyIiwiYWRkQ2xvc2VMaXN0ZW5lciIsImFkZFRvZ2dsZUxpc3RlbmVyIiwiYWRkQ2xvc2VhYmxlTGlzdGVuZXIiLCJhZGRUb2dnbGVGb2N1c0xpc3RlbmVyIiwicmVzaXplTGlzdGVuZXIiLCIkbm9kZXMiLCJzY3JvbGxMaXN0ZW5lciIsImNsb3NlTWVMaXN0ZW5lciIsInBsdWdpbklkIiwibm90IiwiYWRkQ2xvc2VtZUxpc3RlbmVyIiwieWV0aUJveGVzIiwicGx1Z05hbWVzIiwibGlzdGVuZXJzIiwiam9pbiIsImRlYm91bmNlR2xvYmFsTGlzdGVuZXIiLCJkZWJvdW5jZSIsImxpc3RlbmVyIiwiYWRkUmVzaXplTGlzdGVuZXIiLCJhZGRTY3JvbGxMaXN0ZW5lciIsImFkZE11dGF0aW9uRXZlbnRzTGlzdGVuZXIiLCJsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uIiwibXV0YXRpb25SZWNvcmRzTGlzdCIsIiR0YXJnZXQiLCJhdHRyaWJ1dGVOYW1lIiwiY2xvc2VzdCIsImVsZW1lbnRPYnNlcnZlciIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsInN1YnRyZWUiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJhZGRTaW1wbGVMaXN0ZW5lcnMiLCIkZG9jdW1lbnQiLCJhZGRHbG9iYWxMaXN0ZW5lcnMiLCJ0cmlnZ2Vyc0luaXRpYWxpemVkIiwiSUhlYXJZb3UiLCJQbHVnaW4iLCJfc2V0dXAiLCJnZXRQbHVnaW5OYW1lIiwiZGVzdHJveSIsIl9kZXN0cm95IiwiaHlwaGVuYXRlJDEiLCJBYmlkZSIsIl9QbHVnaW4iLCJkZWZhdWx0cyIsImlzRW5hYmxlZCIsImZvcm1ub3ZhbGlkYXRlIiwiJGlucHV0cyIsIm1lcmdlIiwiJHN1Ym1pdHMiLCIkZ2xvYmFsRXJyb3JzIiwiYTExeUF0dHJpYnV0ZXMiLCJpbnB1dCIsImFkZEExMXlBdHRyaWJ1dGVzIiwiYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlcyIsIl9ldmVudHMiLCJfdGhpczMiLCJyZXNldEZvcm0iLCJ2YWxpZGF0ZUZvcm0iLCJnZXRBdHRyaWJ1dGUiLCJzdWJtaXQiLCJ2YWxpZGF0ZU9uIiwidmFsaWRhdGVJbnB1dCIsImxpdmVWYWxpZGF0ZSIsInZhbGlkYXRlT25CbHVyIiwiX3JlZmxvdyIsIl92YWxpZGF0aW9uSXNEaXNhYmxlZCIsImVuYWJsZVZhbGlkYXRpb24iLCJkaXNhYmxlVmFsaWRhdGlvbiIsInJlcXVpcmVkQ2hlY2siLCJpc0dvb2QiLCJjaGVja2VkIiwiZmluZEZvcm1FcnJvciIsImZhaWxlZFZhbGlkYXRvcnMiLCJfdGhpczQiLCIkZXJyb3IiLCJzaWJsaW5ncyIsImZvcm1FcnJvclNlbGVjdG9yIiwiYWRkIiwidiIsImZpbmRMYWJlbCIsIiRsYWJlbCIsImZpbmRSYWRpb0xhYmVscyIsIiRlbHMiLCJfdGhpczUiLCJsYWJlbHMiLCJmaW5kQ2hlY2tib3hMYWJlbHMiLCJfdGhpczYiLCJhZGRFcnJvckNsYXNzZXMiLCIkZm9ybUVycm9yIiwibGFiZWxFcnJvckNsYXNzIiwiZm9ybUVycm9yQ2xhc3MiLCJpbnB1dEVycm9yQ2xhc3MiLCIkZXJyb3JzIiwiJGxhYmVscyIsImVycm9ySWQiLCJlbGVtSWQiLCJsYWJlbCIsImExMXlFcnJvckxldmVsIiwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMiLCJncm91cE5hbWUiLCIkZm9ybUVycm9ycyIsInJlbW92ZUNoZWNrYm94RXJyb3JDbGFzc2VzIiwicmVtb3ZlRXJyb3JDbGFzc2VzIiwiX3RoaXM3IiwiY2xlYXJSZXF1aXJlIiwidmFsaWRhdG9yIiwibWFuYWdlRXJyb3JDbGFzc2VzIiwidmFsaWRhdGVSYWRpbyIsInZhbGlkYXRlQ2hlY2tib3giLCJ2YWxpZGF0ZVRleHQiLCJyZXF1aXJlZCIsInZhbGlkYXRvcnMiLCJlcXVhbFRvIiwiZ29vZFRvR28iLCJtZXNzYWdlIiwiZGVwZW5kZW50RWxlbWVudHMiLCJfdGhpczgiLCJhY2MiLCJjaGVja2JveEdyb3VwTmFtZSIsImluaXRpYWxpemVkIiwibm9FcnJvciIsInBhdHRlcm4iLCJpbnB1dFRleHQiLCJ2YWxpZCIsInBhdHRlcm5zIiwiUmVnRXhwIiwiJGdyb3VwIiwiX3RoaXM5IiwibWluUmVxdWlyZWQiLCJwYXJzZUludCIsIm1hdGNoVmFsaWRhdGlvbiIsIl90aGlzMTAiLCJjbGVhciIsIiRmb3JtIiwiYWxwaGEiLCJhbHBoYV9udW1lcmljIiwiaW50ZWdlciIsIm51bWJlciIsImNhcmQiLCJjdnYiLCJlbWFpbCIsImRvbWFpbiIsImRhdGV0aW1lIiwiZGF0ZSIsInRpbWUiLCJkYXRlSVNPIiwibW9udGhfZGF5X3llYXIiLCJkYXlfbW9udGhfeWVhciIsImNvbG9yIiwid2Vic2l0ZSIsIkFjY29yZGlvbiIsIl9pc0luaXRpYWxpemluZyIsIiR0YWJzIiwiaWR4IiwiJGNvbnRlbnQiLCJsaW5rSWQiLCIkaW5pdEFjdGl2ZSIsIl9pbml0aWFsQW5jaG9yIiwicHJldiIsIl9vcGVuU2luZ2xlVGFiIiwiX2NoZWNrRGVlcExpbmsiLCJoYXNoIiwiJGFuY2hvciIsIiRsaW5rIiwiaXNPd25BbmNob3IiLCJoYXNDbGFzcyIsIl9jbG9zZUFsbFRhYnMiLCJkZWVwTGlua1NtdWRnZSIsImRlZXBMaW5rU211ZGdlT2Zmc2V0IiwiZGVlcExpbmtTbXVkZ2VEZWxheSIsImRlZXBMaW5rIiwiJHRhYkNvbnRlbnQiLCIkYSIsIm11bHRpRXhwYW5kIiwicHJldmlvdXMiLCJ1cCIsImRvd24iLCJ1cGRhdGVIaXN0b3J5IiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsInJlcGxhY2VTdGF0ZSIsIl9vcGVuVGFiIiwiJHRhcmdldEl0ZW0iLCIkb3RoZXJzSXRlbXMiLCJhbGxvd0FsbENsb3NlZCIsIl9jbG9zZVRhYiIsIiRhY3RpdmVDb250ZW50cyIsInRhcmdldENvbnRlbnRJZCIsInNsaWRlRG93biIsInNsaWRlU3BlZWQiLCJzbGlkZVVwIiwiJGFjdGl2ZVRhYnMiLCJzdG9wIiwiQWNjb3JkaW9uTWVudSIsIm11bHRpT3BlbiIsIiRtZW51TGlua3MiLCJzdWJJZCIsImlzQWN0aXZlIiwicGFyZW50TGluayIsImNsb25lIiwicHJlcGVuZFRvIiwid3JhcCIsInN1Ym1lbnVUb2dnbGUiLCJhZnRlciIsInN1Ym1lbnVUb2dnbGVUZXh0IiwiaW5pdFBhbmVzIiwiJHN1Ym1lbnUiLCIkZWxlbWVudHMiLCIkcHJldkVsZW1lbnQiLCIkbmV4dEVsZW1lbnQiLCJwYXJlbnRzIiwiY2xvc2UiLCJjbG9zZUFsbCIsImhpZGVBbGwiLCJzaG93QWxsIiwiJHRhcmdldEJyYW5jaCIsInBhcmVudHNVbnRpbCIsIiRvdGhlcnNBY3RpdmVTdWJtZW51cyIsIiRzdWJtZW51cyIsIiRhbGxtZW51cyIsImRldGFjaCIsInJlbW92ZSIsIkRyaWxsZG93biIsImF1dG9BcHBseUNsYXNzIiwiJHN1Ym1lbnVBbmNob3JzIiwiJG1lbnVJdGVtcyIsIiRjdXJyZW50TWVudSIsIl9wcmVwYXJlTWVudSIsIl9yZWdpc3RlckV2ZW50cyIsIl9rZXlib2FyZEV2ZW50cyIsIiRtZW51IiwiJGJhY2siLCJiYWNrQnV0dG9uUG9zaXRpb24iLCJhcHBlbmQiLCJiYWNrQnV0dG9uIiwicHJlcGVuZCIsIl9iYWNrIiwiYXV0b0hlaWdodCIsIiR3cmFwcGVyIiwid3JhcHBlciIsImFuaW1hdGVIZWlnaHQiLCJfZ2V0TWF4RGltcyIsIl9yZXNpemUiLCJfc2hvdyIsImNsb3NlT25DbGljayIsIiRib2R5IiwiY29udGFpbnMiLCJfaGlkZUFsbCIsIl9iaW5kSGFuZGxlciIsIl9zY3JvbGxUb3AiLCIkc2Nyb2xsVG9wRWxlbWVudCIsInNjcm9sbFRvcEVsZW1lbnQiLCJzY3JvbGxQb3MiLCJzY3JvbGxUb3BPZmZzZXQiLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsIl9oaWRlIiwiY2FsY0hlaWdodCIsInBhcmVudFN1Yk1lbnUiLCJfbWVudUxpbmtFdmVudHMiLCJfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzIiwiX3NldEhpZGVTdWJNZW51Q2xhc3NlcyIsIl9zaG93TWVudSIsImF1dG9Gb2N1cyIsIiRleHBhbmRlZFN1Ym1lbnVzIiwiaW5kZXgiLCJpc0xhc3RDaGlsZCIsImJsdXIiLCJtYXhIZWlnaHQiLCJyZXN1bHQiLCJudW1PZkVsZW1zIiwidW53cmFwIiwiUE9TSVRJT05TIiwiVkVSVElDQUxfQUxJR05NRU5UUyIsIkhPUklaT05UQUxfQUxJR05NRU5UUyIsIkFMSUdOTUVOVFMiLCJuZXh0SXRlbSIsIml0ZW0iLCJhcnJheSIsImN1cnJlbnRJZHgiLCJQb3NpdGlvbmFibGUiLCJ0cmllZFBvc2l0aW9ucyIsIl9nZXREZWZhdWx0UG9zaXRpb24iLCJfZ2V0RGVmYXVsdEFsaWdubWVudCIsIm9yaWdpbmFsUG9zaXRpb24iLCJvcmlnaW5hbEFsaWdubWVudCIsIl9yZXBvc2l0aW9uIiwiX2FsaWdubWVudHNFeGhhdXN0ZWQiLCJfcmVhbGlnbiIsIl9hZGRUcmllZFBvc2l0aW9uIiwiX3Bvc2l0aW9uc0V4aGF1c3RlZCIsImlzRXhoYXVzdGVkIiwiX2dldFZPZmZzZXQiLCJfZ2V0SE9mZnNldCIsIl9zZXRQb3NpdGlvbiIsIiRwYXJlbnQiLCJhbGxvd092ZXJsYXAiLCJtaW5PdmVybGFwIiwibWluQ29vcmRpbmF0ZXMiLCJvdmVybGFwIiwiYWxsb3dCb3R0b21PdmVybGFwIiwiRHJvcGRvd24iLCJfUG9zaXRpb25hYmxlIiwiJGlkIiwiJGFuY2hvcnMiLCJfc2V0Q3VycmVudEFuY2hvciIsInBhcmVudENsYXNzIiwiJGN1cnJlbnRBbmNob3IiLCJtYXRjaCIsImhvcml6b250YWxQb3NpdGlvbiIsImhhc1RvdWNoIiwib250b3VjaHN0YXJ0IiwiZm9yY2VGb2xsb3ciLCJob3ZlciIsImJvZHlEYXRhIiwid2hhdGlucHV0IiwidGltZW91dCIsImhvdmVyRGVsYXkiLCJob3ZlclBhbmUiLCJ2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMiLCJfYWRkQm9keUhhbmRsZXIiLCJEcm9wZG93bk1lbnUiLCJzdWJzIiwidmVydGljYWxDbGFzcyIsInJpZ2h0Q2xhc3MiLCJjaGFuZ2VkIiwiX2lzVmVydGljYWwiLCJfaXNSdGwiLCJwYXJDbGFzcyIsImhhbmRsZUNsaWNrRm4iLCJoYXNTdWIiLCJoYXNDbGlja2VkIiwiY2xpY2tPcGVuIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiY2xvc2VPbkNsaWNrSW5zaWRlIiwiZGlzYWJsZUhvdmVyIiwiYXV0b2Nsb3NlIiwiY2xvc2luZ1RpbWUiLCJpc1RhYiIsIm5leHRTaWJsaW5nIiwicHJldlNpYmxpbmciLCJvcGVuU3ViIiwiY2xvc2VTdWIiLCJfcmVtb3ZlQm9keUhhbmRsZXIiLCJpc0l0c2VsZiIsIiRzaWJzIiwib2xkQ2xhc3MiLCIkcGFyZW50TGkiLCIkdG9DbG9zZSIsInNvbWV0aGluZ1RvQ2xvc2UiLCIkYWN0aXZlSXRlbSIsIkVxdWFsaXplciIsImVxSWQiLCIkd2F0Y2hlZCIsImhhc05lc3RlZCIsImlzTmVzdGVkIiwiaXNPbiIsIm9uUmVzaXplTWVCb3VuZCIsIl9vblJlc2l6ZU1lIiwib25Qb3N0RXF1YWxpemVkQm91bmQiLCJfb25Qb3N0RXF1YWxpemVkIiwiaW1ncyIsInRvb1NtYWxsIiwiZXF1YWxpemVPbiIsIl9jaGVja01RIiwiX3BhdXNlRXZlbnRzIiwiX2tpbGxzd2l0Y2giLCJlcXVhbGl6ZU9uU3RhY2siLCJfaXNTdGFja2VkIiwiZXF1YWxpemVCeVJvdyIsImdldEhlaWdodHNCeVJvdyIsImFwcGx5SGVpZ2h0QnlSb3ciLCJnZXRIZWlnaHRzIiwiYXBwbHlIZWlnaHQiLCJoZWlnaHRzIiwibGVuIiwib2Zmc2V0SGVpZ2h0IiwibGFzdEVsVG9wT2Zmc2V0IiwiZ3JvdXBzIiwiZ3JvdXAiLCJlbE9mZnNldFRvcCIsImoiLCJsbiIsImdyb3Vwc0lMZW5ndGgiLCJsZW5KIiwiSW50ZXJjaGFuZ2UiLCJydWxlcyIsImN1cnJlbnRQYXRoIiwiX3BhcnNlT3B0aW9ucyIsIl9hZGRCcmVha3BvaW50cyIsIl9nZW5lcmF0ZVJ1bGVzIiwicnVsZSIsInBhdGgiLCJ0eXBlcyIsIlNQRUNJQUxfUVVFUklFUyIsInJ1bGVzTGlzdCIsIm5vZGVOYW1lIiwicmVzcG9uc2UiLCJodG1sIiwiU21vb3RoU2Nyb2xsIiwiX2xpbmtDbGlja0xpc3RlbmVyIiwiX2hhbmRsZUxpbmtDbGljayIsImFycml2YWwiLCJfaW5UcmFuc2l0aW9uIiwic2Nyb2xsVG9Mb2MiLCJsb2MiLCIkbG9jIiwicm91bmQiLCJ0aHJlc2hvbGQiLCJNYWdlbGxhbiIsImNhbGNQb2ludHMiLCIkdGFyZ2V0cyIsIiRsaW5rcyIsIiRhY3RpdmUiLCJwb2ludHMiLCJ3aW5IZWlnaHQiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImRvY0hlaWdodCIsInNjcm9sbEhlaWdodCIsIiR0YXIiLCJwdCIsInRhcmdldFBvaW50IiwiZGVlcExpbmtpbmciLCJfdXBkYXRlQWN0aXZlIiwib25Mb2FkTGlzdGVuZXIiLCJfZGVlcExpbmtTY3JvbGwiLCJuZXdTY3JvbGxQb3MiLCJpc1Njcm9sbGluZ1VwIiwiYWN0aXZlSWR4IiwidmlzaWJsZUxpbmtzIiwiJG9sZEFjdGl2ZSIsImFjdGl2ZUhhc2giLCJpc05ld0FjdGl2ZSIsImlzTmV3SGFzaCIsInBhdGhuYW1lIiwic2VhcmNoIiwiT2ZmQ2FudmFzIiwiY29udGVudENsYXNzZXMiLCJyZXZlYWwiLCIkbGFzdFRyaWdnZXIiLCIkdHJpZ2dlcnMiLCJuZXN0ZWQiLCIkc3RpY2t5IiwiaXNJbkNhbnZhcyIsImNvbnRlbnRJZCIsImNvbnRlbnRPdmVybGF5Iiwib3ZlcmxheSIsIm92ZXJsYXlQb3NpdGlvbiIsInNldEF0dHJpYnV0ZSIsIiRvdmVybGF5IiwiaW5zZXJ0QWZ0ZXIiLCJyZXZlYWxPblJlZ0V4cCIsInJldmVhbENsYXNzIiwicmV2ZWFsT25DbGFzcyIsImlzUmV2ZWFsZWQiLCJyZXZlYWxPbiIsIl9zZXRNUUNoZWNrZXIiLCJ0cmFuc2l0aW9uVGltZSIsImNvbnRlbnRTY3JvbGwiLCJpbkNhbnZhc0ZvciIsImluQ2FudmFzT24iLCJfY2hlY2tJbkNhbnZhcyIsIl9yZW1vdmVDb250ZW50Q2xhc3NlcyIsIl9oYW5kbGVLZXlib2FyZCIsImhhc1JldmVhbCIsIl9hZGRDb250ZW50Q2xhc3NlcyIsIl9maXhTdGlja3lFbGVtZW50cyIsIl8iLCJhYnNvbHV0ZVRvcFZhbCIsIl91bmZpeFN0aWNreUVsZW1lbnRzIiwic3RpY2t5RGF0YSIsIl9zdG9wU2Nyb2xsaW5nIiwiX3JlY29yZFNjcm9sbGFibGUiLCJhbGxvd1VwIiwiYWxsb3dEb3duIiwibGFzdFkiLCJvcmlnaW5hbEV2ZW50IiwiX3N0b3BTY3JvbGxQcm9wYWdhdGlvbiIsImhhc0F0dHJpYnV0ZSIsImZvcmNlVG8iLCJzY3JvbGxUbyIsImNhbnZhc0ZvY3VzIiwiT3JiaXQiLCJfcmVzZXQiLCJjb250YWluZXJDbGFzcyIsIiRzbGlkZXMiLCJzbGlkZUNsYXNzIiwiJGltYWdlcyIsImluaXRBY3RpdmUiLCJ1c2VNVUkiLCJfcHJlcGFyZUZvck9yYml0IiwiYnVsbGV0cyIsIl9sb2FkQnVsbGV0cyIsImF1dG9QbGF5IiwiZ2VvU3luYyIsImFjY2Vzc2libGUiLCIkYnVsbGV0cyIsImJveE9mQnVsbGV0cyIsInRpbWVyRGVsYXkiLCJjaGFuZ2VTbGlkZSIsIl9zZXRXcmFwcGVySGVpZ2h0IiwidGVtcCIsImNvdW50ZXIiLCJfc2V0U2xpZGVIZWlnaHQiLCJwYXVzZU9uSG92ZXIiLCJuYXZCdXR0b25zIiwiJGNvbnRyb2xzIiwibmV4dENsYXNzIiwicHJldkNsYXNzIiwiJHNsaWRlIiwiX3VwZGF0ZUJ1bGxldHMiLCJpc0xUUiIsImNob3NlblNsaWRlIiwiJGN1clNsaWRlIiwiJGZpcnN0U2xpZGUiLCIkbGFzdFNsaWRlIiwibGFzdCIsImRpckluIiwiZGlyT3V0IiwiJG5ld1NsaWRlIiwiaW5maW5pdGVXcmFwIiwiJG9sZEJ1bGxldCIsIiRvdGhlcnNCdWxsZXRzIiwiJG5ld0J1bGxldCIsImFjdGl2ZVN0YXRlRGVzY3JpcHRvciIsInNwYW5zIiwic3BhbkNvdW50SW5PdGhlcnNCdWxsZXRzIiwidG9BcnJheSIsImIiLCJldmVyeSIsImNvdW50IiwiYW5pbUluRnJvbVJpZ2h0IiwiYW5pbU91dFRvUmlnaHQiLCJhbmltSW5Gcm9tTGVmdCIsImFuaW1PdXRUb0xlZnQiLCJNZW51UGx1Z2lucyIsImRyb3Bkb3duIiwiY3NzQ2xhc3MiLCJkcmlsbGRvd24iLCJhY2NvcmRpb24iLCJSZXNwb25zaXZlTWVudSIsImN1cnJlbnRNcSIsImN1cnJlbnRQbHVnaW4iLCJydWxlc1RyZWUiLCJydWxlU2l6ZSIsInJ1bGVQbHVnaW4iLCJpc0VtcHR5T2JqZWN0IiwiX2NoZWNrTWVkaWFRdWVyaWVzIiwibWF0Y2hlZE1xIiwiUmVzcG9uc2l2ZVRvZ2dsZSIsInRhcmdldElEIiwiJHRhcmdldE1lbnUiLCIkdG9nZ2xlciIsImFuaW1hdGlvbkluIiwiYW5pbWF0aW9uT3V0IiwiX3VwZGF0ZSIsIl91cGRhdGVNcUhhbmRsZXIiLCJ0b2dnbGVNZW51IiwiaGlkZUZvciIsIlJldmVhbCIsImNhY2hlZCIsIm1xIiwiZnVsbFNjcmVlbiIsIl9tYWtlT3ZlcmxheSIsImFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcyIsIl91cGRhdGVQb3NpdGlvbiIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIm1hcmdpbiIsImNsb3NlWmZUcmlnZ2VyIiwicmVzaXplbWVaZlRyaWdnZXIiLCJfaGFuZGxlU3RhdGUiLCJfZGlzYWJsZVNjcm9sbCIsIl9lbmFibGVTY3JvbGwiLCIkYWN0aXZlQW5jaG9yIiwiYWN0aXZlRWxlbWVudCIsIm11bHRpcGxlT3BlbmVkIiwiYWZ0ZXJBbmltYXRpb24iLCJfYWRkR2xvYmFsQ2xhc3NlcyIsImZvY3VzYWJsZUVsZW1lbnRzIiwic2hvd0RlbGF5IiwiX2FkZEdsb2JhbExpc3RlbmVycyIsInVwZGF0ZVNjcm9sbGJhckNsYXNzIiwidG9nZ2xlQ2xhc3MiLCJfcmVtb3ZlR2xvYmFsQ2xhc3NlcyIsImNsb3NlT25Fc2MiLCJmaW5pc2hVcCIsImhpZGVEZWxheSIsInJlc2V0T25DbG9zZSIsInVybFdpdGhvdXRIYXNoIiwidGl0bGUiLCJTbGlkZXIiLCJpbnB1dHMiLCJoYW5kbGVzIiwiJGhhbmRsZSIsIiRpbnB1dCIsIiRmaWxsIiwidmVydGljYWwiLCJkaXNhYmxlZCIsImRpc2FibGVkQ2xhc3MiLCJiaW5kaW5nIiwiX3NldEluaXRBdHRyIiwiZG91YmxlU2lkZWQiLCIkaGFuZGxlMiIsIiRpbnB1dDIiLCJzZXRIYW5kbGVzIiwiX3NldEhhbmRsZVBvcyIsIl9wY3RPZkJhciIsInBjdE9mQmFyIiwicGVyY2VudCIsInBvc2l0aW9uVmFsdWVGdW5jdGlvbiIsIl9sb2dUcmFuc2Zvcm0iLCJfcG93VHJhbnNmb3JtIiwidG9GaXhlZCIsIl92YWx1ZSIsImJhc2VMb2ciLCJub25MaW5lYXJCYXNlIiwicG93IiwiJGhuZGwiLCJpc0RibCIsImgyVmFsIiwic3RlcCIsImgxVmFsIiwidmVydCIsImhPclciLCJsT3JUIiwiaGFuZGxlRGltIiwiZWxlbURpbSIsInB4VG9Nb3ZlIiwibW92ZW1lbnQiLCJkZWNpbWFsIiwiX3NldFZhbHVlcyIsImlzTGVmdEhuZGwiLCJkaW0iLCJoYW5kbGVQY3QiLCJoYW5kbGVQb3MiLCJpbml0aWFsU3RhcnQiLCJtb3ZlVGltZSIsImNoYW5nZWREZWxheSIsImluaXRWYWwiLCJpbml0aWFsRW5kIiwiX2hhbmRsZUV2ZW50IiwiZGlyZWN0aW9uIiwiZXZlbnRPZmZzZXQiLCJiYXJEaW0iLCJ3aW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwiZWxlbU9mZnNldCIsImV2ZW50RnJvbUJhciIsImJhclhZIiwib2Zmc2V0UGN0IiwiX2FkanVzdFZhbHVlIiwiZmlyc3RIbmRsUG9zIiwiYWJzUG9zaXRpb24iLCJzZWNuZEhuZGxQb3MiLCJkaXYiLCJwcmV2X3ZhbCIsIm5leHRfdmFsIiwiX2V2ZW50c0ZvckhhbmRsZSIsImN1ckhhbmRsZSIsImhhbmRsZUNoYW5nZUV2ZW50IiwiY2xpY2tTZWxlY3QiLCJkcmFnZ2FibGUiLCJfJGhhbmRsZSIsIm9sZFZhbHVlIiwibmV3VmFsdWUiLCJkZWNyZWFzZSIsImluY3JlYXNlIiwiZGVjcmVhc2VfZmFzdCIsImluY3JlYXNlX2Zhc3QiLCJpbnZlcnRWZXJ0aWNhbCIsImZyYWMiLCJudW0iLCJjbGlja1BvcyIsIlN0aWNreSIsIiRjb250YWluZXIiLCJ3YXNXcmFwcGVkIiwiY29udGFpbmVyIiwic3RpY2t5Q2xhc3MiLCJzY3JvbGxDb3VudCIsImNoZWNrRXZlcnkiLCJpc1N0dWNrIiwiY29udGFpbmVySGVpZ2h0IiwiZWxlbUhlaWdodCIsIl9wYXJzZVBvaW50cyIsIl9zZXRTaXplcyIsIl9jYWxjIiwiX3JlbW92ZVN0aWNreSIsInRvcFBvaW50IiwicmV2ZXJzZSIsInRvcEFuY2hvciIsImJ0bSIsImJ0bUFuY2hvciIsInB0cyIsImJyZWFrcyIsInBsYWNlIiwiY2FuU3RpY2siLCJfZXZlbnRzSGFuZGxlciIsIl9wYXVzZUxpc3RlbmVycyIsImNoZWNrU2l6ZXMiLCJib3R0b21Qb2ludCIsIl9zZXRTdGlja3kiLCJzdGlja1RvIiwibXJnbiIsIm5vdFN0dWNrVG8iLCJpc1RvcCIsInN0aWNrVG9Ub3AiLCJhbmNob3JQdCIsImFuY2hvckhlaWdodCIsInRvcE9yQm90dG9tIiwic3RpY2t5T24iLCJuZXdFbGVtV2lkdGgiLCJjb21wIiwicGRuZ2wiLCJwZG5nciIsImR5bmFtaWNIZWlnaHQiLCJuZXdDb250YWluZXJIZWlnaHQiLCJfc2V0QnJlYWtQb2ludHMiLCJtVG9wIiwiZW1DYWxjIiwibWFyZ2luVG9wIiwibUJ0bSIsIm1hcmdpbkJvdHRvbSIsImJvdHRvbSIsImVtIiwiZm9udFNpemUiLCJUYWJzIiwiJHRhYlRpdGxlcyIsImxpbmtDbGFzcyIsImxpbmtBY3RpdmVDbGFzcyIsIm1hdGNoSGVpZ2h0IiwiX3NldEhlaWdodCIsImFuY2hvck5vSGFzaCIsInNlbGVjdFRhYiIsIl9jb2xsYXBzZSIsIl9hZGRLZXlIYW5kbGVyIiwiX2FkZENsaWNrSGFuZGxlciIsIl9zZXRIZWlnaHRNcUhhbmRsZXIiLCJfaGFuZGxlVGFiQ2hhbmdlIiwid3JhcE9uS2V5cyIsImhpc3RvcnlIYW5kbGVkIiwiYWN0aXZlQ29sbGFwc2UiLCIkb2xkVGFiIiwiJHRhYkxpbmsiLCIkdGFyZ2V0Q29udGVudCIsIl9jb2xsYXBzZVRhYiIsInBhbmVsQWN0aXZlQ2xhc3MiLCIkdGFyZ2V0X2FuY2hvciIsIiRhY3RpdmVUYWIiLCJpZFN0ciIsImhhc2hJZFN0ciIsInBhbmVsQ2xhc3MiLCJwYW5lbCIsIlRvZ2dsZXIiLCJ0b2dnbGVyIiwiJHRyaWdnZXIiLCJjb250cm9scyIsImNvbnRhaW5zSWQiLCJfdG9nZ2xlQ2xhc3MiLCJfdXBkYXRlQVJJQSIsIl90b2dnbGVBbmltYXRlIiwiVG9vbHRpcCIsImlzQ2xpY2siLCJ0aXBUZXh0IiwidGVtcGxhdGUiLCJfYnVpbGRUZW1wbGF0ZSIsImFsbG93SHRtbCIsInRyaWdnZXJDbGFzcyIsImVsZW1lbnRDbGFzc05hbWUiLCJTVkdFbGVtZW50IiwiYmFzZVZhbCIsInRvb2x0aXBXaWR0aCIsInRvb2x0aXBIZWlnaHQiLCJ0ZW1wbGF0ZUNsYXNzZXMiLCJ0b29sdGlwQ2xhc3MiLCIkdGVtcGxhdGUiLCJzaG93T24iLCJmYWRlSW4iLCJmYWRlSW5EdXJhdGlvbiIsImZhZGVPdXREdXJhdGlvbiIsImlzRm9jdXMiLCJkaXNhYmxlRm9yVG91Y2giLCJ0b3VjaENsb3NlVGV4dCIsIk1lbnVQbHVnaW5zJDEiLCJ0YWJzIiwiUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMiLCJzdG9yZXpmRGF0YSIsImN1cnJlbnRSdWxlIiwiX2dldEFsbE9wdGlvbnMiLCJhbGxPcHRpb25zIiwiZHVtbXlQbHVnaW4iLCJ0bXBQbHVnaW4iLCJrZXlLZXkiLCJvYmpPYmoiLCJfY2hhbmdlZFpmTWVkaWFRdWVyeUhhbmRsZXIiLCJfaGFuZGxlTWFya3VwIiwidG9TZXQiLCJmcm9tU3RyaW5nIiwiJHBhbmVscyIsInRhYnNUaXRsZSIsInRhYnNQYW5lbCIsIiRsaUhlYWRzIiwiJGxpSGVhZHNBIiwiZGlzcGxheSIsInZpc2liaWxpdHkiLCIkdGFic0NvbnRlbnQiLCIkcGxhY2Vob2xkZXIiLCJ0ZW1wVmFsdWUiLCJfdGFyZ2V0IiwiX3RoaXMkY3VycmVudFJ1bGUiLCJfdGhpcyRjdXJyZW50UnVsZTIiLCJfdGhpcyRjdXJyZW50UnVsZTMiLCJDb3JlIiwiQ29yZVV0aWxzIiwibW9kdWxlU2xpZGVyIiwibW9kdWxlTmFtZSIsIiRzbGlkZXIiLCIkdGhpcyIsIm51bWJlck9mT3B0aW9ucyIsImRhdGFfZGVmYXVsdCIsInNlbGVjdF9jbGFzcyIsIiRzdHlsZWRTZWxlY3QiLCIkbGlzdCIsIiRjbGFzcyIsIiR0aGlzb3B0aW9uIiwiaGlkZGVuIiwicmVsIiwiJGxpc3RJdGVtcyJdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7UUFFQTtRQUNBOzs7Ozs7O0FDN0RBLHdCOzs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7Ozs7QUFDQTs7OztBQUtBOzs7O0FBSUE7O0FBR0E7Ozs7QUFYQTs7QUFFQUEsT0FBT0MsQ0FBUCxHQUFXQSxnQkFBWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDOEI7O0FBRTlCLHNCQUFFQyxRQUFGLEVBQVlDLFVBQVo7O0FBSUEsc0JBQUdELFFBQUgsRUFBY0UsS0FBZCxDQUFvQixZQUFXO0FBQzNCQyxXQUFRQyxHQUFSLENBQWEsUUFBYjs7QUFFQSx5QkFBRSxhQUFGLEVBQWlCQyxLQUFqQixDQUF1QixZQUFZO0FBQ2pDLDRCQUFFLGNBQUYsRUFBa0JKLFVBQWxCLENBQTZCLE1BQTdCO0FBQ0QsSUFGRDs7QUFJ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QTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNB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QStDLFFBQS9DO0FBQ0F3eUMsc0JBQWNydEMsSUFBZCxDQUFtQixTQUFuQixFQUE4QjB0QyxHQUE5QjtBQUNBVCxjQUFNdmxDLEdBQU4sQ0FBVXhQLEVBQUUsSUFBRixFQUFROEgsSUFBUixDQUFhLEtBQWIsQ0FBVjs7QUFFQXN0QyxjQUFNOXpDLElBQU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQXl6QyxjQUFNN2xDLE9BQU4sQ0FBYyxRQUFkO0FBRUgsS0FmRDs7QUFpQkFsUCxNQUFFQyxRQUFGLEVBQVlLLEtBQVosQ0FBa0IsWUFBVztBQUN6QjYwQyxzQkFBY3h5QyxXQUFkLENBQTBCLFFBQTFCO0FBQ0F5eUMsY0FBTTl6QyxJQUFOO0FBQ0E7QUFDSCxLQUpEOztBQU1BbEIsWUFBUUMsR0FBUixDQUFZLFlBQVo7QUFFSCxDQXJFRCxFIiwiZmlsZSI6ImFwcC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDdkNDc0OGRlMGI4M2ZhMWQ5ZTY0IiwibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJqUXVlcnlcIlxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgd2hhdElucHV0IGZyb20gJ3doYXQtaW5wdXQnO1xyXG4vL2ltcG9ydCBUd2Vlbk1heCBmcm9tIFwiZ3NhcC9Ud2Vlbk1heFwiO1xyXG5cclxud2luZG93LiQgPSAkO1xyXG4vL2ltcG9ydCBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9AZm9ydGF3ZXNvbWUvZm9udGF3ZXNvbWUtcHJvL2pzL2FsbC5qc1wiO1xyXG5pbXBvcnQgRm91bmRhdGlvbiBmcm9tICdmb3VuZGF0aW9uLXNpdGVzJztcclxuLy8gSWYgeW91IHdhbnQgdG8gcGljayBhbmQgY2hvb3NlIHdoaWNoIG1vZHVsZXMgdG8gaW5jbHVkZSwgY29tbWVudCBvdXQgdGhlIGFib3ZlIGFuZCB1bmNvbW1lbnRcclxuLy8gdGhlIGxpbmUgYmVsb3dcclxuLy9pbXBvcnQgJy4vbGliL2ZvdW5kYXRpb24tZXhwbGljaXQtcGllY2VzJztcclxuaW1wb3J0ICcuL2xpYi9tb2JpbGVfbW9kdWxlX3NsaWRlcic7XHJcblxyXG4vLyB1bi1jb21tZW50IHRvIGNvbnZlcnQgc2VsZWN0IG1lbnVzIHRvIGN1c3RvbSBqYXZhc2NyaXB0IG1lbnVzXHJcbmltcG9ydCAnLi9saWIvZHJvcGRvd25fbWVudSc7IC8vIGNvbnZlcnRzIHNsZWN0cyBpbnRvIGphdmFzY3JpcHQgc2VsZWN0c1xyXG5cclxuJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xyXG5cclxuXHJcblxyXG4kKCBkb2N1bWVudCApLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgY29uc29sZS5sb2coIFwicmVhZHkhXCIgKTtcclxuXHJcbiAgICAkKFwiLnNlYXJjaC1idG5cIikuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAkKCcjc2VhcmNoTW9kYWwnKS5mb3VuZGF0aW9uKCdvcGVuJyk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgJCgnLm1vYmlsZS1tb2R1bGUtc2xpZGVyJykuc2xpY2soe1xyXG4gICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXHJcbiAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxyXG4gICAgICAgICBhdXRvcGxheTogZmFsc2UsXHJcbiAgICAgICAgIGF1dG9wbGF5U3BlZWQ6IDIwMDAsXHJcbiAgICAgICAgIG1vYmlsZUZpcnN0OiB0cnVlLFxyXG4gICAgICAgICBhcnJvd3M6IGZhbHNlLFxyXG4gICAgICAgICBkb3RzOiB0cnVlLFxyXG4gICAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZSxcclxuICAgICAgICAgcmVzcG9uc2l2ZTogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgIGJyZWFrcG9pbnQ6IDc2NyxcclxuICAgICAgICAgICAgICAgc2V0dGluZ3M6IFwidW5zbGlja1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgXVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoJy5mdWxsLW1vZHVsZS1zbGlkZXInKS5zbGljayh7XHJcbiAgICAgICAgICAgc2xpZGVzVG9TaG93OiAxLFxyXG4gICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxyXG4gICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcclxuICAgICAgICAgICBhdXRvcGxheVNwZWVkOiAyMDAwLFxyXG4gICAgICAgICAgIG1vYmlsZUZpcnN0OiB0cnVlLFxyXG4gICAgICAgICAgIGFycm93czogZmFsc2UsXHJcbiAgICAgICAgICAgZG90czogdHJ1ZSxcclxuICAgICAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAkKCcuc2xpZGVyLTFjYXJkJykuc2xpY2soe1xyXG4gICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXHJcbiAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxyXG4gICAgICAgICBhdXRvcGxheTogZmFsc2UsXHJcbiAgICAgICAgIGF1dG9wbGF5U3BlZWQ6IDIwMDAsXHJcbiAgICAgICAgIG1vYmlsZUZpcnN0OiB0cnVlLFxyXG4gICAgICAgICBhcnJvd3M6IGZhbHNlLFxyXG4gICAgICAgICBkb3RzOiB0cnVlLFxyXG4gICAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICQoJy5zbGlkZXItMWNhcmQtYXV0bycpLnNsaWNrKHtcclxuICAgICAgICAgIHNsaWRlc1RvU2hvdzogMSxcclxuICAgICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxyXG4gICAgICAgICAgYXV0b3BsYXk6IHRydWUsXHJcbiAgICAgICAgICBhdXRvcGxheVNwZWVkOiA0MDAwLFxyXG4gICAgICAgICAgbW9iaWxlRmlyc3Q6IHRydWUsXHJcbiAgICAgICAgICBhcnJvd3M6IGZhbHNlLFxyXG4gICAgICAgICAgZG90czogdHJ1ZVxyXG4gICAgICAgfSk7XHJcblxyXG4gICAgXHJcblxyXG4gICAkKCcuc2xpZGVyLTNjYXJkcycpLnNsaWNrKHtcclxuICAgICAgIHNsaWRlc1RvU2hvdzogMSxcclxuICAgICAgIHNsaWRlc1RvU2Nyb2xsOiAxLFxyXG4gICAgICAgYXV0b3BsYXk6IGZhbHNlLFxyXG4gICAgICAgYXV0b3BsYXlTcGVlZDogMjAwMCxcclxuICAgICAgIG1vYmlsZUZpcnN0OiB0cnVlLFxyXG4gICAgICAgYXJyb3dzOiBmYWxzZSxcclxuICAgICAgIGRvdHM6IHRydWUsXHJcbiAgICAgICBhZGFwdGl2ZUhlaWdodDogdHJ1ZSxcclxuICAgICAgIHJlc3BvbnNpdmU6IFtcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgIGJyZWFrcG9pbnQ6IDEwMjUsXHJcbiAgICAgICAgICAgICBzZXR0aW5nczoge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzVG9TaG93OiAzXHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICBdXHJcbiAgICB9KTtcclxuXHJcbiAgICAkKCcuc2xpZGVyLTJ4MicpLnNsaWNrKHtcclxuICAgICAgc2xpZGVzVG9TaG93OiAxLCBcclxuICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXHJcbiAgICAgIHJvd3M6IDIsXHJcbiAgICAgIHNsaWRlc1BlclJvdzogMixcclxuICAgICAgYXV0b3BsYXk6IGZhbHNlLFxyXG4gICAgICBhdXRvcGxheVNwZWVkOiAyMDAwLFxyXG4gICAgICBtb2JpbGVGaXJzdDogdHJ1ZSxcclxuICAgICAgYXJyb3dzOiBmYWxzZSxcclxuICAgICAgZG90czogdHJ1ZSxcclxuICAgICAgZmFkZTogdHJ1ZSxcclxuICAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWVcclxuICAgfSk7XHJcblxyXG5cclxuLy8gU2NyaXB0IHRvIG1ha2UgYSdjYXJkJyBjbGNrYWJsZS4gbWFrZXN1cmUgdG8gYWRkIHRoZSB1cmwgYXMgYSBkYXRhLXVybD1cInlvdXJfdXJsX2hlcmUuaHRtbFwiIGluIHRoZSBlbGVtZW50LlxyXG4vLyB0byBoYXZlIHRoZSBjYXJkIG9wZW4gaW4gYSBuZXcgd2luZG93IGFkZCBkYXRhLWJsYW5rPVwidHJ1ZVwiXHJcblxyXG4gICAgICAvLyByZW1vdmUgc2VvIGxpbmtzXHJcbiAgICAgICQoJy5zZW8tbGluaycpLmhpZGUoKTtcclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNsaWNrQ2FyZCgpIHtcclxuICAgICAgICAkKCcuc2VvLWxpbmsnKS5oaWRlKCk7XHJcblxyXG4gICAvL2ZpeCB0byBwcmV2ZW50IGNsaWNrIGNhcmQgZnJvbSBmaXJpbmcgd2hlbiBjbGlja2luZyB0aGUgbWV0YSB0YWdzIG9mIHRoZSByZXNvdXJjZXMgaGVybyBtb2R1bGUgICAgIFxyXG4gICAgICAgIHZhciBtZXRhY2xpY2sgPSAwO1xyXG4gICAgICAgICQoJy5yZXNvdXJjZXNfaGVybyAubWV0YScpLmNsaWNrKGZ1bmN0aW9uKCkgeyBcclxuICAgICAgICAgICBtZXRhY2xpY2sgPSAxO1xyXG4gICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbWV0YWNsaWNrID0gMCwgMTAwKTtcclxuICAgICAgICB9IClcclxuICAgICAgICBpZiAobWV0YWNsaWNrID09PSAxKSB7XHJcbiAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJCgnLmNsaWNrLWNhcmQnKS5jbGljayhmdW5jdGlvbigpIHtcclxuXHJcblxyXG4gICAgICAgICAgdmFyIHVybCA9ICQodGhpcykuZGF0YSgndXJsJyk7XHJcbiAgICAgICAgICB2YXIgYmxhbmsgPSAkKHRoaXMpLmRhdGEoJ2JsYW5rJyk7XHJcbiAgICAgICAgICBpZiAoYmxhbmspIHtcclxuICAgICAgICAgICAgd2luZG93Lm9wZW4odXJsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjbGlja0NhcmQoKTtcclxuXHJcblxyXG5cclxuICAgICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAgIC8vUEFHRSBTQ1JPTEwgQU5JTUFUSU9OXHJcbiAgICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAkKCdzZWN0aW9uJykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIF93aW4gICAgID0gJCh3aW5kb3cpLFxyXG4gICAgICAgICAgICAgICBfdGhzICAgICA9ICQodGhpcyksXHJcbiAgICAgICAgICAgICAgIF9wb3MgICAgPSBfdGhzLm9mZnNldCgpLnRvcCxcclxuICAgICAgICAgICAgICAgX3Njcm9sbCA9IF93aW4uc2Nyb2xsVG9wKCksXHJcbiAgICAgICAgICAgICAgIF9oZWlnaHQgPSBfd2luLmhlaWdodCgpO1xyXG4gICAgICAgICBcclxuICAgICAgICAgICAgLy8gKF9zY3JvbGwgPiBfcG9zIC0gX2hlaWdodCAqIDEpID8gX3Rocy5hZGRDbGFzcygnZW50cmFuY2UtYW5pbScpIDogX3Rocy5yZW1vdmVDbGFzcygnZW50cmFuY2UtYW5pbScpO1xyXG4gICAgICAgICAgICAoX3Njcm9sbCA+IF9wb3MgLSBfaGVpZ2h0ICogMSkgPyBfdGhzLmFkZENsYXNzKCdlbnRyYW5jZS1hbmltJykgOiBfdGhzLnJlbW92ZUNsYXNzKCdlbnRyYW5jZS1hbmltJyk7XHJcbiAgICAgICAgIFxyXG4gICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAkKHdpbmRvdykuc2Nyb2xsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAkKCdzZWN0aW9uJykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICB2YXIgX3dpbiAgICAgPSAkKHdpbmRvdyksXHJcbiAgICAgICAgICAgICAgIF90aHMgICAgID0gJCh0aGlzKSxcclxuICAgICAgICAgICAgICAgX3BvcyAgICA9IF90aHMub2Zmc2V0KCkudG9wLFxyXG4gICAgICAgICAgICAgICBfc2Nyb2xsID0gX3dpbi5zY3JvbGxUb3AoKSxcclxuICAgICAgICAgICAgICAgX2hlaWdodCA9IF93aW4uaGVpZ2h0KCk7XHJcbiAgICAgICBcclxuICAgICAgICAgICAoX3Njcm9sbCA+IF9wb3MgLSBfaGVpZ2h0ICogLjkpID8gX3Rocy5hZGRDbGFzcygnZW50cmFuY2UtYW5pbScpIDogX3Rocy5yZW1vdmVDbGFzcygnZW50cmFuY2UtYW5pbScpO1xyXG4gICAgICAgXHJcbiAgICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuXHJcbn0pO1xyXG5cclxuLy8gbWFrZSAkIHNhZmUgdG8gdXNlIHdpdGgganF1ZXJ5XHJcblxyXG5cclxuXHJcbi8vIGZvb3RlciB0b2dnbGUgZm9yIG1vYmlsZVxyXG5mb290ZXJNZW51VG9nZ2xlKCk7XHJcblxyXG5mdW5jdGlvbiBmb290ZXJNZW51VG9nZ2xlKCkgeyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgIGxldCB0b2dnbGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mb290ZXItbmF2LndpZGdldF9uYXZfbWVudSA+IGg2XCIpLFxyXG4gICAgICBjb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5mb290ZXItbmF2LndpZGdldF9uYXZfbWVudVwiKTtcclxuXHJcbiAgIHRvZ2dsZXMuZm9yRWFjaCgodG9nZ2xlLCBpbmQpID0+IHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKXtcclxuICAgICAgY29udGFpbmVyc1tpbmRdLmNsYXNzTGlzdC50b2dnbGUoXCJzZWxlY3RlZFwiKTtcclxuICAgfSkpO1xyXG5cclxufS8vIGVuZCBmb290ZXJNZW51VG9nZ2xlIGZ1bmN0aW9uIGRlZmluaXRpb24gLS0tLS0tLVxyXG5cclxuXHJcbi8vIFJlc2V0IHN0eWxlZCBtZW51cyB0byBkZWZhdWx0cyBcclxuXHJcbi8vIG5vdCB5ZXQgYnVpbHRcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hc3NldHMvanMvYXBwLmpzIiwiLyoqXG4gKiB3aGF0LWlucHV0IC0gQSBnbG9iYWwgdXRpbGl0eSBmb3IgdHJhY2tpbmcgdGhlIGN1cnJlbnQgaW5wdXQgbWV0aG9kIChtb3VzZSwga2V5Ym9hcmQgb3IgdG91Y2gpLlxuICogQHZlcnNpb24gdjQuMy4xXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVuMXNldmVuL3doYXQtaW5wdXRcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIndoYXRJbnB1dFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ3aGF0SW5wdXRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wid2hhdElucHV0XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAvKlxuXHQgICAqIHZhcmlhYmxlc1xuXHQgICAqL1xuXG5cdCAgLy8gbGFzdCB1c2VkIGlucHV0IHR5cGVcblx0ICB2YXIgY3VycmVudElucHV0ID0gJ2luaXRpYWwnO1xuXG5cdCAgLy8gbGFzdCB1c2VkIGlucHV0IGludGVudFxuXHQgIHZhciBjdXJyZW50SW50ZW50ID0gbnVsbDtcblxuXHQgIC8vIGNhY2hlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuXHQgIHZhciBkb2MgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0ICAvLyBmb3JtIGlucHV0IHR5cGVzXG5cdCAgdmFyIGZvcm1JbnB1dHMgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYSddO1xuXG5cdCAgdmFyIGZ1bmN0aW9uTGlzdCA9IFtdO1xuXG5cdCAgLy8gbGlzdCBvZiBtb2RpZmllciBrZXlzIGNvbW1vbmx5IHVzZWQgd2l0aCB0aGUgbW91c2UgYW5kXG5cdCAgLy8gY2FuIGJlIHNhZmVseSBpZ25vcmVkIHRvIHByZXZlbnQgZmFsc2Uga2V5Ym9hcmQgZGV0ZWN0aW9uXG5cdCAgdmFyIGlnbm9yZU1hcCA9IFsxNiwgLy8gc2hpZnRcblx0ICAxNywgLy8gY29udHJvbFxuXHQgIDE4LCAvLyBhbHRcblx0ICA5MSwgLy8gV2luZG93cyBrZXkgLyBsZWZ0IEFwcGxlIGNtZFxuXHQgIDkzIC8vIFdpbmRvd3MgbWVudSAvIHJpZ2h0IEFwcGxlIGNtZFxuXHQgIF07XG5cblx0ICAvLyBsaXN0IG9mIGtleXMgZm9yIHdoaWNoIHdlIGNoYW5nZSBpbnRlbnQgZXZlbiBmb3IgZm9ybSBpbnB1dHNcblx0ICB2YXIgY2hhbmdlSW50ZW50TWFwID0gWzkgLy8gdGFiXG5cdCAgXTtcblxuXHQgIC8vIG1hcHBpbmcgb2YgZXZlbnRzIHRvIGlucHV0IHR5cGVzXG5cdCAgdmFyIGlucHV0TWFwID0ge1xuXHQgICAga2V5ZG93bjogJ2tleWJvYXJkJyxcblx0ICAgIGtleXVwOiAna2V5Ym9hcmQnLFxuXHQgICAgbW91c2Vkb3duOiAnbW91c2UnLFxuXHQgICAgbW91c2Vtb3ZlOiAnbW91c2UnLFxuXHQgICAgTVNQb2ludGVyRG93bjogJ3BvaW50ZXInLFxuXHQgICAgTVNQb2ludGVyTW92ZTogJ3BvaW50ZXInLFxuXHQgICAgcG9pbnRlcmRvd246ICdwb2ludGVyJyxcblx0ICAgIHBvaW50ZXJtb3ZlOiAncG9pbnRlcicsXG5cdCAgICB0b3VjaHN0YXJ0OiAndG91Y2gnXG5cdCAgfTtcblxuXHQgIC8vIGFycmF5IG9mIGFsbCB1c2VkIGlucHV0IHR5cGVzXG5cdCAgdmFyIGlucHV0VHlwZXMgPSBbXTtcblxuXHQgIC8vIGJvb2xlYW46IHRydWUgaWYgdG91Y2ggYnVmZmVyIGlzIGFjdGl2ZVxuXHQgIHZhciBpc0J1ZmZlcmluZyA9IGZhbHNlO1xuXG5cdCAgLy8gYm9vbGVhbjogdHJ1ZSBpZiB0aGUgcGFnZSBpcyBiZWluZyBzY3JvbGxlZFxuXHQgIHZhciBpc1Njcm9sbGluZyA9IGZhbHNlO1xuXG5cdCAgLy8gc3RvcmUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuXHQgIHZhciBtb3VzZVBvcyA9IHtcblx0ICAgIHg6IG51bGwsXG5cdCAgICB5OiBudWxsXG5cdCAgfTtcblxuXHQgIC8vIG1hcCBvZiBJRSAxMCBwb2ludGVyIGV2ZW50c1xuXHQgIHZhciBwb2ludGVyTWFwID0ge1xuXHQgICAgMjogJ3RvdWNoJyxcblx0ICAgIDM6ICd0b3VjaCcsIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG5cdCAgICA0OiAnbW91c2UnXG5cdCAgfTtcblxuXHQgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuXHQgIHRyeSB7XG5cdCAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICAvKlxuXHQgICAqIHNldCB1cFxuXHQgICAqL1xuXG5cdCAgdmFyIHNldFVwID0gZnVuY3Rpb24gc2V0VXAoKSB7XG5cdCAgICAvLyBhZGQgY29ycmVjdCBtb3VzZSB3aGVlbCBldmVudCBtYXBwaW5nIHRvIGBpbnB1dE1hcGBcblx0ICAgIGlucHV0TWFwW2RldGVjdFdoZWVsKCldID0gJ21vdXNlJztcblxuXHQgICAgYWRkTGlzdGVuZXJzKCk7XG5cdCAgICBzZXRJbnB1dCgpO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAqIGV2ZW50c1xuXHQgICAqL1xuXG5cdCAgdmFyIGFkZExpc3RlbmVycyA9IGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcblx0ICAgIC8vIGBwb2ludGVybW92ZWAsIGBNU1BvaW50ZXJNb3ZlYCwgYG1vdXNlbW92ZWAgYW5kIG1vdXNlIHdoZWVsIGV2ZW50IGJpbmRpbmdcblx0ICAgIC8vIGNhbiBvbmx5IGRlbW9uc3RyYXRlIHBvdGVudGlhbCwgYnV0IG5vdCBhY3R1YWwsIGludGVyYWN0aW9uXG5cdCAgICAvLyBhbmQgYXJlIHRyZWF0ZWQgc2VwYXJhdGVseVxuXHQgICAgdmFyIG9wdGlvbnMgPSBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlO1xuXG5cdCAgICAvLyBwb2ludGVyIGV2ZW50cyAobW91c2UsIHBlbiwgdG91Y2gpXG5cdCAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB1cGRhdGVJbnB1dCk7XG5cdCAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHNldEludGVudCk7XG5cdCAgICB9IGVsc2UgaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCkge1xuXHQgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIHVwZGF0ZUlucHV0KTtcblx0ICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCBzZXRJbnRlbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gbW91c2UgZXZlbnRzXG5cdCAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB1cGRhdGVJbnB1dCk7XG5cdCAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzZXRJbnRlbnQpO1xuXG5cdCAgICAgIC8vIHRvdWNoIGV2ZW50c1xuXHQgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB7XG5cdCAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaEJ1ZmZlciwgb3B0aW9ucyk7XG5cdCAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hCdWZmZXIpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIG1vdXNlIHdoZWVsXG5cdCAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihkZXRlY3RXaGVlbCgpLCBzZXRJbnRlbnQsIG9wdGlvbnMpO1xuXG5cdCAgICAvLyBrZXlib2FyZCBldmVudHNcblx0ICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdXBkYXRlSW5wdXQpO1xuXHQgIH07XG5cblx0ICAvLyBjaGVja3MgY29uZGl0aW9ucyBiZWZvcmUgdXBkYXRpbmcgbmV3IGlucHV0XG5cdCAgdmFyIHVwZGF0ZUlucHV0ID0gZnVuY3Rpb24gdXBkYXRlSW5wdXQoZXZlbnQpIHtcblx0ICAgIC8vIG9ubHkgZXhlY3V0ZSBpZiB0aGUgdG91Y2ggYnVmZmVyIHRpbWVyIGlzbid0IHJ1bm5pbmdcblx0ICAgIGlmICghaXNCdWZmZXJpbmcpIHtcblx0ICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQud2hpY2g7XG5cdCAgICAgIHZhciB2YWx1ZSA9IGlucHV0TWFwW2V2ZW50LnR5cGVdO1xuXHQgICAgICBpZiAodmFsdWUgPT09ICdwb2ludGVyJykgdmFsdWUgPSBwb2ludGVyVHlwZShldmVudCk7XG5cblx0ICAgICAgaWYgKGN1cnJlbnRJbnB1dCAhPT0gdmFsdWUgfHwgY3VycmVudEludGVudCAhPT0gdmFsdWUpIHtcblx0ICAgICAgICB2YXIgYWN0aXZlRWxlbSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdCAgICAgICAgdmFyIGFjdGl2ZUlucHV0ID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIG5vdEZvcm1JbnB1dCA9IGFjdGl2ZUVsZW0gJiYgYWN0aXZlRWxlbS5ub2RlTmFtZSAmJiBmb3JtSW5wdXRzLmluZGV4T2YoYWN0aXZlRWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTE7XG5cblx0ICAgICAgICBpZiAobm90Rm9ybUlucHV0IHx8IGNoYW5nZUludGVudE1hcC5pbmRleE9mKGV2ZW50S2V5KSAhPT0gLTEpIHtcblx0ICAgICAgICAgIGFjdGl2ZUlucHV0ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodmFsdWUgPT09ICd0b3VjaCcgfHxcblx0ICAgICAgICAvLyBpZ25vcmUgbW91c2UgbW9kaWZpZXIga2V5c1xuXHQgICAgICAgIHZhbHVlID09PSAnbW91c2UnIHx8XG5cdCAgICAgICAgLy8gZG9uJ3Qgc3dpdGNoIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSBmb3JtIGlucHV0XG5cdCAgICAgICAgdmFsdWUgPT09ICdrZXlib2FyZCcgJiYgZXZlbnRLZXkgJiYgYWN0aXZlSW5wdXQgJiYgaWdub3JlTWFwLmluZGV4T2YoZXZlbnRLZXkpID09PSAtMSkge1xuXHQgICAgICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IGFuZCBjYXRjaC1hbGwgdmFyaWFibGVcblx0ICAgICAgICAgIGN1cnJlbnRJbnB1dCA9IGN1cnJlbnRJbnRlbnQgPSB2YWx1ZTtcblxuXHQgICAgICAgICAgc2V0SW5wdXQoKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLy8gdXBkYXRlcyB0aGUgZG9jIGFuZCBgaW5wdXRUeXBlc2AgYXJyYXkgd2l0aCBuZXcgaW5wdXRcblx0ICB2YXIgc2V0SW5wdXQgPSBmdW5jdGlvbiBzZXRJbnB1dCgpIHtcblx0ICAgIGRvYy5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdGlucHV0JywgY3VycmVudElucHV0KTtcblx0ICAgIGRvYy5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdGludGVudCcsIGN1cnJlbnRJbnB1dCk7XG5cblx0ICAgIGlmIChpbnB1dFR5cGVzLmluZGV4T2YoY3VycmVudElucHV0KSA9PT0gLTEpIHtcblx0ICAgICAgaW5wdXRUeXBlcy5wdXNoKGN1cnJlbnRJbnB1dCk7XG5cdCAgICAgIGRvYy5jbGFzc05hbWUgKz0gJyB3aGF0aW5wdXQtdHlwZXMtJyArIGN1cnJlbnRJbnB1dDtcblx0ICAgIH1cblxuXHQgICAgZmlyZUZ1bmN0aW9ucygnaW5wdXQnKTtcblx0ICB9O1xuXG5cdCAgLy8gdXBkYXRlcyBpbnB1dCBpbnRlbnQgZm9yIGBtb3VzZW1vdmVgIGFuZCBgcG9pbnRlcm1vdmVgXG5cdCAgdmFyIHNldEludGVudCA9IGZ1bmN0aW9uIHNldEludGVudChldmVudCkge1xuXHQgICAgLy8gdGVzdCB0byBzZWUgaWYgYG1vdXNlbW92ZWAgaGFwcGVuZWQgcmVsYXRpdmUgdG8gdGhlIHNjcmVlblxuXHQgICAgLy8gdG8gZGV0ZWN0IHNjcm9sbGluZyB2ZXJzdXMgbW91c2Vtb3ZlXG5cdCAgICBpZiAobW91c2VQb3NbJ3gnXSAhPT0gZXZlbnQuc2NyZWVuWCB8fCBtb3VzZVBvc1sneSddICE9PSBldmVudC5zY3JlZW5ZKSB7XG5cdCAgICAgIGlzU2Nyb2xsaW5nID0gZmFsc2U7XG5cblx0ICAgICAgbW91c2VQb3NbJ3gnXSA9IGV2ZW50LnNjcmVlblg7XG5cdCAgICAgIG1vdXNlUG9zWyd5J10gPSBldmVudC5zY3JlZW5ZO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaXNTY3JvbGxpbmcgPSB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIHRvdWNoIGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXG5cdCAgICAvLyBvciBzY3JvbGxpbmcgaXNuJ3QgaGFwcGVuaW5nXG5cdCAgICBpZiAoIWlzQnVmZmVyaW5nICYmICFpc1Njcm9sbGluZykge1xuXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcblx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xuXG5cdCAgICAgIGlmIChjdXJyZW50SW50ZW50ICE9PSB2YWx1ZSkge1xuXHQgICAgICAgIGN1cnJlbnRJbnRlbnQgPSB2YWx1ZTtcblxuXHQgICAgICAgIGRvYy5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdGludGVudCcsIGN1cnJlbnRJbnRlbnQpO1xuXG5cdCAgICAgICAgZmlyZUZ1bmN0aW9ucygnaW50ZW50Jyk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLy8gYnVmZmVycyB0b3VjaCBldmVudHMgYmVjYXVzZSB0aGV5IGZyZXF1ZW50bHkgYWxzbyBmaXJlIG1vdXNlIGV2ZW50c1xuXHQgIHZhciB0b3VjaEJ1ZmZlciA9IGZ1bmN0aW9uIHRvdWNoQnVmZmVyKGV2ZW50KSB7XG5cdCAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdCAgICAgIGlzQnVmZmVyaW5nID0gZmFsc2U7XG5cblx0ICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IGlucHV0XG5cdCAgICAgIHVwZGF0ZUlucHV0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlzQnVmZmVyaW5nID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgdmFyIGZpcmVGdW5jdGlvbnMgPSBmdW5jdGlvbiBmaXJlRnVuY3Rpb25zKHR5cGUpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmdW5jdGlvbkxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgaWYgKGZ1bmN0aW9uTGlzdFtpXS50eXBlID09PSB0eXBlKSB7XG5cdCAgICAgICAgZnVuY3Rpb25MaXN0W2ldLmZuLmNhbGwodW5kZWZpbmVkLCBjdXJyZW50SW50ZW50KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKlxuXHQgICAqIHV0aWxpdGllc1xuXHQgICAqL1xuXG5cdCAgdmFyIHBvaW50ZXJUeXBlID0gZnVuY3Rpb24gcG9pbnRlclR5cGUoZXZlbnQpIHtcblx0ICAgIGlmICh0eXBlb2YgZXZlbnQucG9pbnRlclR5cGUgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiBwb2ludGVyTWFwW2V2ZW50LnBvaW50ZXJUeXBlXTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG5cdCAgICAgIHJldHVybiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicgPyAndG91Y2gnIDogZXZlbnQucG9pbnRlclR5cGU7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIGRldGVjdCB2ZXJzaW9uIG9mIG1vdXNlIHdoZWVsIGV2ZW50IHRvIHVzZVxuXHQgIC8vIHZpYSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWxcblx0ICB2YXIgZGV0ZWN0V2hlZWwgPSBmdW5jdGlvbiBkZXRlY3RXaGVlbCgpIHtcblx0ICAgIHZhciB3aGVlbFR5cGUgPSB2b2lkIDA7XG5cblx0ICAgIC8vIE1vZGVybiBicm93c2VycyBzdXBwb3J0IFwid2hlZWxcIlxuXHQgICAgaWYgKCdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkge1xuXHQgICAgICB3aGVlbFR5cGUgPSAnd2hlZWwnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gV2Via2l0IGFuZCBJRSBzdXBwb3J0IGF0IGxlYXN0IFwibW91c2V3aGVlbFwiXG5cdCAgICAgIC8vIG9yIGFzc3VtZSB0aGF0IHJlbWFpbmluZyBicm93c2VycyBhcmUgb2xkZXIgRmlyZWZveFxuXHQgICAgICB3aGVlbFR5cGUgPSBkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCA/ICdtb3VzZXdoZWVsJyA6ICdET01Nb3VzZVNjcm9sbCc7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB3aGVlbFR5cGU7XG5cdCAgfTtcblxuXHQgIHZhciBvYmpQb3MgPSBmdW5jdGlvbiBvYmpQb3MobWF0Y2gpIHtcblx0ICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmdW5jdGlvbkxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgaWYgKGZ1bmN0aW9uTGlzdFtpXS5mbiA9PT0gbWF0Y2gpIHtcblx0ICAgICAgICByZXR1cm4gaTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvKlxuXHQgICAqIGluaXRcblx0ICAgKi9cblxuXHQgIC8vIGRvbid0IHN0YXJ0IHNjcmlwdCB1bmxlc3MgYnJvd3NlciBjdXRzIHRoZSBtdXN0YXJkXG5cdCAgLy8gKGFsc28gcGFzc2VzIGlmIHBvbHlmaWxscyBhcmUgdXNlZClcblx0ICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyAmJiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuXHQgICAgc2V0VXAoKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAqIGFwaVxuXHQgICAqL1xuXG5cdCAgcmV0dXJuIHtcblx0ICAgIC8vIHJldHVybnMgc3RyaW5nOiB0aGUgY3VycmVudCBpbnB1dCB0eXBlXG5cdCAgICAvLyBvcHQ6ICdsb29zZSd8J3N0cmljdCdcblx0ICAgIC8vICdzdHJpY3QnIChkZWZhdWx0KTogcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgYGRhdGEtd2hhdGlucHV0YCBhdHRyaWJ1dGVcblx0ICAgIC8vICdsb29zZSc6IGluY2x1ZGVzIGBkYXRhLXdoYXRpbnRlbnRgIHZhbHVlIGlmIGl0J3MgbW9yZSBjdXJyZW50IHRoYW4gYGRhdGEtd2hhdGlucHV0YFxuXHQgICAgYXNrOiBmdW5jdGlvbiBhc2sob3B0KSB7XG5cdCAgICAgIHJldHVybiBvcHQgPT09ICdsb29zZScgPyBjdXJyZW50SW50ZW50IDogY3VycmVudElucHV0O1xuXHQgICAgfSxcblxuXHQgICAgLy8gcmV0dXJucyBhcnJheTogYWxsIHRoZSBkZXRlY3RlZCBpbnB1dCB0eXBlc1xuXHQgICAgdHlwZXM6IGZ1bmN0aW9uIHR5cGVzKCkge1xuXHQgICAgICByZXR1cm4gaW5wdXRUeXBlcztcblx0ICAgIH0sXG5cblx0ICAgIC8vIG92ZXJ3cml0ZXMgaWdub3JlZCBrZXlzIHdpdGggcHJvdmlkZWQgYXJyYXlcblx0ICAgIGlnbm9yZUtleXM6IGZ1bmN0aW9uIGlnbm9yZUtleXMoYXJyKSB7XG5cdCAgICAgIGlnbm9yZU1hcCA9IGFycjtcblx0ICAgIH0sXG5cblx0ICAgIC8vIGF0dGFjaCBmdW5jdGlvbnMgdG8gaW5wdXQgYW5kIGludGVudCBcImV2ZW50c1wiXG5cdCAgICAvLyBmdW5jdDogZnVuY3Rpb24gdG8gZmlyZSBvbiBjaGFuZ2Vcblx0ICAgIC8vIGV2ZW50VHlwZTogJ2lucHV0J3wnaW50ZW50J1xuXHQgICAgcmVnaXN0ZXJPbkNoYW5nZTogZnVuY3Rpb24gcmVnaXN0ZXJPbkNoYW5nZShmbiwgZXZlbnRUeXBlKSB7XG5cdCAgICAgIGZ1bmN0aW9uTGlzdC5wdXNoKHtcblx0ICAgICAgICBmbjogZm4sXG5cdCAgICAgICAgdHlwZTogZXZlbnRUeXBlIHx8ICdpbnB1dCdcblx0ICAgICAgfSk7XG5cdCAgICB9LFxuXG5cdCAgICB1blJlZ2lzdGVyT25DaGFuZ2U6IGZ1bmN0aW9uIHVuUmVnaXN0ZXJPbkNoYW5nZShmbikge1xuXHQgICAgICB2YXIgcG9zaXRpb24gPSBvYmpQb3MoZm4pO1xuXG5cdCAgICAgIGlmIChwb3NpdGlvbikge1xuXHQgICAgICAgIGZ1bmN0aW9uTGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblx0fSgpO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmICghYmFzZSkgcmV0dXJuO1xuICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTtcblxuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgYm9vbGVhbiBmb3IgUlRMIHN1cHBvcnRcbiAqL1xuXG5mdW5jdGlvbiBydGwoKSB7XG4gIHJldHVybiAkKCdodG1sJykuYXR0cignZGlyJykgPT09ICdydGwnO1xufVxuLyoqXG4gKiByZXR1cm5zIGEgcmFuZG9tIGJhc2UtMzYgdWlkIHdpdGggbmFtZXNwYWNpbmdcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCAtIG51bWJlciBvZiByYW5kb20gYmFzZS0zNiBkaWdpdHMgZGVzaXJlZC4gSW5jcmVhc2UgZm9yIG1vcmUgcmFuZG9tIHN0cmluZ3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbmFtZSBvZiBwbHVnaW4gdG8gYmUgaW5jb3Jwb3JhdGVkIGluIHVpZCwgb3B0aW9uYWwuXG4gKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIHVuaXF1ZSBpZFxuICovXG5cblxuZnVuY3Rpb24gR2V0WW9EaWdpdHMoKSB7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDY7XG4gIHZhciBuYW1lc3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgY2hhcnMgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcbiAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBzdHIgKz0gY2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnNMZW5ndGgpXTtcbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2UgPyBcIlwiLmNvbmNhdChzdHIsIFwiLVwiKS5jb25jYXQobmFtZXNwYWNlKSA6IHN0cjtcbn1cbi8qKlxuICogRXNjYXBlIGEgc3RyaW5nIHNvIGl0IGNhbiBiZSB1c2VkIGFzIGEgcmVnZXhwIHBhdHRlcm5cbiAqIEBmdW5jdGlvblxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTMxMDc1Mi80MzE3Mzg0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAtIGVzY2FwZWQgc3RyaW5nXG4gKi9cblxuXG5mdW5jdGlvbiBSZWdFeHBFc2NhcGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbmVuZCgkZWxlbSkge1xuICB2YXIgdHJhbnNpdGlvbnMgPSB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ290cmFuc2l0aW9uZW5kJ1xuICB9O1xuICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgZW5kO1xuXG4gIGZvciAodmFyIHRyYW5zaXRpb24gaW4gdHJhbnNpdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGVsZW0uc3R5bGVbdHJhbnNpdGlvbl0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0cmFuc2l0aW9uXTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICRlbGVtLnRyaWdnZXJIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgWyRlbGVtXSk7XG4gICAgfSwgMSk7XG4gICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm4gYW4gZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yIHdpbmRvdyBsb2FkLlxuICpcbiAqIElmIGAkZWxlbWAgaXMgcGFzc2VkLCBhbiBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBvbiBgJGVsZW1gLiBJZiB3aW5kb3cgaXMgYWxyZWFkeSBsb2FkZWQsIHRoZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZC5cbiAqIElmIGBoYW5kbGVyYCBpcyBwYXNzZWQsIGF0dGFjaCBpdCB0byB0aGUgZXZlbnQgb24gYCRlbGVtYC5cbiAqIENhbGxpbmcgYG9uTG9hZGAgd2l0aG91dCBoYW5kbGVyIGFsbG93cyB5b3UgdG8gZ2V0IHRoZSBldmVudCB0eXBlIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYmVmb3JlIGF0dGFjaGluZyB0aGUgaGFuZGxlciBieSB5b3Vyc2VsZi5cbiAqIEBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSAkZWxlbSAtIGpRdWVyeSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBpZiBwYXNzZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gZnVuY3Rpb24gdG8gYXR0YWNoIHRvIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gZXZlbnQgdHlwZSB0aGF0IHNob3VsZCBvciB3aWxsIGJlIHRyaWdnZXJlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9uTG9hZCgkZWxlbSwgaGFuZGxlcikge1xuICB2YXIgZGlkTG9hZCA9IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZSc7XG4gIHZhciBldmVudFR5cGUgPSAoZGlkTG9hZCA/ICdfZGlkTG9hZCcgOiAnbG9hZCcpICsgJy56Zi51dGlsLm9uTG9hZCc7XG5cbiAgdmFyIGNiID0gZnVuY3Rpb24gY2IoKSB7XG4gICAgcmV0dXJuICRlbGVtLnRyaWdnZXJIYW5kbGVyKGV2ZW50VHlwZSk7XG4gIH07XG5cbiAgaWYgKCRlbGVtKSB7XG4gICAgaWYgKGhhbmRsZXIpICRlbGVtLm9uZShldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgIGlmIChkaWRMb2FkKSBzZXRUaW1lb3V0KGNiKTtlbHNlICQod2luZG93KS5vbmUoJ2xvYWQnLCBjYik7XG4gIH1cblxuICByZXR1cm4gZXZlbnRUeXBlO1xufVxuLyoqXG4gKiBSZXR1bnMgYW4gaGFuZGxlciBmb3IgdGhlIGBtb3VzZWxlYXZlYCB0aGF0IGlnbm9yZSBkaXNhcHBlYXJlZCBtb3VzZXMuXG4gKlxuICogSWYgdGhlIG1vdXNlIFwiZGlzYXBwZWFyZWRcIiBmcm9tIHRoZSBkb2N1bWVudCAobGlrZSB3aGVuIGdvaW5nIG9uIGEgYnJvd3NlciBVSSBlbGVtZW50LCBTZWUgaHR0cHM6Ly9naXQuaW8vemYtMTE0MTApLFxuICogdGhlIGV2ZW50IGlzIGlnbm9yZWQuXG4gKiAtIElmIHRoZSBgaWdub3JlTGVhdmVXaW5kb3dgIGlzIGB0cnVlYCwgdGhlIGV2ZW50IGlzIGlnbm9yZWQgd2hlbiB0aGUgdXNlciBhY3R1YWxseSBsZWZ0IHRoZSB3aW5kb3dcbiAqICAgKGxpa2UgYnkgc3dpdGNoaW5nIHRvIGFuIG90aGVyIHdpbmRvdyB3aXRoIFtBbHRdK1tUYWJdKS5cbiAqIC0gSWYgdGhlIGBpZ25vcmVSZWFwcGVhcmAgaXMgYHRydWVgLCB0aGUgZXZlbnQgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhlIG1vdXNlIHdpbGwgcmVhcHBlYXIgbGF0ZXIgb24gdGhlIGRvY3VtZW50XG4gKiAgIG91dHNpZGUgb2YgdGhlIGVsZW1lbnQgaXQgbGVmdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbXSBoYW5kbGVyIC0gaGFuZGxlciBmb3IgdGhlIGZpbHRlcmVkIGBtb3VzZWxlYXZlYCBldmVudCB0byB3YXRjaC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbXSBvcHRpb25zIC0gb2JqZWN0IG9mIG9wdGlvbnM6XG4gKiAtIHtCb29sZWFufSBbZmFsc2VdIGlnbm9yZUxlYXZlV2luZG93IC0gYWxzbyBpZ25vcmUgd2hlbiB0aGUgdXNlciBzd2l0Y2hlZCB3aW5kb3dzLlxuICogLSB7Qm9vbGVhbn0gW2ZhbHNlXSBpZ25vcmVSZWFwcGVhciAtIGFsc28gaWdub3JlIHdoZW4gdGhlIG1vdXNlIHJlYXBwZWFyZWQgb3V0c2lkZSBvZiB0aGUgZWxlbWVudCBpdCBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSAtIGZpbHRlcmVkIGhhbmRsZXIgdG8gdXNlIHRvIGxpc3RlbiBvbiB0aGUgYG1vdXNlbGVhdmVgIGV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gaWdub3JlTW91c2VkaXNhcHBlYXIoaGFuZGxlcikge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJGlnbm9yZUxlYXZlV2luZG8gPSBfcmVmLmlnbm9yZUxlYXZlV2luZG93LFxuICAgICAgaWdub3JlTGVhdmVXaW5kb3cgPSBfcmVmJGlnbm9yZUxlYXZlV2luZG8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVMZWF2ZVdpbmRvLFxuICAgICAgX3JlZiRpZ25vcmVSZWFwcGVhciA9IF9yZWYuaWdub3JlUmVhcHBlYXIsXG4gICAgICBpZ25vcmVSZWFwcGVhciA9IF9yZWYkaWdub3JlUmVhcHBlYXIgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVSZWFwcGVhcjtcblxuICByZXR1cm4gZnVuY3Rpb24gbGVhdmVFdmVudEhhbmRsZXIoZUxlYXZlKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHJlc3QgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcmVzdFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gaGFuZGxlci5iaW5kLmFwcGx5KGhhbmRsZXIsIFt0aGlzLCBlTGVhdmVdLmNvbmNhdChyZXN0KSk7IC8vIFRoZSBtb3VzZSBsZWZ0OiBjYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBpZiB0aGUgbW91c2UgZW50ZXJlZCBlbHNld2hlcmVcblxuICAgIGlmIChlTGVhdmUucmVsYXRlZFRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBPdGhlcndpc2UsIGNoZWNrIGlmIHRoZSBtb3VzZSBhY3R1YWxseSBsZWZ0IHRoZSB3aW5kb3cuXG4gICAgLy8gSW4gZmlyZWZveCBpZiB0aGUgdXNlciBzd2l0Y2hlZCBiZXR3ZWVuIHdpbmRvd3MsIHRoZSB3aW5kb3cgc2lsbCBoYXZlIHRoZSBmb2N1cyBieSB0aGUgdGltZVxuICAgIC8vIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuIFdlIGhhdmUgdG8gZGVib3VuY2UgdGhlIGV2ZW50IHRvIHRlc3QgdGhpcyBjYXNlLlxuXG5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGxlYXZlRXZlbnREZWJvdW5jZXIoKSB7XG4gICAgICBpZiAoIWlnbm9yZUxlYXZlV2luZG93ICYmIGRvY3VtZW50Lmhhc0ZvY3VzICYmICFkb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSAvLyBPdGhlcndpc2UsIHdhaXQgZm9yIHRoZSBtb3VzZSB0byByZWVhcGVhciBvdXRzaWRlIG9mIHRoZSBlbGVtZW50LFxuXG5cbiAgICAgIGlmICghaWdub3JlUmVhcHBlYXIpIHtcbiAgICAgICAgJChkb2N1bWVudCkub25lKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gcmVlbnRlckV2ZW50SGFuZGxlcihlUmVlbnRlcikge1xuICAgICAgICAgIGlmICghJChlTGVhdmUuY3VycmVudFRhcmdldCkuaGFzKGVSZWVudGVyLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBGaWxsIHdoZXJlIHRoZSBtb3VzZSBmaW5hbGx5IGVudGVyZWQuXG4gICAgICAgICAgICBlTGVhdmUucmVsYXRlZFRhcmdldCA9IGVSZWVudGVyLnRhcmdldDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCAwKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kYXRpb25fY29yZV91dGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgcnRsOiBydGwsXG4gIEdldFlvRGlnaXRzOiBHZXRZb0RpZ2l0cyxcbiAgUmVnRXhwRXNjYXBlOiBSZWdFeHBFc2NhcGUsXG4gIHRyYW5zaXRpb25lbmQ6IHRyYW5zaXRpb25lbmQsXG4gIG9uTG9hZDogb25Mb2FkLFxuICBpZ25vcmVNb3VzZWRpc2FwcGVhcjogaWdub3JlTW91c2VkaXNhcHBlYXJcbn0pO1xuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IMKpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIE1JVCBsaWNlbnNlXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5cbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgc3R5bGVNZWRpYSA9IHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYTsgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuXG4gIGlmICghc3R5bGVNZWRpYSkge1xuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICAgICAgaW5mbyA9IG51bGw7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgc3R5bGUuaWQgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG4gICAgfSAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuXG5cbiAgICBpbmZvID0gJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdyAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24gbWF0Y2hNZWRpdW0obWVkaWEpIHtcbiAgICAgICAgdmFyIHRleHQgPSAnQG1lZGlhICcgKyBtZWRpYSArICd7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfSc7IC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuXG4gICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH0gLy8gVGVzdCBpZiBtZWRpYSBxdWVyeSBpcyB0cnVlIG9yIGZhbHNlXG5cblxuICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAobWVkaWEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2hlczogc3R5bGVNZWRpYS5tYXRjaE1lZGl1bShtZWRpYSB8fCAnYWxsJyksXG4gICAgICBtZWRpYTogbWVkaWEgfHwgJ2FsbCdcbiAgICB9O1xuICB9O1xufSgpKTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIE1lZGlhUXVlcnkgPSB7XG4gIHF1ZXJpZXM6IFtdLFxuICBjdXJyZW50OiAnJyxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlciwgYnkgZXh0cmFjdGluZyB0aGUgYnJlYWtwb2ludCBsaXN0IGZyb20gdGhlIENTUyBhbmQgYWN0aXZhdGluZyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGluaXRpYWxpemF0aW9uIGlzIG9ubHkgZG9uZSBvbmNlIHdoZW4gY2FsbGluZyBfaW5pdCgpIHNldmVyYWwgdGltZXNcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciAkbWV0YSA9ICQoJ21ldGEuZm91bmRhdGlvbi1tcScpO1xuXG4gICAgaWYgKCEkbWV0YS5sZW5ndGgpIHtcbiAgICAgICQoJzxtZXRhIGNsYXNzPVwiZm91bmRhdGlvbi1tcVwiPicpLmFwcGVuZFRvKGRvY3VtZW50LmhlYWQpO1xuICAgIH1cblxuICAgIHZhciBleHRyYWN0ZWRTdHlsZXMgPSAkKCcuZm91bmRhdGlvbi1tcScpLmNzcygnZm9udC1mYW1pbHknKTtcbiAgICB2YXIgbmFtZWRRdWVyaWVzO1xuICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xuICAgIHNlbGYucXVlcmllcyA9IFtdOyAvLyByZXNldFxuXG4gICAgZm9yICh2YXIga2V5IGluIG5hbWVkUXVlcmllcykge1xuICAgICAgaWYgKG5hbWVkUXVlcmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHNlbGYucXVlcmllcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgdmFsdWU6IFwib25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6IFwiLmNvbmNhdChuYW1lZFF1ZXJpZXNba2V5XSwgXCIpXCIpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuX2dldEN1cnJlbnRTaXplKCk7XG5cbiAgICB0aGlzLl93YXRjaGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlaW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlci5cbiAgICogVXNlZnVsIGlmIHlvdXIgQ1NTIGJyZWFrcG9pbnQgY29uZmlndXJhdGlvbiBoYXMganVzdCBiZWVuIGxvYWRlZCBvciBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgaW5pdGlhbGl6YXRpb24uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlSW5pdDogZnVuY3Rpb24gX3JlSW5pdCgpIHtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgYXQgbGVhc3QgYXMgd2lkZSBhcyBhIGJyZWFrcG9pbnQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCdzIHNtYWxsZXIuXG4gICAqL1xuICBhdExlYXN0OiBmdW5jdGlvbiBhdExlYXN0KHNpemUpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgIGlmIChxdWVyeSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KS5tYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgd2l0aGluIHRoZSBnaXZlbiBicmVha3BvaW50LlxuICAgKiBJZiBzbWFsbGVyIHRoYW4gdGhlIGJyZWFrcG9pbnQgb2YgbGFyZ2VyIHRoYW4gaXRzIHVwcGVyIGxpbWl0IGl0IHJldHVybnMgZmFsc2UuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBvbmx5OiBmdW5jdGlvbiBvbmx5KHNpemUpIHtcbiAgICByZXR1cm4gc2l6ZSA9PT0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzY3JlZW4gaXMgd2l0aGluIGEgYnJlYWtwb2ludCBvciBzbWFsbGVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQncyBsYXJnZXIuXG4gICAqL1xuICB1cFRvOiBmdW5jdGlvbiB1cFRvKHNpemUpIHtcbiAgICB2YXIgbmV4dFNpemUgPSB0aGlzLm5leHQoc2l6ZSk7IC8vIElmIHRoZSBuZXh0IGJyZWFrcG9pbnQgZG9lcyBub3QgbWF0Y2gsIHRoZSBzY3JlZW4gaXMgc21hbGxlciB0aGFuXG4gICAgLy8gdGhlIHVwcGVyIGxpbWl0IG9mIHRoaXMgYnJlYWtwb2ludC5cblxuICAgIGlmIChuZXh0U2l6ZSkge1xuICAgICAgcmV0dXJuICF0aGlzLmF0TGVhc3QobmV4dFNpemUpO1xuICAgIH0gLy8gSWYgdGhlcmUgaXMgbm8gbmV4dCBicmVha3BvaW50LCB0aGUgXCJzaXplXCIgYnJlYWtwb2ludCBkb2VzIG5vdCBoYXZlXG4gICAgLy8gYW4gdXBwZXIgbGltaXQgYW5kIHRoZSBzY3JlZW4gd2lsbCBhbHdheXMgYmUgd2l0aGluIGl0IG9yIHNtYWxsZXIuXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBtYXRjaGVzIHRvIGEgYnJlYWtwb2ludC5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjaywgZWl0aGVyICdzbWFsbCBvbmx5JyBvciAnc21hbGwnLiBPbWl0dGluZyAnb25seScgZmFsbHMgYmFjayB0byB1c2luZyBhdExlYXN0KCkgbWV0aG9kLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQgZG9lcyBub3QuXG4gICAqL1xuICBpczogZnVuY3Rpb24gaXMoc2l6ZSkge1xuICAgIHZhciBwYXJ0cyA9IHNpemUudHJpbSgpLnNwbGl0KCcgJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gISFwLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHZhciBfcGFydHMgPSBfc2xpY2VkVG9BcnJheShwYXJ0cywgMiksXG4gICAgICAgIGJwU2l6ZSA9IF9wYXJ0c1swXSxcbiAgICAgICAgX3BhcnRzJCA9IF9wYXJ0c1sxXSxcbiAgICAgICAgYnBNb2RpZmllciA9IF9wYXJ0cyQgPT09IHZvaWQgMCA/ICcnIDogX3BhcnRzJDsgLy8gT25seSB0aGUgYnJlYWtwb250XG5cblxuICAgIGlmIChicE1vZGlmaWVyID09PSAnb25seScpIHtcbiAgICAgIHJldHVybiB0aGlzLm9ubHkoYnBTaXplKTtcbiAgICB9IC8vIEF0IGxlYXN0IHRoZSBicmVha3BvaW50IChpbmNsdWRlZClcblxuXG4gICAgaWYgKCFicE1vZGlmaWVyIHx8IGJwTW9kaWZpZXIgPT09ICd1cCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0TGVhc3QoYnBTaXplKTtcbiAgICB9IC8vIFVwIHRvIHRoZSBicmVha3BvaW50IChpbmNsdWRlZClcblxuXG4gICAgaWYgKGJwTW9kaWZpZXIgPT09ICdkb3duJykge1xuICAgICAgcmV0dXJuIHRoaXMudXBUbyhicFNpemUpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIEludmFsaWQgYnJlYWtwb2ludCBwYXNzZWQgdG8gTWVkaWFRdWVyeS5pcygpLlxcbiAgICAgIEV4cGVjdGVkIGEgYnJlYWtwb2ludCBuYW1lIGZvcm1hdHRlZCBsaWtlIFxcXCI8c2l6ZT4gPG1vZGlmaWVyPlxcXCIsIGdvdCBcXFwiXCIuY29uY2F0KHNpemUsIFwiXFxcIi5cXG4gICAgXCIpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgbWVkaWEgcXVlcnkgb2YgYSBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGdldC5cbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfSAtIFRoZSBtZWRpYSBxdWVyeSBvZiB0aGUgYnJlYWtwb2ludCwgb3IgYG51bGxgIGlmIHRoZSBicmVha3BvaW50IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBnZXQ6IGZ1bmN0aW9uIGdldChzaXplKSB7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLnF1ZXJpZXMpIHtcbiAgICAgIGlmICh0aGlzLnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gcXVlcnkubmFtZSkgcmV0dXJuIHF1ZXJ5LnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGJyZWFrcG9pbnQgZm9sbG93aW5nIHRoZSBnaXZlbiBicmVha3BvaW50LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG5hbWUgb2YgdGhlIGZvbGxvd2luZyBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIHBhc3NlZCBicmVha3BvaW50IHdhcyB0aGUgbGFzdCBvbmUuXG4gICAqL1xuICBuZXh0OiBmdW5jdGlvbiBuZXh0KHNpemUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHF1ZXJ5SW5kZXggPSB0aGlzLnF1ZXJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChxKSB7XG4gICAgICByZXR1cm4gX3RoaXMuX2dldFF1ZXJ5TmFtZShxKSA9PT0gc2l6ZTtcbiAgICB9KTtcblxuICAgIGlmIChxdWVyeUluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBVbmtub3duIGJyZWFrcG9pbnQgXFxcIlwiLmNvbmNhdChzaXplLCBcIlxcXCIgcGFzc2VkIHRvIE1lZGlhUXVlcnkubmV4dCgpLlxcbiAgICAgICAgRW5zdXJlIGl0IGlzIHByZXNlbnQgaW4geW91ciBTYXNzIFxcXCIkYnJlYWtwb2ludHNcXFwiIHNldHRpbmcuXFxuICAgICAgXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFF1ZXJ5ID0gdGhpcy5xdWVyaWVzW3F1ZXJ5SW5kZXggKyAxXTtcbiAgICByZXR1cm4gbmV4dFF1ZXJ5ID8gbmV4dFF1ZXJ5Lm5hbWUgOiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBicmVha3BvaW50IHJlbGF0ZWQgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB2YWx1ZSAtIEJyZWFrcG9pbnQgbmFtZSBvciBxdWVyeSBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQuXG4gICAqL1xuICBfZ2V0UXVlcnlOYW1lOiBmdW5jdGlvbiBfZ2V0UXVlcnlOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoX3R5cGVvZih2YWx1ZSkgPT09ICdvYmplY3QnKSByZXR1cm4gdmFsdWUubmFtZTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxuICAgICAgSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gTWVkaWFRdWVyeS5fZ2V0UXVlcnlOYW1lKCkuXFxuICAgICAgRXhwZWN0ZWQgYSBicmVha3BvaW50IG5hbWUgKFN0cmluZykgb3IgYSBicmVha3BvaW50IHF1ZXJ5IChPYmplY3QpLCBnb3QgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIChcIikuY29uY2F0KF90eXBlb2YodmFsdWUpLCBcIilcXG4gICAgXCIpKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgKi9cbiAgX2dldEN1cnJlbnRTaXplOiBmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKSB7XG4gICAgdmFyIG1hdGNoZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuXG4gICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2hlZCA9IHF1ZXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVkICYmIHRoaXMuX2dldFF1ZXJ5TmFtZShtYXRjaGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2F0Y2hlcjogZnVuY3Rpb24gX3dhdGNoZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuemYubWVkaWFxdWVyeScpLm9uKCdyZXNpemUuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuZXdTaXplID0gX3RoaXMyLl9nZXRDdXJyZW50U2l6ZSgpLFxuICAgICAgICAgIGN1cnJlbnRTaXplID0gX3RoaXMyLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChuZXdTaXplICE9PSBjdXJyZW50U2l6ZSkge1xuICAgICAgICAvLyBDaGFuZ2UgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnlcbiAgICAgICAgX3RoaXMyLmN1cnJlbnQgPSBuZXdTaXplOyAvLyBCcm9hZGNhc3QgdGhlIG1lZGlhIHF1ZXJ5IGNoYW5nZSBvbiB0aGUgd2luZG93XG5cbiAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIFtuZXdTaXplLCBjdXJyZW50U2l6ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59OyAvLyBUaGFuayB5b3U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nXG5cbmZ1bmN0aW9uIHBhcnNlU3R5bGVUb09iamVjdChzdHIpIHtcbiAgdmFyIHN0eWxlT2JqZWN0ID0ge307XG5cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcblxuICBpZiAoIXN0cikge1xuICAgIHJldHVybiBzdHlsZU9iamVjdDtcbiAgfVxuXG4gIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG4gICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcbiAgICB2YXIga2V5ID0gcGFydHNbMF07XG4gICAgdmFyIHZhbCA9IHBhcnRzWzFdO1xuICAgIGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpOyAvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblxuICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG4gICAgaWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuICAgICAgcmV0W2tleV0ucHVzaCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LCB7fSk7XG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cblxudmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjYuMyc7IC8vIEdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxuXG52YXIgRm91bmRhdGlvbiA9IHtcbiAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgaW5pdGlhbGl6ZWQgcGx1Z2lucy5cbiAgICovXG4gIF9wbHVnaW5zOiB7fSxcblxuICAvKipcbiAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXG4gICAqL1xuICBfdXVpZHM6IFtdLFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBwbHVnaW4uXG4gICAqL1xuICBwbHVnaW46IGZ1bmN0aW9uIHBsdWdpbihfcGx1Z2luLCBuYW1lKSB7XG4gICAgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBhZGRpbmcgdG8gZ2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4gICAgLy8gRXhhbXBsZXM6IEZvdW5kYXRpb24uUmV2ZWFsLCBGb3VuZGF0aW9uLk9mZkNhbnZhc1xuICAgIHZhciBjbGFzc05hbWUgPSBuYW1lIHx8IGZ1bmN0aW9uTmFtZShfcGx1Z2luKTsgLy8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBzdG9yaW5nIHRoZSBwbHVnaW4sIGFsc28gdXNlZCB0byBjcmVhdGUgdGhlIGlkZW50aWZ5aW5nIGRhdGEgYXR0cmlidXRlIGZvciB0aGUgcGx1Z2luXG4gICAgLy8gRXhhbXBsZXM6IGRhdGEtcmV2ZWFsLCBkYXRhLW9mZi1jYW52YXNcblxuICAgIHZhciBhdHRyTmFtZSA9IGh5cGhlbmF0ZShjbGFzc05hbWUpOyAvLyBBZGQgdG8gdGhlIEZvdW5kYXRpb24gb2JqZWN0IGFuZCB0aGUgcGx1Z2lucyBsaXN0IChmb3IgcmVmbG93aW5nKVxuXG4gICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBfcGx1Z2luO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxuICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXG4gICAqIEFsc28gZmlyZXMgdGhlIGluaXRpYWxpemF0aW9uIGV2ZW50IGZvciBlYWNoIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cbiAgICogQGZpcmVzIFBsdWdpbiNpbml0XG4gICAqL1xuICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gcmVnaXN0ZXJQbHVnaW4ocGx1Z2luLCBuYW1lKSB7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBuYW1lID8gaHlwaGVuYXRlKG5hbWUpIDogZnVuY3Rpb25OYW1lKHBsdWdpbi5jb25zdHJ1Y3RvcikudG9Mb3dlckNhc2UoKTtcbiAgICBwbHVnaW4udXVpZCA9IEdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xuXG4gICAgaWYgKCFwbHVnaW4uJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpKSkge1xuICAgICAgcGx1Z2luLiRlbGVtZW50LmF0dHIoXCJkYXRhLVwiLmNvbmNhdChwbHVnaW5OYW1lKSwgcGx1Z2luLnV1aWQpO1xuICAgIH1cblxuICAgIGlmICghcGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykpIHtcbiAgICAgIHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicsIHBsdWdpbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV2ZW50IFBsdWdpbiNpbml0XG4gICAgICovXG5cblxuICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKFwiaW5pdC56Zi5cIi5jb25jYXQocGx1Z2luTmFtZSkpO1xuXG4gICAgdGhpcy5fdXVpZHMucHVzaChwbHVnaW4udXVpZCk7XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBSZW1vdmVzIHRoZSBwbHVnaW5zIHV1aWQgZnJvbSB0aGUgX3V1aWRzIGFycmF5LlxuICAgKiBSZW1vdmVzIHRoZSB6ZlBsdWdpbiBkYXRhIGF0dHJpYnV0ZSwgYXMgd2VsbCBhcyB0aGUgZGF0YS1wbHVnaW4tbmFtZSBhdHRyaWJ1dGUuXG4gICAqIEFsc28gZmlyZXMgdGhlIGRlc3Ryb3llZCBldmVudCBmb3IgdGhlIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICogQGZpcmVzIFBsdWdpbiNkZXN0cm95ZWRcbiAgICovXG4gIHVucmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luKSB7XG4gICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XG5cbiAgICB0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZihwbHVnaW4udXVpZCksIDEpO1xuXG4gICAgcGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoXCJkYXRhLVwiLmNvbmNhdChwbHVnaW5OYW1lKSkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgKi9cbiAgICAudHJpZ2dlcihcImRlc3Ryb3llZC56Zi5cIi5jb25jYXQocGx1Z2luTmFtZSkpO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBwbHVnaW4pIHtcbiAgICAgIHBsdWdpbltwcm9wXSA9IG51bGw7IC8vY2xlYW4gdXAgc2NyaXB0IHRvIHByZXAgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBDYXVzZXMgb25lIG9yIG1vcmUgYWN0aXZlIHBsdWdpbnMgdG8gcmUtaW5pdGlhbGl6ZSwgcmVzZXR0aW5nIGV2ZW50IGxpc3RlbmVycywgcmVjYWxjdWxhdGluZyBwb3NpdGlvbnMsIGV0Yy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbnMgLSBvcHRpb25hbCBzdHJpbmcgb2YgYW4gaW5kaXZpZHVhbCBwbHVnaW4ga2V5LCBhdHRhaW5lZCBieSBjYWxsaW5nIGAkKGVsZW1lbnQpLmRhdGEoJ3BsdWdpbk5hbWUnKWAsIG9yIHN0cmluZyBvZiBhIHBsdWdpbiBjbGFzcyBpLmUuIGAnZHJvcGRvd24nYFxuICAgKiBAZGVmYXVsdCBJZiBubyBhcmd1bWVudCBpcyBwYXNzZWQsIHJlZmxvdyBhbGwgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW5zLlxuICAgKi9cbiAgcmVJbml0OiBmdW5jdGlvbiByZUluaXQocGx1Z2lucykge1xuICAgIHZhciBpc0pRID0gcGx1Z2lucyBpbnN0YW5jZW9mICQ7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzSlEpIHtcbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkKHRoaXMpLmRhdGEoJ3pmUGx1Z2luJykuX2luaXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdHlwZSA9IF90eXBlb2YocGx1Z2lucyksXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBmbnMgPSB7XG4gICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uIG9iamVjdChwbGdzKSB7XG4gICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgcCA9IGh5cGhlbmF0ZShwKTtcbiAgICAgICAgICAgICAgJCgnW2RhdGEtJyArIHAgKyAnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbiBzdHJpbmcoKSB7XG4gICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xuICAgICAgICAgICAgJCgnW2RhdGEtJyArIHBsdWdpbnMgKyAnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24gdW5kZWZpbmVkJDEoKSB7XG4gICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBmbnNbdHlwZV0ocGx1Z2lucyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXG4gICAqL1xuICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtLCBwbHVnaW5zKSB7XG4gICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXG4gICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH0gLy8gSWYgcGx1Z2lucyBpcyBhIHN0cmluZywgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIG9uZSBpdGVtXG4gICAgZWxzZSBpZiAodHlwZW9mIHBsdWdpbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBwbHVnaW5cblxuXG4gICAgJC5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uIChpLCBuYW1lKSB7XG4gICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXG4gICAgICB2YXIgcGx1Z2luID0gX3RoaXMuX3BsdWdpbnNbbmFtZV07IC8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcblxuICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nICsgbmFtZSArICddJykuYWRkQmFjaygnW2RhdGEtJyArIG5hbWUgKyAnXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgJCh0aGlzKS5kYXRhKFwiemZQbHVnaW5cIikgPT09ICd1bmRlZmluZWQnO1xuICAgICAgfSk7IC8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxuXG4gICAgICAkZWxlbS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbCA9ICQodGhpcyksXG4gICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgIHJlZmxvdzogdHJ1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgkZWwuYXR0cignZGF0YS1vcHRpb25zJykpIHtcbiAgICAgICAgICAkZWwuYXR0cignZGF0YS1vcHRpb25zJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIF9pbmRleCkge1xuICAgICAgICAgICAgdmFyIG9wdCA9IG9wdGlvbi5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsLnRyaW0oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG9wdFswXSkgb3B0c1tvcHRbMF1dID0gcGFyc2VWYWx1ZShvcHRbMV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAkZWwuZGF0YSgnemZQbHVnaW4nLCBuZXcgcGx1Z2luKCQodGhpcyksIG9wdHMpKTtcbiAgICAgICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuICBnZXRGbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgYWRkVG9KcXVlcnk6IGZ1bmN0aW9uIGFkZFRvSnF1ZXJ5KCQpIHtcbiAgICAvLyBUT0RPOiBjb25zaWRlciBub3QgbWFraW5nIHRoaXMgYSBqUXVlcnkgZnVuY3Rpb25cbiAgICAvLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcblxuICAgIC8qKlxuICAgICAqIFRoZSBGb3VuZGF0aW9uIGpRdWVyeSBtZXRob2QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG1ldGhvZCAtIEFuIGFjdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBjdXJyZW50IGpRdWVyeSBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIGZvdW5kYXRpb24gPSBmdW5jdGlvbiBmb3VuZGF0aW9uKG1ldGhvZCkge1xuICAgICAgdmFyIHR5cGUgPSBfdHlwZW9mKG1ldGhvZCksXG4gICAgICAgICAgJG5vSlMgPSAkKCcubm8tanMnKTtcblxuICAgICAgaWYgKCRub0pTLmxlbmd0aCkge1xuICAgICAgICAkbm9KUy5yZW1vdmVDbGFzcygnbm8tanMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vbmVlZHMgdG8gaW5pdGlhbGl6ZSB0aGUgRm91bmRhdGlvbiBvYmplY3QsIG9yIGFuIGluZGl2aWR1YWwgcGx1Z2luLlxuICAgICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7XG5cbiAgICAgICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxuXG4gICAgICAgIHZhciBwbHVnQ2xhc3MgPSB0aGlzLmRhdGEoJ3pmUGx1Z2luJyk7IC8vZGV0ZXJtaW5lIHRoZSBjbGFzcyBvZiBwbHVnaW5cblxuICAgICAgICBpZiAodHlwZW9mIHBsdWdDbGFzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBsdWdDbGFzc1ttZXRob2RdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vbWFrZSBzdXJlIGJvdGggdGhlIGNsYXNzIGFuZCBtZXRob2QgZXhpc3RcbiAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vaWYgdGhlcmUncyBvbmx5IG9uZSwgY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KHBsdWdDbGFzcywgYXJncyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgICAgICAgLy9vdGhlcndpc2UgbG9vcCB0aHJvdWdoIHRoZSBqUXVlcnkgY29sbGVjdGlvbiBhbmQgaW52b2tlIHRoZSBtZXRob2Qgb24gZWFjaFxuICAgICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2Vycm9yIGZvciBubyBjbGFzcyBvciBubyBtZXRob2RcbiAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJXZSdyZSBzb3JyeSwgJ1wiICsgbWV0aG9kICsgXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcIiArIChwbHVnQ2xhc3MgPyBmdW5jdGlvbk5hbWUocGx1Z0NsYXNzKSA6ICd0aGlzIGVsZW1lbnQnKSArICcuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZXJyb3IgZm9yIGludmFsaWQgYXJndW1lbnQgdHlwZVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiV2UncmUgc29ycnksIFwiLmNvbmNhdCh0eXBlLCBcIiBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgICQuZm4uZm91bmRhdGlvbiA9IGZvdW5kYXRpb247XG4gICAgcmV0dXJuICQ7XG4gIH1cbn07XG5Gb3VuZGF0aW9uLnV0aWwgPSB7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmb3IgYXBwbHlpbmcgYSBkZWJvdW5jZSBlZmZlY3QgdG8gYSBmdW5jdGlvbiBjYWxsLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IC0gVGltZSBpbiBtcyB0byBkZWxheSB0aGUgY2FsbCBvZiBgZnVuY2AuXG4gICAqIEByZXR1cm5zIGZ1bmN0aW9uXG4gICAqL1xuICB0aHJvdHRsZTogZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgZGVsYXkpIHtcbiAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsXG4gICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgICAgaWYgKHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xud2luZG93LkZvdW5kYXRpb24gPSBGb3VuZGF0aW9uOyAvLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbihmdW5jdGlvbiAoKSB7XG4gIGlmICghRGF0ZS5ub3cgfHwgIXdpbmRvdy5EYXRlLm5vdykgd2luZG93LkRhdGUubm93ID0gRGF0ZS5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuICB2YXIgdmVuZG9ycyA9IFsnd2Via2l0JywgJ21veiddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xuICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2cCArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcbiAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdnAgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XG4gIH1cblxuICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgdmFyIG5leHRUaW1lID0gTWF0aC5tYXgobGFzdFRpbWUgKyAxNiwgbm93KTtcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2sobGFzdFRpbWUgPSBuZXh0VGltZSk7XG4gICAgICB9LCBuZXh0VGltZSAtIG5vdyk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcbiAgfVxuICAvKipcbiAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXG4gICAqL1xuXG5cbiAgaWYgKCF3aW5kb3cucGVyZm9ybWFuY2UgfHwgIXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpIHtcbiAgICB3aW5kb3cucGVyZm9ybWFuY2UgPSB7XG4gICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSkoKTtcblxuaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xuICAgIH1cblxuICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgIGZUb0JpbmQgPSB0aGlzLFxuICAgICAgICBmTk9QID0gZnVuY3Rpb24gZk5PUCgpIHt9LFxuICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiBmQm91bmQoKSB7XG4gICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCA/IHRoaXMgOiBvVGhpcywgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMucHJvdG90eXBlKSB7XG4gICAgICAvLyBuYXRpdmUgZnVuY3Rpb25zIGRvbid0IGhhdmUgYSBwcm90b3R5cGVcbiAgICAgIGZOT1AucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG4gICAgfVxuXG4gICAgZkJvdW5kLnByb3RvdHlwZSA9IG5ldyBmTk9QKCk7XG4gICAgcmV0dXJuIGZCb3VuZDtcbiAgfTtcbn0gLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XG5cblxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICh0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlLm5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGZ1bmNOYW1lUmVnZXggPSAvZnVuY3Rpb25cXHMoW14oXXsxLH0pXFwoLztcbiAgICB2YXIgcmVzdWx0cyA9IGZ1bmNOYW1lUmVnZXguZXhlYyhmbi50b1N0cmluZygpKTtcbiAgICByZXR1cm4gcmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzWzFdLnRyaW0oKSA6IFwiXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGZuLnByb3RvdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZm4uY29uc3RydWN0b3IubmFtZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZShzdHIpIHtcbiAgaWYgKCd0cnVlJyA9PT0gc3RyKSByZXR1cm4gdHJ1ZTtlbHNlIGlmICgnZmFsc2UnID09PSBzdHIpIHJldHVybiBmYWxzZTtlbHNlIGlmICghaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiBzdHI7XG59IC8vIENvbnZlcnQgUGFzY2FsQ2FzZSB0byBrZWJhYi1jYXNlXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcblxuXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcbn1cblxudmFyIEJveCA9IHtcbiAgSW1Ob3RUb3VjaGluZ1lvdTogSW1Ob3RUb3VjaGluZ1lvdSxcbiAgT3ZlcmxhcEFyZWE6IE92ZXJsYXBBcmVhLFxuICBHZXREaW1lbnNpb25zOiBHZXREaW1lbnNpb25zLFxuICBHZXRFeHBsaWNpdE9mZnNldHM6IEdldEV4cGxpY2l0T2Zmc2V0c1xuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIGRpbWVuc2lvbnMgb2YgYW4gZWxlbWVudCB0byBhIGNvbnRhaW5lciBhbmQgZGV0ZXJtaW5lcyBjb2xsaXNpb24gZXZlbnRzIHdpdGggY29udGFpbmVyLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHRlc3QgZm9yIGNvbGxpc2lvbnMuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBwYXJlbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyBib3VuZGluZyBjb250YWluZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbHJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgbGVmdCBhbmQgcmlnaHQgdmFsdWVzIG9ubHkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdGJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgdG9wIGFuZCBib3R0b20gdmFsdWVzIG9ubHkuXG4gICAqIEBkZWZhdWx0IGlmIG5vIHBhcmVudCBvYmplY3QgcGFzc2VkLCBkZXRlY3RzIGNvbGxpc2lvbnMgd2l0aCBgd2luZG93YC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiBjb2xsaXNpb24gZnJlZSwgZmFsc2UgaWYgYSBjb2xsaXNpb24gaW4gYW55IGRpcmVjdGlvbi5cbiAgICovXG5cbn07XG5cbmZ1bmN0aW9uIEltTm90VG91Y2hpbmdZb3UoZWxlbWVudCwgcGFyZW50LCBsck9ubHksIHRiT25seSwgaWdub3JlQm90dG9tKSB7XG4gIHJldHVybiBPdmVybGFwQXJlYShlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5LCBpZ25vcmVCb3R0b20pID09PSAwO1xufVxuXG5mdW5jdGlvbiBPdmVybGFwQXJlYShlbGVtZW50LCBwYXJlbnQsIGxyT25seSwgdGJPbmx5LCBpZ25vcmVCb3R0b20pIHtcbiAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxuICAgICAgdG9wT3ZlcixcbiAgICAgIGJvdHRvbU92ZXIsXG4gICAgICBsZWZ0T3ZlcixcbiAgICAgIHJpZ2h0T3ZlcjtcblxuICBpZiAocGFyZW50KSB7XG4gICAgdmFyIHBhckRpbXMgPSBHZXREaW1lbnNpb25zKHBhcmVudCk7XG4gICAgYm90dG9tT3ZlciA9IHBhckRpbXMuaGVpZ2h0ICsgcGFyRGltcy5vZmZzZXQudG9wIC0gKGVsZURpbXMub2Zmc2V0LnRvcCArIGVsZURpbXMuaGVpZ2h0KTtcbiAgICB0b3BPdmVyID0gZWxlRGltcy5vZmZzZXQudG9wIC0gcGFyRGltcy5vZmZzZXQudG9wO1xuICAgIGxlZnRPdmVyID0gZWxlRGltcy5vZmZzZXQubGVmdCAtIHBhckRpbXMub2Zmc2V0LmxlZnQ7XG4gICAgcmlnaHRPdmVyID0gcGFyRGltcy53aWR0aCArIHBhckRpbXMub2Zmc2V0LmxlZnQgLSAoZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGgpO1xuICB9IGVsc2Uge1xuICAgIGJvdHRvbU92ZXIgPSBlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0ICsgZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgLSAoZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQpO1xuICAgIHRvcE92ZXIgPSBlbGVEaW1zLm9mZnNldC50b3AgLSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcDtcbiAgICBsZWZ0T3ZlciA9IGVsZURpbXMub2Zmc2V0LmxlZnQgLSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQ7XG4gICAgcmlnaHRPdmVyID0gZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gKGVsZURpbXMub2Zmc2V0LmxlZnQgKyBlbGVEaW1zLndpZHRoKTtcbiAgfVxuXG4gIGJvdHRvbU92ZXIgPSBpZ25vcmVCb3R0b20gPyAwIDogTWF0aC5taW4oYm90dG9tT3ZlciwgMCk7XG4gIHRvcE92ZXIgPSBNYXRoLm1pbih0b3BPdmVyLCAwKTtcbiAgbGVmdE92ZXIgPSBNYXRoLm1pbihsZWZ0T3ZlciwgMCk7XG4gIHJpZ2h0T3ZlciA9IE1hdGgubWluKHJpZ2h0T3ZlciwgMCk7XG5cbiAgaWYgKGxyT25seSkge1xuICAgIHJldHVybiBsZWZ0T3ZlciArIHJpZ2h0T3ZlcjtcbiAgfVxuXG4gIGlmICh0Yk9ubHkpIHtcbiAgICByZXR1cm4gdG9wT3ZlciArIGJvdHRvbU92ZXI7XG4gIH0gLy8gdXNlIHN1bSBvZiBzcXVhcmVzIGIvYyB3ZSBjYXJlIGFib3V0IG92ZXJsYXAgYXJlYS5cblxuXG4gIHJldHVybiBNYXRoLnNxcnQodG9wT3ZlciAqIHRvcE92ZXIgKyBib3R0b21PdmVyICogYm90dG9tT3ZlciArIGxlZnRPdmVyICogbGVmdE92ZXIgKyByaWdodE92ZXIgKiByaWdodE92ZXIpO1xufVxuLyoqXG4gKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnkgfHwgSFRNTH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3Qgb3IgRE9NIGVsZW1lbnQgZm9yIHdoaWNoIHRvIGdldCB0aGUgZGltZW5zaW9ucy4gQ2FuIGJlIGFueSBlbGVtZW50IG90aGVyIHRoYXQgZG9jdW1lbnQgb3Igd2luZG93LlxuICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gKiBUT0RPIC0gaWYgZWxlbWVudCBpcyB3aW5kb3csIHJldHVybiBvbmx5IHRob3NlIHZhbHVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIEdldERpbWVuc2lvbnMoZWxlbSkge1xuICBlbGVtID0gZWxlbS5sZW5ndGggPyBlbGVtWzBdIDogZWxlbTtcblxuICBpZiAoZWxlbSA9PT0gd2luZG93IHx8IGVsZW0gPT09IGRvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSSdtIHNvcnJ5LCBEYXZlLiBJJ20gYWZyYWlkIEkgY2FuJ3QgZG8gdGhhdC5cIik7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJSZWN0ID0gZWxlbS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgd2luUmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgd2luWCA9IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIG9mZnNldDoge1xuICAgICAgdG9wOiByZWN0LnRvcCArIHdpblksXG4gICAgICBsZWZ0OiByZWN0LmxlZnQgKyB3aW5YXG4gICAgfSxcbiAgICBwYXJlbnREaW1zOiB7XG4gICAgICB3aWR0aDogcGFyUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXG4gICAgICBvZmZzZXQ6IHtcbiAgICAgICAgdG9wOiBwYXJSZWN0LnRvcCArIHdpblksXG4gICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpbmRvd0RpbXM6IHtcbiAgICAgIHdpZHRoOiB3aW5SZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5SZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHdpblksXG4gICAgICAgIGxlZnQ6IHdpblhcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRvcCBhbmQgbGVmdCBpbnRlZ2VyIHBpeGVsIHZhbHVlcyBmb3IgZHluYW1pY2FsbHkgcmVuZGVyZWQgZWxlbWVudHMsXG4gKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93bi4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB3aGVyZVxuICogeW91IGRvbid0IGtub3cgYWxpZ25tZW50LCBidXQgZ2VuZXJhbGx5IGZyb21cbiAqIDYuNCBmb3J3YXJkIHlvdSBzaG91bGQgdXNlIEdldEV4cGxpY2l0T2Zmc2V0cywgYXMgR2V0T2Zmc2V0cyBjb25mbGF0ZXMgcG9zaXRpb24gYW5kIGFsaWdubWVudC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICogQHBhcmFtIHtqUXVlcnl9IGFuY2hvciAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50J3MgYW5jaG9yIHBvaW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXG4gKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtOdW1iZXJ9IGhPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXG4gKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcbiAqL1xuXG5cbmZ1bmN0aW9uIEdldEV4cGxpY2l0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCBhbGlnbm1lbnQsIHZPZmZzZXQsIGhPZmZzZXQsIGlzT3ZlcmZsb3cpIHtcbiAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICRhbmNob3JEaW1zID0gYW5jaG9yID8gR2V0RGltZW5zaW9ucyhhbmNob3IpIDogbnVsbDtcbiAgdmFyIHRvcFZhbCwgbGVmdFZhbDtcblxuICBpZiAoJGFuY2hvckRpbXMgIT09IG51bGwpIHtcbiAgICAvLyBzZXQgcG9zaXRpb24gcmVsYXRlZCBhdHRyaWJ1dGVcbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGxlZnRWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBzZXQgYWxpZ25tZW50IHJlbGF0ZWQgYXR0cmlidXRlXG5cblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgaE9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgbGVmdFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCAtIGhPZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBsZWZ0VmFsID0gaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMiArIGhPZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgdG9wVmFsID0gJGFuY2hvckRpbXMub2Zmc2V0LnRvcCAtIHZPZmZzZXQgKyAkYW5jaG9yRGltcy5oZWlnaHQgLSAkZWxlRGltcy5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICB0b3BWYWwgPSAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgdk9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHRvcFZhbCA9ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0ICsgJGFuY2hvckRpbXMuaGVpZ2h0IC8gMiAtICRlbGVEaW1zLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3BWYWwsXG4gICAgbGVmdDogbGVmdFZhbFxuICB9O1xufVxuXG4vKipcbiAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlcyAtIEltYWdlKHMpIHRvIGNoZWNrIGlmIGxvYWRlZC5cbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICovXG5cbmZ1bmN0aW9uIG9uSW1hZ2VzTG9hZGVkKGltYWdlcywgY2FsbGJhY2spIHtcbiAgdmFyIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcblxuICBpZiAodW5sb2FkZWQgPT09IDApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaW1hZ2VzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIC8vIENoZWNrIGlmIGltYWdlIGlzIGxvYWRlZFxuICAgIGlmICh0aGlzLmNvbXBsZXRlICYmIHR5cGVvZiB0aGlzLm5hdHVyYWxXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBhYm92ZSBjaGVjayBmYWlsZWQsIHNpbXVsYXRlIGxvYWRpbmcgb24gZGV0YWNoZWQgZWxlbWVudC5cbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBTdGlsbCBjb3VudCBpbWFnZSBhcyBsb2FkZWQgaWYgaXQgZmluYWxpemVzIHdpdGggYW4gZXJyb3IuXG5cbiAgICAgIHZhciBldmVudHMgPSBcImxvYWQuemYuaW1hZ2VzIGVycm9yLnpmLmltYWdlc1wiO1xuICAgICAgJChpbWFnZSkub25lKGV2ZW50cywgZnVuY3Rpb24gbWUoZXZlbnQpIHtcbiAgICAgICAgLy8gVW5iaW5kIHRoZSBldmVudCBsaXN0ZW5lcnMuIFdlJ3JlIHVzaW5nICdvbmUnIGJ1dCBvbmx5IG9uZSBvZiB0aGUgdHdvIGV2ZW50cyB3aWxsIGhhdmUgZmlyZWQuXG4gICAgICAgICQodGhpcykub2ZmKGV2ZW50cywgbWUpO1xuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSAkKHRoaXMpLmF0dHIoJ3NyYycpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XG4gICAgdW5sb2FkZWQtLTtcblxuICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gKiBUaGlzIHV0aWwgd2FzIGNyZWF0ZWQgYnkgTWFyaXVzIE9sYmVydHogKlxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcbiAqIG9yIHRoZSB3ZWIgaHR0cDovL3d3dy5tYXJpdXNvbGJlcnR6LmRlLyAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBrZXlDb2RlcyA9IHtcbiAgOTogJ1RBQicsXG4gIDEzOiAnRU5URVInLFxuICAyNzogJ0VTQ0FQRScsXG4gIDMyOiAnU1BBQ0UnLFxuICAzNTogJ0VORCcsXG4gIDM2OiAnSE9NRScsXG4gIDM3OiAnQVJST1dfTEVGVCcsXG4gIDM4OiAnQVJST1dfVVAnLFxuICAzOTogJ0FSUk9XX1JJR0hUJyxcbiAgNDA6ICdBUlJPV19ET1dOJ1xufTtcbnZhciBjb21tYW5kcyA9IHt9OyAvLyBGdW5jdGlvbnMgcHVsbGVkIG91dCB0byBiZSByZWZlcmVuY2VhYmxlIGZyb20gaW50ZXJuYWxzXG5cbmZ1bmN0aW9uIGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpIHtcbiAgaWYgKCEkZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VLZXkoZXZlbnQpIHtcbiAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7IC8vIFJlbW92ZSB1bi1wcmludGFibGUgY2hhcmFjdGVycywgZS5nLiBmb3IgYGZyb21DaGFyQ29kZWAgY2FsbHMgZm9yIENUUkwgb25seSBldmVudHNcblxuICBrZXkgPSBrZXkucmVwbGFjZSgvXFxXKy8sICcnKTtcbiAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSBcIlNISUZUX1wiLmNvbmNhdChrZXkpO1xuICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gXCJDVFJMX1wiLmNvbmNhdChrZXkpO1xuICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSBcIkFMVF9cIi5jb25jYXQoa2V5KTsgLy8gUmVtb3ZlIHRyYWlsaW5nIHVuZGVyc2NvcmUsIGluIGNhc2Ugb25seSBtb2RpZmllcnMgd2VyZSB1c2VkIChlLmcuIG9ubHkgYENUUkxfQUxUYClcblxuICBrZXkgPSBrZXkucmVwbGFjZSgvXyQvLCAnJyk7XG4gIHJldHVybiBrZXk7XG59XG5cbnZhciBLZXlib2FyZCA9IHtcbiAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIChrZXlib2FyZCkgZXZlbnQgYW5kIHJldHVybnMgYSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGl0cyBrZXlcbiAgICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcmV0dXJuIFN0cmluZyBrZXkgLSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBrZXkgcHJlc3NlZFxuICAgKi9cbiAgcGFyc2VLZXk6IHBhcnNlS2V5LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiAoa2V5Ym9hcmQpIGV2ZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQncyBuYW1lLCBlLmcuIFNsaWRlciBvciBSZXZlYWxcbiAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgaGFuZGxlS2V5OiBmdW5jdGlvbiBoYW5kbGVLZXkoZXZlbnQsIGNvbXBvbmVudCwgZnVuY3Rpb25zKSB7XG4gICAgdmFyIGNvbW1hbmRMaXN0ID0gY29tbWFuZHNbY29tcG9uZW50XSxcbiAgICAgICAga2V5Q29kZSA9IHRoaXMucGFyc2VLZXkoZXZlbnQpLFxuICAgICAgICBjbWRzLFxuICAgICAgICBjb21tYW5kLFxuICAgICAgICBmbjtcbiAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7IC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgaXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgaWYgKGV2ZW50LnpmSXNLZXlIYW5kbGVkID09PSB0cnVlKSByZXR1cm47IC8vIFRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxuXG4gICAgaWYgKHR5cGVvZiBjb21tYW5kTGlzdC5sdHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjbWRzID0gY29tbWFuZExpc3Q7IC8vIHVzZSBwbGFpbiBsaXN0XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1lcmdlIGx0ciBhbmQgcnRsOiBpZiBkb2N1bWVudCBpcyBydGwsIHJ0bCBvdmVyd3JpdGVzIGx0ciBhbmQgdmljZSB2ZXJzYVxuICAgICAgaWYgKHJ0bCgpKSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0Lmx0ciwgY29tbWFuZExpc3QucnRsKTtlbHNlIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QucnRsLCBjb21tYW5kTGlzdC5sdHIpO1xuICAgIH1cblxuICAgIGNvbW1hbmQgPSBjbWRzW2tleUNvZGVdO1xuICAgIGZuID0gZnVuY3Rpb25zW2NvbW1hbmRdOyAvLyBFeGVjdXRlIHRoZSBoYW5kbGVyIGlmIGZvdW5kXG5cbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSBmbi5hcHBseSgpOyAvLyBNYXJrIHRoZSBldmVudCBhcyBcImhhbmRsZWRcIiB0byBwcmV2ZW50IGZ1dHVyZSBoYW5kbGluZ3NcblxuICAgICAgZXZlbnQuemZJc0tleUhhbmRsZWQgPSB0cnVlOyAvLyBFeGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWRcblxuICAgICAgaWYgKGZ1bmN0aW9ucy5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW5jdGlvbnMuaGFuZGxlZChyZXR1cm5WYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgbm90IGhhbmRsZWRcbiAgICAgIGlmIChmdW5jdGlvbnMudW5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMudW5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZ1bmN0aW9ucy51bmhhbmRsZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxuICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAqL1xuICBmaW5kRm9jdXNhYmxlOiBmaW5kRm9jdXNhYmxlLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcbiAgICovXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnROYW1lLCBjbWRzKSB7XG4gICAgY29tbWFuZHNbY29tcG9uZW50TmFtZV0gPSBjbWRzO1xuICB9LFxuICAvLyBUT0RPOTQzODogVGhlc2UgcmVmZXJlbmNlcyB0byBLZXlib2FyZCBuZWVkIHRvIG5vdCByZXF1aXJlIGdsb2JhbC4gV2lsbCAndGhpcycgd29yayBpbiB0aGlzIGNvbnRleHQ/XG4gIC8vXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRoZSBmb2N1cyBpbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICogQHBhcmFtICB7alF1ZXJ5fSAkZWxlbWVudCAgalF1ZXJ5IG9iamVjdCB0byB0cmFwIHRoZSBmb3VjcyBpbnRvLlxuICAgKi9cbiAgdHJhcEZvY3VzOiBmdW5jdGlvbiB0cmFwRm9jdXMoJGVsZW1lbnQpIHtcbiAgICB2YXIgJGZvY3VzYWJsZSA9IGZpbmRGb2N1c2FibGUoJGVsZW1lbnQpLFxuICAgICAgICAkZmlyc3RGb2N1c2FibGUgPSAkZm9jdXNhYmxlLmVxKDApLFxuICAgICAgICAkbGFzdEZvY3VzYWJsZSA9ICRmb2N1c2FibGUuZXEoLTEpO1xuICAgICRlbGVtZW50Lm9uKCdrZXlkb3duLnpmLnRyYXBmb2N1cycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gJGxhc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnVEFCJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkZmlyc3RGb2N1c2FibGUuZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSAkZmlyc3RGb2N1c2FibGVbMF0gJiYgcGFyc2VLZXkoZXZlbnQpID09PSAnU0hJRlRfVEFCJykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAkbGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgdHJhcHBlZCBmb2N1cyBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtqUXVlcnl9ICRlbGVtZW50ICBqUXVlcnkgb2JqZWN0IHRvIHJlbGVhc2UgdGhlIGZvY3VzIGZvci5cbiAgICovXG4gIHJlbGVhc2VGb2N1czogZnVuY3Rpb24gcmVsZWFzZUZvY3VzKCRlbGVtZW50KSB7XG4gICAgJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnRyYXBmb2N1cycpO1xuICB9XG59O1xuLypcbiAqIENvbnN0YW50cyBmb3IgZWFzaWVyIGNvbXBhcmluZy5cbiAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICovXG5cbmZ1bmN0aW9uIGdldEtleUNvZGVzKGtjcykge1xuICB2YXIgayA9IHt9O1xuXG4gIGZvciAodmFyIGtjIGluIGtjcykge1xuICAgIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xuICB9XG5cbiAgcmV0dXJuIGs7XG59XG5cbi8qKlxuICogTW90aW9uIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5tb3Rpb25cbiAqL1xuXG52YXIgaW5pdENsYXNzZXMgPSBbJ211aS1lbnRlcicsICdtdWktbGVhdmUnXTtcbnZhciBhY3RpdmVDbGFzc2VzID0gWydtdWktZW50ZXItYWN0aXZlJywgJ211aS1sZWF2ZS1hY3RpdmUnXTtcbnZhciBNb3Rpb24gPSB7XG4gIGFuaW1hdGVJbjogZnVuY3Rpb24gYW5pbWF0ZUluKGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICB9LFxuICBhbmltYXRlT3V0OiBmdW5jdGlvbiBhbmltYXRlT3V0KGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpIHtcbiAgICBhbmltYXRlKGZhbHNlLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gTW92ZShkdXJhdGlvbiwgZWxlbSwgZm4pIHtcbiAgdmFyIGFuaW0sXG4gICAgICBwcm9nLFxuICAgICAgc3RhcnQgPSBudWxsOyAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5cbiAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgZm4uYXBwbHkoZWxlbSk7XG4gICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZSh0cykge1xuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gdHM7IC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG5cbiAgICBwcm9nID0gdHMgLSBzdGFydDtcbiAgICBmbi5hcHBseShlbGVtKTtcblxuICAgIGlmIChwcm9nIDwgZHVyYXRpb24pIHtcbiAgICAgIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbSk7XG4gICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcbiAgICB9XG4gIH1cblxuICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcbn1cbi8qKlxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvciBIVE1MIG9iamVjdCB0byBhbmltYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICBlbGVtZW50ID0gJChlbGVtZW50KS5lcSgwKTtcbiAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaW5pdENsYXNzID0gaXNJbiA/IGluaXRDbGFzc2VzWzBdIDogaW5pdENsYXNzZXNbMV07XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTsgLy8gU2V0IHVwIHRoZSBhbmltYXRpb25cblxuICByZXNldCgpO1xuICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbikuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XG4gICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xuICB9KTsgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxuXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2lsbCB0cmlnZ2VyIHRoZSBicm93c2VyIHRvIHN5bmNocm9ub3VzbHkgY2FsY3VsYXRlIHRoZSBzdHlsZSBhbmQgbGF5b3V0XG4gICAgLy8gYWxzbyBjYWxsZWQgcmVmbG93IG9yIGxheW91dCB0aHJhc2hpbmdcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhXG4gICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICBlbGVtZW50LmNzcygndHJhbnNpdGlvbicsICcnKS5hZGRDbGFzcyhhY3RpdmVDbGFzcyk7XG4gIH0pOyAvLyBDbGVhbiB1cCB0aGUgYW5pbWF0aW9uIHdoZW4gaXQgZmluaXNoZXNcblxuICBlbGVtZW50Lm9uZSh0cmFuc2l0aW9uZW5kKGVsZW1lbnQpLCBmaW5pc2gpOyAvLyBIaWRlcyB0aGUgZWxlbWVudCAoZm9yIG91dCBhbmltYXRpb25zKSwgcmVzZXRzIHRoZSBlbGVtZW50LCBhbmQgcnVucyBhIGNhbGxiYWNrXG5cbiAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIGlmICghaXNJbikgZWxlbWVudC5oaWRlKCk7XG4gICAgcmVzZXQoKTtcbiAgICBpZiAoY2IpIGNiLmFwcGx5KGVsZW1lbnQpO1xuICB9IC8vIFJlc2V0cyB0cmFuc2l0aW9ucyBhbmQgcmVtb3ZlcyBtb3Rpb24tc3BlY2lmaWMgY2xhc3Nlc1xuXG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgZWxlbWVudFswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwO1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJcIi5jb25jYXQoaW5pdENsYXNzLCBcIiBcIikuY29uY2F0KGFjdGl2ZUNsYXNzLCBcIiBcIikuY29uY2F0KGFuaW1hdGlvbikpO1xuICB9XG59XG5cbnZhciBOZXN0ID0ge1xuICBGZWF0aGVyOiBmdW5jdGlvbiBGZWF0aGVyKG1lbnUpIHtcbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3pmJztcbiAgICBtZW51LmF0dHIoJ3JvbGUnLCAnbWVudWJhcicpO1xuICAgIG1lbnUuZmluZCgnYScpLmF0dHIoe1xuICAgICAgJ3JvbGUnOiAnbWVudWl0ZW0nXG4gICAgfSk7XG4gICAgdmFyIGl0ZW1zID0gbWVudS5maW5kKCdsaScpLmF0dHIoe1xuICAgICAgJ3JvbGUnOiAnbm9uZSdcbiAgICB9KSxcbiAgICAgICAgc3ViTWVudUNsYXNzID0gXCJpcy1cIi5jb25jYXQodHlwZSwgXCItc3VibWVudVwiKSxcbiAgICAgICAgc3ViSXRlbUNsYXNzID0gXCJcIi5jb25jYXQoc3ViTWVudUNsYXNzLCBcIi1pdGVtXCIpLFxuICAgICAgICBoYXNTdWJDbGFzcyA9IFwiaXMtXCIuY29uY2F0KHR5cGUsIFwiLXN1Ym1lbnUtcGFyZW50XCIpLFxuICAgICAgICBhcHBseUFyaWEgPSB0eXBlICE9PSAnYWNjb3JkaW9uJzsgLy8gQWNjb3JkaW9ucyBoYW5kbGUgdGhlaXIgb3duIEFSSUEgYXR0cml1dGVzLlxuXG4gICAgaXRlbXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJGl0ZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICRzdWIgPSAkaXRlbS5jaGlsZHJlbigndWwnKTtcblxuICAgICAgaWYgKCRzdWIubGVuZ3RoKSB7XG4gICAgICAgICRpdGVtLmFkZENsYXNzKGhhc1N1YkNsYXNzKTtcblxuICAgICAgICBpZiAoYXBwbHlBcmlhKSB7XG4gICAgICAgICAgJGl0ZW0uYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6ICRpdGVtLmNoaWxkcmVuKCdhOmZpcnN0JykudGV4dCgpXG4gICAgICAgICAgfSk7IC8vIE5vdGU6ICBEcmlsbGRvd25zIGJlaGF2ZSBkaWZmZXJlbnRseSBpbiBob3cgdGhleSBoaWRlLCBhbmQgc28gbmVlZFxuICAgICAgICAgIC8vIGFkZGl0aW9uYWwgYXR0cmlidXRlcy4gIFdlIHNob3VsZCBsb29rIGlmIHRoaXMgcG9zc2libHkgb3Zlci1nZW5lcmFsaXplZFxuICAgICAgICAgIC8vIHV0aWxpdHkgKE5lc3QpIGlzIGFwcHJvcHJpYXRlIHdoZW4gd2UgcmV3b3JrIG1lbnVzIGluIDYuNFxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkcmlsbGRvd24nKSB7XG4gICAgICAgICAgICAkaXRlbS5hdHRyKHtcbiAgICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJHN1Yi5hZGRDbGFzcyhcInN1Ym1lbnUgXCIuY29uY2F0KHN1Yk1lbnVDbGFzcykpLmF0dHIoe1xuICAgICAgICAgICdkYXRhLXN1Ym1lbnUnOiAnJyxcbiAgICAgICAgICAncm9sZSc6ICdtZW51YmFyJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcbiAgICAgICAgICAkc3ViLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKSB7XG4gICAgICAgICRpdGVtLmFkZENsYXNzKFwiaXMtc3VibWVudS1pdGVtIFwiLmNvbmNhdChzdWJJdGVtQ2xhc3MpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0sXG4gIEJ1cm46IGZ1bmN0aW9uIEJ1cm4obWVudSwgdHlwZSkge1xuICAgIHZhciAvL2l0ZW1zID0gbWVudS5maW5kKCdsaScpLFxuICAgIHN1Yk1lbnVDbGFzcyA9IFwiaXMtXCIuY29uY2F0KHR5cGUsIFwiLXN1Ym1lbnVcIiksXG4gICAgICAgIHN1Ykl0ZW1DbGFzcyA9IFwiXCIuY29uY2F0KHN1Yk1lbnVDbGFzcywgXCItaXRlbVwiKSxcbiAgICAgICAgaGFzU3ViQ2xhc3MgPSBcImlzLVwiLmNvbmNhdCh0eXBlLCBcIi1zdWJtZW51LXBhcmVudFwiKTtcbiAgICBtZW51LmZpbmQoJz5saSwgPiBsaSA+IHVsLCAubWVudSwgLm1lbnUgPiBsaSwgW2RhdGEtc3VibWVudV0gPiBsaScpLnJlbW92ZUNsYXNzKFwiXCIuY29uY2F0KHN1Yk1lbnVDbGFzcywgXCIgXCIpLmNvbmNhdChzdWJJdGVtQ2xhc3MsIFwiIFwiKS5jb25jYXQoaGFzU3ViQ2xhc3MsIFwiIGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51IGlzLWFjdGl2ZVwiKSkucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywgJycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lcihlbGVtLCBvcHRpb25zLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgLy9vcHRpb25zIGlzIGFuIG9iamVjdCBmb3IgZWFzaWx5IGFkZGluZyBmZWF0dXJlcyBsYXRlci5cbiAgbmFtZVNwYWNlID0gT2JqZWN0LmtleXMoZWxlbS5kYXRhKCkpWzBdIHx8ICd0aW1lcicsXG4gICAgICByZW1haW4gPSAtMSxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGltZXI7XG5cbiAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuXG4gIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZW1haW4gPSAtMTtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfTtcblxuICB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTsgLy8gaWYoIWVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG5cbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgIHJlbWFpbiA9IHJlbWFpbiA8PSAwID8gZHVyYXRpb24gOiByZW1haW47XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCBmYWxzZSk7XG4gICAgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmZpbml0ZSkge1xuICAgICAgICBfdGhpcy5yZXN0YXJ0KCk7IC8vcmVydW4gdGhlIHRpbWVyLlxuXG4gICAgICB9XG5cbiAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH1cbiAgICB9LCByZW1haW4pO1xuICAgIGVsZW0udHJpZ2dlcihcInRpbWVyc3RhcnQuemYuXCIuY29uY2F0KG5hbWVTcGFjZSkpO1xuICB9O1xuXG4gIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7IC8vaWYoZWxlbS5kYXRhKCdwYXVzZWQnKSl7IHJldHVybiBmYWxzZTsgfS8vbWF5YmUgaW1wbGVtZW50IHRoaXMgc2FuaXR5IGNoZWNrIGlmIHVzZWQgZm9yIG90aGVyIHRoaW5ncy5cblxuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcbiAgICB2YXIgZW5kID0gRGF0ZS5ub3coKTtcbiAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xuICAgIGVsZW0udHJpZ2dlcihcInRpbWVycGF1c2VkLnpmLlwiLmNvbmNhdChuYW1lU3BhY2UpKTtcbiAgfTtcbn1cblxudmFyIFRvdWNoID0ge307XG52YXIgc3RhcnRQb3NYLFxuICAgIHN0YXJ0UG9zWSxcbiAgICBzdGFydFRpbWUsXG4gICAgZWxhcHNlZFRpbWUsXG4gICAgc3RhcnRFdmVudCxcbiAgICBpc01vdmluZyA9IGZhbHNlLFxuICAgIGRpZE1vdmVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG9uVG91Y2hFbmQoZSkge1xuICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcbiAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpOyAvLyBJZiB0aGUgdG91Y2ggZGlkIG5vdCBtb3ZlLCBjb25zaWRlciBpdCBhcyBhIFwidGFwXCJcblxuICBpZiAoIWRpZE1vdmVkKSB7XG4gICAgdmFyIHRhcEV2ZW50ID0gJC5FdmVudCgndGFwJywgc3RhcnRFdmVudCB8fCBlKTtcbiAgICAkKHRoaXMpLnRyaWdnZXIodGFwRXZlbnQpO1xuICB9XG5cbiAgc3RhcnRFdmVudCA9IG51bGw7XG4gIGlzTW92aW5nID0gZmFsc2U7XG4gIGRpZE1vdmVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpIHtcbiAgaWYgKCQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgaWYgKGlzTW92aW5nKSB7XG4gICAgdmFyIHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgdmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgdmFyIGR4ID0gc3RhcnRQb3NYIC0geDtcbiAgICB2YXIgZGlyO1xuICAgIGRpZE1vdmVkID0gdHJ1ZTtcbiAgICBlbGFwc2VkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lO1xuXG4gICAgaWYgKE1hdGguYWJzKGR4KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAgIGRpciA9IGR4ID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSAvLyBlbHNlIGlmKE1hdGguYWJzKGR5KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcbiAgICAvLyAgIGRpciA9IGR5ID4gMCA/ICdkb3duJyA6ICd1cCc7XG4gICAgLy8gfVxuXG5cbiAgICBpZiAoZGlyKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvblRvdWNoRW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJC5FdmVudCgnc3dpcGUnLCBPYmplY3QuYXNzaWduKHt9LCBlKSksIGRpcikudHJpZ2dlcigkLkV2ZW50KFwic3dpcGVcIi5jb25jYXQoZGlyKSwgT2JqZWN0LmFzc2lnbih7fSwgZSkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcbiAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgIHN0YXJ0UG9zWCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICBzdGFydFBvc1kgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgc3RhcnRFdmVudCA9IGU7XG4gICAgaXNNb3ZpbmcgPSB0cnVlO1xuICAgIGRpZE1vdmVkID0gZmFsc2U7XG4gICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xufVxuXG52YXIgU3BvdFN3aXBlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BvdFN3aXBlKCQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BvdFN3aXBlKTtcblxuICAgIHRoaXMudmVyc2lvbiA9ICcxLjAuMCc7XG4gICAgdGhpcy5lbmFibGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHRoaXMucHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICB0aGlzLm1vdmVUaHJlc2hvbGQgPSA3NTtcbiAgICB0aGlzLnRpbWVUaHJlc2hvbGQgPSAyMDA7XG4gICAgdGhpcy4kID0gJDtcblxuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTcG90U3dpcGUsIFt7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyICQgPSB0aGlzLiQ7XG4gICAgICAkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7XG4gICAgICAgIHNldHVwOiBpbml0XG4gICAgICB9O1xuICAgICAgJC5ldmVudC5zcGVjaWFsLnRhcCA9IHtcbiAgICAgICAgc2V0dXA6IGluaXRcbiAgICAgIH07XG4gICAgICAkLmVhY2goWydsZWZ0JywgJ3VwJywgJ2Rvd24nLCAncmlnaHQnXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAkLmV2ZW50LnNwZWNpYWxbXCJzd2lwZVwiLmNvbmNhdCh0aGlzKV0gPSB7XG4gICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgICAgICAgICAgJCh0aGlzKS5vbignc3dpcGUnLCAkLm5vb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcG90U3dpcGU7XG59KCk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQXMgZmFyIGFzIEkgY2FuIHRlbGwsIGJvdGggc2V0dXBTcG90U3dpcGUgYW5kICAgICpcbiAqIHNldHVwVG91Y2hIYW5kbGVyIHNob3VsZCBiZSBpZGVtcG90ZW50LCAgICAgICAgICAqXG4gKiBiZWNhdXNlIHRoZXkgZGlyZWN0bHkgcmVwbGFjZSBmdW5jdGlvbnMgJiAgICAgICAgKlxuICogdmFsdWVzLCBhbmQgZG8gbm90IGFkZCBldmVudCBoYW5kbGVycyBkaXJlY3RseS4gICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRvdWNoLnNldHVwU3BvdFN3aXBlID0gZnVuY3Rpb24gKCQpIHtcbiAgJC5zcG90U3dpcGUgPSBuZXcgU3BvdFN3aXBlKCQpO1xufTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNZXRob2QgZm9yIGFkZGluZyBwc2V1ZG8gZHJhZyBldmVudHMgdG8gZWxlbWVudHMgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5Ub3VjaC5zZXR1cFRvdWNoSGFuZGxlciA9IGZ1bmN0aW9uICgkKSB7XG4gICQuZm4uYWRkVG91Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgJChlbCkuYmluZCgndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy93ZSBwYXNzIHRoZSBvcmlnaW5hbCBldmVudCBvYmplY3QgYmVjYXVzZSB0aGUgalF1ZXJ5IGV2ZW50XG4gICAgICAgIC8vb2JqZWN0IGlzIG5vcm1hbGl6ZWQgdG8gdzNjIHNwZWNzIGFuZCBkb2VzIG5vdCBwcm92aWRlIHRoZSBUb3VjaExpc3RcbiAgICAgICAgaGFuZGxlVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGFuZGxlVG91Y2ggPSBmdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCkge1xuICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG4gICAgICAgICAgZXZlbnRUeXBlcyA9IHtcbiAgICAgICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgICAgIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gICAgICAgIHRvdWNoZW5kOiAnbW91c2V1cCdcbiAgICAgIH0sXG4gICAgICAgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXG4gICAgICAgICAgc2ltdWxhdGVkRXZlbnQ7XG5cbiAgICAgIGlmICgnTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XG4gICAgICAgICAgJ2J1YmJsZXMnOiB0cnVlLFxuICAgICAgICAgICdjYW5jZWxhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXG4gICAgICAgICAgJ3NjcmVlblknOiBmaXJzdC5zY3JlZW5ZLFxuICAgICAgICAgICdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcbiAgICAgICAgICAnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG4gICAgICAgIHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgZmlyc3Quc2NyZWVuWCwgZmlyc3Quc2NyZWVuWSwgZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDBcbiAgICAgICAgLypsZWZ0Ki9cbiAgICAgICAgLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgZmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuICAgIH07XG4gIH07XG59O1xuXG5Ub3VjaC5pbml0ID0gZnVuY3Rpb24gKCQpIHtcbiAgaWYgKHR5cGVvZiAkLnNwb3RTd2lwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBUb3VjaC5zZXR1cFNwb3RTd2lwZSgkKTtcbiAgICBUb3VjaC5zZXR1cFRvdWNoSGFuZGxlcigkKTtcbiAgfVxufTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoXCJcIi5jb25jYXQocHJlZml4ZXNbaV0sIFwiTXV0YXRpb25PYnNlcnZlclwiKSBpbiB3aW5kb3cpIHtcbiAgICAgIHJldHVybiB3aW5kb3dbXCJcIi5jb25jYXQocHJlZml4ZXNbaV0sIFwiTXV0YXRpb25PYnNlcnZlclwiKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSgpO1xuXG52YXIgdHJpZ2dlcnMgPSBmdW5jdGlvbiB0cmlnZ2VycyhlbCwgdHlwZSkge1xuICBlbC5kYXRhKHR5cGUpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAkKFwiI1wiLmNvbmNhdChpZCkpW3R5cGUgPT09ICdjbG9zZScgPyAndHJpZ2dlcicgOiAndHJpZ2dlckhhbmRsZXInXShcIlwiLmNvbmNhdCh0eXBlLCBcIi56Zi50cmlnZ2VyXCIpLCBbZWxdKTtcbiAgfSk7XG59O1xuXG52YXIgVHJpZ2dlcnMgPSB7XG4gIExpc3RlbmVyczoge1xuICAgIEJhc2ljOiB7fSxcbiAgICBHbG9iYWw6IHt9XG4gIH0sXG4gIEluaXRpYWxpemVyczoge31cbn07XG5UcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMgPSB7XG4gIG9wZW5MaXN0ZW5lcjogZnVuY3Rpb24gb3Blbkxpc3RlbmVyKCkge1xuICAgIHRyaWdnZXJzKCQodGhpcyksICdvcGVuJyk7XG4gIH0sXG4gIGNsb3NlTGlzdGVuZXI6IGZ1bmN0aW9uIGNsb3NlTGlzdGVuZXIoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xuXG4gICAgaWYgKGlkKSB7XG4gICAgICB0cmlnZ2VycygkKHRoaXMpLCAnY2xvc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LFxuICB0b2dnbGVMaXN0ZW5lcjogZnVuY3Rpb24gdG9nZ2xlTGlzdGVuZXIoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUnKTtcblxuICAgIGlmIChpZCkge1xuICAgICAgdHJpZ2dlcnMoJCh0aGlzKSwgJ3RvZ2dsZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LFxuICBjbG9zZWFibGVMaXN0ZW5lcjogZnVuY3Rpb24gY2xvc2VhYmxlTGlzdGVuZXIoZSkge1xuICAgIHZhciBhbmltYXRpb24gPSAkKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7IC8vIE9ubHkgY2xvc2UgdGhlIGZpcnN0IGNsb3NhYmxlIGVsZW1lbnQuIFNlZSBodHRwczovL2dpdC5pby96Zi03ODMzXG5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKGFuaW1hdGlvbiAhPT0gJycpIHtcbiAgICAgIE1vdGlvbi5hbmltYXRlT3V0KCQodGhpcyksIGFuaW1hdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoJ2Nsb3NlZC56ZicpO1xuICAgIH1cbiAgfSxcbiAgdG9nZ2xlRm9jdXNMaXN0ZW5lcjogZnVuY3Rpb24gdG9nZ2xlRm9jdXNMaXN0ZW5lcigpIHtcbiAgICB2YXIgaWQgPSAkKHRoaXMpLmRhdGEoJ3RvZ2dsZS1mb2N1cycpO1xuICAgICQoXCIjXCIuY29uY2F0KGlkKSkudHJpZ2dlckhhbmRsZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJywgWyQodGhpcyldKTtcbiAgfVxufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1vcGVuXSB3aWxsIHJldmVhbCBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE9wZW5MaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xuICAkZWxlbS5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMub3Blbkxpc3RlbmVyKTtcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtb3Blbl0nLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMub3Blbkxpc3RlbmVyKTtcbn07IC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2VdIHdpbGwgY2xvc2UgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4vLyBJZiB1c2VkIHdpdGhvdXQgYSB2YWx1ZSBvbiBbZGF0YS1jbG9zZV0sIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgYWxsb3dpbmcgaXQgdG8gY2xvc2UgYSBwYXJlbnQgY29tcG9uZW50LlxuXG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRDbG9zZUxpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XG4gICRlbGVtLm9mZignY2xpY2suemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy5jbG9zZUxpc3RlbmVyKTtcbiAgJGVsZW0ub24oJ2NsaWNrLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2VdJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlTGlzdGVuZXIpO1xufTsgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGVdIHdpbGwgdG9nZ2xlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuXG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xuICAkZWxlbS5vZmYoJ2NsaWNrLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuQmFzaWMudG9nZ2xlTGlzdGVuZXIpO1xuICAkZWxlbS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGVdJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUxpc3RlbmVyKTtcbn07IC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cblxuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VhYmxlTGlzdGVuZXIgPSBmdW5jdGlvbiAoJGVsZW0pIHtcbiAgJGVsZW0ub2ZmKCdjbG9zZS56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlYWJsZUxpc3RlbmVyKTtcbiAgJGVsZW0ub24oJ2Nsb3NlLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2VhYmxlXSwgW2RhdGEtY2xvc2FibGVdJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLmNsb3NlYWJsZUxpc3RlbmVyKTtcbn07IC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtdG9nZ2xlLWZvY3VzXSB3aWxsIHJlc3BvbmQgdG8gY29taW5nIGluIGFuZCBvdXQgb2YgZm9jdXNcblxuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkVG9nZ2xlRm9jdXNMaXN0ZW5lciA9IGZ1bmN0aW9uICgkZWxlbSkge1xuICAkZWxlbS5vZmYoJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgVHJpZ2dlcnMuTGlzdGVuZXJzLkJhc2ljLnRvZ2dsZUZvY3VzTGlzdGVuZXIpO1xuICAkZWxlbS5vbignZm9jdXMuemYudHJpZ2dlciBibHVyLnpmLnRyaWdnZXInLCAnW2RhdGEtdG9nZ2xlLWZvY3VzXScsIFRyaWdnZXJzLkxpc3RlbmVycy5CYXNpYy50b2dnbGVGb2N1c0xpc3RlbmVyKTtcbn07IC8vIE1vcmUgR2xvYmFsL2NvbXBsZXggbGlzdGVuZXJzIGFuZCB0cmlnZ2Vyc1xuXG5cblRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwgPSB7XG4gIHJlc2l6ZUxpc3RlbmVyOiBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcigkbm9kZXMpIHtcbiAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIC8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xuICAgICAgfSk7XG4gICAgfSAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgcmVzaXplIGV2ZW50XG5cblxuICAgICRub2Rlcy5hdHRyKCdkYXRhLWV2ZW50cycsIFwicmVzaXplXCIpO1xuICB9LFxuICBzY3JvbGxMaXN0ZW5lcjogZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIoJG5vZGVzKSB7XG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInKTtcbiAgICAgIH0pO1xuICAgIH0gLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHNjcm9sbCBldmVudFxuXG5cbiAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInNjcm9sbFwiKTtcbiAgfSxcbiAgY2xvc2VNZUxpc3RlbmVyOiBmdW5jdGlvbiBjbG9zZU1lTGlzdGVuZXIoZSwgcGx1Z2luSWQpIHtcbiAgICB2YXIgcGx1Z2luID0gZS5uYW1lc3BhY2Uuc3BsaXQoJy4nKVswXTtcbiAgICB2YXIgcGx1Z2lucyA9ICQoXCJbZGF0YS1cIi5jb25jYXQocGx1Z2luLCBcIl1cIikpLm5vdChcIltkYXRhLXlldGktYm94PVxcXCJcIi5jb25jYXQocGx1Z2luSWQsIFwiXFxcIl1cIikpO1xuICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSAkKHRoaXMpO1xuXG4gICAgICBfdGhpcy50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsIFtfdGhpc10pO1xuICAgIH0pO1xuICB9IC8vIEdsb2JhbCwgcGFyc2VzIHdob2xlIGRvY3VtZW50LlxuXG59O1xuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VtZUxpc3RlbmVyID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgdmFyIHlldGlCb3hlcyA9ICQoJ1tkYXRhLXlldGktYm94XScpLFxuICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xuXG4gIGlmIChwbHVnaW5OYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgcGx1Z05hbWVzLnB1c2gocGx1Z2luTmFtZSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHBsdWdpbk5hbWUpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGx1Z2luTmFtZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBsdWdOYW1lcyA9IHBsdWdOYW1lcy5jb25jYXQocGx1Z2luTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoeWV0aUJveGVzLmxlbmd0aCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBwbHVnTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gXCJjbG9zZW1lLnpmLlwiLmNvbmNhdChuYW1lKTtcbiAgICB9KS5qb2luKCcgJyk7XG4gICAgJCh3aW5kb3cpLm9mZihsaXN0ZW5lcnMpLm9uKGxpc3RlbmVycywgVHJpZ2dlcnMuTGlzdGVuZXJzLkdsb2JhbC5jbG9zZU1lTGlzdGVuZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCB0cmlnZ2VyLCBsaXN0ZW5lcikge1xuICB2YXIgdGltZXIsXG4gICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgJCh3aW5kb3cpLm9mZih0cmlnZ2VyKS5vbih0cmlnZ2VyLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICh0aW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICB9XG5cbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgZGVib3VuY2UgfHwgMTApOyAvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxuICB9KTtcbn1cblxuVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGRlYm91bmNlKSB7XG4gIHZhciAkbm9kZXMgPSAkKCdbZGF0YS1yZXNpemVdJyk7XG5cbiAgaWYgKCRub2Rlcy5sZW5ndGgpIHtcbiAgICBkZWJvdW5jZUdsb2JhbExpc3RlbmVyKGRlYm91bmNlLCAncmVzaXplLnpmLnRyaWdnZXInLCBUcmlnZ2Vycy5MaXN0ZW5lcnMuR2xvYmFsLnJlc2l6ZUxpc3RlbmVyLCAkbm9kZXMpO1xuICB9XG59O1xuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiAoZGVib3VuY2UpIHtcbiAgdmFyICRub2RlcyA9ICQoJ1tkYXRhLXNjcm9sbF0nKTtcblxuICBpZiAoJG5vZGVzLmxlbmd0aCkge1xuICAgIGRlYm91bmNlR2xvYmFsTGlzdGVuZXIoZGVib3VuY2UsICdzY3JvbGwuemYudHJpZ2dlcicsIFRyaWdnZXJzLkxpc3RlbmVycy5HbG9iYWwuc2Nyb2xsTGlzdGVuZXIsICRub2Rlcyk7XG4gIH1cbn07XG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRNdXRhdGlvbkV2ZW50c0xpc3RlbmVyID0gZnVuY3Rpb24gKCRlbGVtKSB7XG4gIGlmICghTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciAkbm9kZXMgPSAkZWxlbS5maW5kKCdbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdJyk7IC8vZWxlbWVudCBjYWxsYmFja1xuXG4gIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24gbGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbihtdXRhdGlvblJlY29yZHNMaXN0KSB7XG4gICAgdmFyICR0YXJnZXQgPSAkKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTsgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxuXG4gICAgc3dpdGNoIChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVzXCI6XG4gICAgICAgIGlmICgkdGFyZ2V0LmF0dHIoXCJkYXRhLWV2ZW50c1wiKSA9PT0gXCJzY3JvbGxcIiAmJiBtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1ldmVudHNcIikge1xuICAgICAgICAgICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLCBbJHRhcmdldCwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJHRhcmdldC5hdHRyKFwiZGF0YS1ldmVudHNcIikgPT09IFwicmVzaXplXCIgJiYgbXV0YXRpb25SZWNvcmRzTGlzdFswXS5hdHRyaWJ1dGVOYW1lID09PSBcImRhdGEtZXZlbnRzXCIpIHtcbiAgICAgICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICAgICR0YXJnZXQuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikuYXR0cihcImRhdGEtZXZlbnRzXCIsIFwibXV0YXRlXCIpO1xuICAgICAgICAgICR0YXJnZXQuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjpcbiAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS5hdHRyKFwiZGF0YS1ldmVudHNcIiwgXCJtdXRhdGVcIik7XG4gICAgICAgICR0YXJnZXQuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKV0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy9ub3RoaW5nXG4gICAgfVxuICB9O1xuXG4gIGlmICgkbm9kZXMubGVuZ3RoKSB7XG4gICAgLy9mb3IgZWFjaCBlbGVtZW50IHRoYXQgbmVlZHMgdG8gbGlzdGVuIGZvciByZXNpemluZywgc2Nyb2xsaW5nLCBvciBtdXRhdGlvbiBhZGQgYSBzaW5nbGUgb2JzZXJ2ZXJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAkbm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgZWxlbWVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbik7XG4gICAgICBlbGVtZW50T2JzZXJ2ZXIub2JzZXJ2ZSgkbm9kZXNbaV0sIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBjaGFyYWN0ZXJEYXRhOiBmYWxzZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJkYXRhLWV2ZW50c1wiLCBcInN0eWxlXCJdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cblRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRTaW1wbGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZE9wZW5MaXN0ZW5lcigkZG9jdW1lbnQpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkQ2xvc2VMaXN0ZW5lcigkZG9jdW1lbnQpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkVG9nZ2xlTGlzdGVuZXIoJGRvY3VtZW50KTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlYWJsZUxpc3RlbmVyKCRkb2N1bWVudCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRUb2dnbGVGb2N1c0xpc3RlbmVyKCRkb2N1bWVudCk7XG59O1xuXG5UcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkR2xvYmFsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgJGRvY3VtZW50ID0gJChkb2N1bWVudCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRNdXRhdGlvbkV2ZW50c0xpc3RlbmVyKCRkb2N1bWVudCk7XG4gIFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRSZXNpemVMaXN0ZW5lcigpO1xuICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2Nyb2xsTGlzdGVuZXIoKTtcbiAgVHJpZ2dlcnMuSW5pdGlhbGl6ZXJzLmFkZENsb3NlbWVMaXN0ZW5lcigpO1xufTtcblxuVHJpZ2dlcnMuaW5pdCA9IGZ1bmN0aW9uICgkLCBGb3VuZGF0aW9uKSB7XG4gIG9uTG9hZCgkKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJC50cmlnZ2Vyc0luaXRpYWxpemVkICE9PSB0cnVlKSB7XG4gICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkU2ltcGxlTGlzdGVuZXJzKCk7XG4gICAgICBUcmlnZ2Vycy5Jbml0aWFsaXplcnMuYWRkR2xvYmFsTGlzdGVuZXJzKCk7XG4gICAgICAkLnRyaWdnZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKEZvdW5kYXRpb24pIHtcbiAgICBGb3VuZGF0aW9uLlRyaWdnZXJzID0gVHJpZ2dlcnM7IC8vIExlZ2FjeSBpbmNsdWRlZCB0byBiZSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmb3Igbm93LlxuXG4gICAgRm91bmRhdGlvbi5JSGVhcllvdSA9IFRyaWdnZXJzLkluaXRpYWxpemVycy5hZGRHbG9iYWxMaXN0ZW5lcnM7XG4gIH1cbn07XG5cbi8vIHtmdW5jdGlvbn0gX3NldHVwIChyZXBsYWNlcyBwcmV2aW91cyBjb25zdHJ1Y3RvciksXG4vLyB7ZnVuY3Rpb259IF9kZXN0cm95IChyZXBsYWNlcyBwcmV2aW91cyBkZXN0cm95KVxuXG52YXIgUGx1Z2luID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGx1Z2luKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGx1Z2luKTtcblxuICAgIHRoaXMuX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHBsdWdpbk5hbWUgPSBnZXRQbHVnaW5OYW1lKHRoaXMpO1xuICAgIHRoaXMudXVpZCA9IEdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xuXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LmF0dHIoXCJkYXRhLVwiLmNvbmNhdChwbHVnaW5OYW1lKSkpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcImRhdGEtXCIuY29uY2F0KHBsdWdpbk5hbWUpLCB0aGlzLnV1aWQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQGV2ZW50IFBsdWdpbiNpbml0XG4gICAgICovXG5cblxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcImluaXQuemYuXCIuY29uY2F0KHBsdWdpbk5hbWUpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQbHVnaW4sIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcblxuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBnZXRQbHVnaW5OYW1lKHRoaXMpO1xuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVBdHRyKFwiZGF0YS1cIi5jb25jYXQocGx1Z2luTmFtZSkpLnJlbW92ZURhdGEoJ3pmUGx1Z2luJylcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAgICAgICAqIEBldmVudCBQbHVnaW4jZGVzdHJveWVkXG4gICAgICAgKi9cbiAgICAgIC50cmlnZ2VyKFwiZGVzdHJveWVkLnpmLlwiLmNvbmNhdChwbHVnaW5OYW1lKSk7XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gdGhpcykge1xuICAgICAgICB0aGlzW3Byb3BdID0gbnVsbDsgLy9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQbHVnaW47XG59KCk7IC8vIENvbnZlcnQgUGFzY2FsQ2FzZSB0byBrZWJhYi1jYXNlXG4vLyBUaGFuayB5b3U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg5NTU1ODBcblxuXG5mdW5jdGlvbiBoeXBoZW5hdGUkMShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBnZXRQbHVnaW5OYW1lKG9iaikge1xuICByZXR1cm4gaHlwaGVuYXRlJDEob2JqLmNsYXNzTmFtZSk7XG59XG5cbi8qKlxuICogQWJpZGUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmFiaWRlXG4gKi9cblxudmFyIEFiaWRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhBYmlkZSwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gQWJpZGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFiaWRlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWJpZGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFiaWRlLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQWJpZGUuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgQWJpZGVcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgQWJpZGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZm9ybW5vdmFsaWRhdGUgPSBudWxsO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWJpZGUnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgQWJpZGUgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IEFiaWRlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGlucHV0cyA9ICQubWVyZ2UoIC8vIENvbnNpZGVyIGFzIGlucHV0IHRvIHZhbGlkYXRlOlxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCcpLm5vdCgnW3R5cGU9XCJzdWJtaXRcIl0nKSwgLy8gKiBhbGwgaW5wdXQgZmllbGRzIGV4cGVjdCBzdWJtaXRcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgndGV4dGFyZWEsIHNlbGVjdCcpIC8vICogYWxsIHRleHRhcmVhcyBhbmQgc2VsZWN0IGZpZWxkc1xuICAgICAgKTtcbiAgICAgIHRoaXMuJHN1Ym1pdHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1t0eXBlPVwic3VibWl0XCJdJyk7XG4gICAgICB2YXIgJGdsb2JhbEVycm9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJyk7IC8vIEFkZCBhMTF5IGF0dHJpYnV0ZXMgdG8gYWxsIGZpZWxkc1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmExMXlBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uIChpLCBpbnB1dCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkQTExeUF0dHJpYnV0ZXMoJChpbnB1dCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgJGdsb2JhbEVycm9ycy5lYWNoKGZ1bmN0aW9uIChpLCBlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlcygkKGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBBYmlkZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKS5vbigncmVzZXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5yZXNldEZvcm0oKTtcbiAgICAgIH0pLm9uKCdzdWJtaXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMudmFsaWRhdGVGb3JtKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHN1Ym1pdHMub2ZmKCdjbGljay56Zi5hYmlkZSBrZXlkb3duLnpmLmFiaWRlJykub24oJ2NsaWNrLnpmLmFiaWRlIGtleWRvd24uemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUua2V5IHx8IGUua2V5ID09PSAnICcgfHwgZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMzLmZvcm1ub3ZhbGlkYXRlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdmb3Jtbm92YWxpZGF0ZScpICE9PSBudWxsO1xuXG4gICAgICAgICAgX3RoaXMzLiRlbGVtZW50LnN1Ym1pdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZU9uID09PSAnZmllbGRDaGFuZ2UnKSB7XG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2NoYW5nZS56Zi5hYmlkZScpLm9uKCdjaGFuZ2UuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMy52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVZhbGlkYXRlKSB7XG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2lucHV0LnpmLmFiaWRlJykub24oJ2lucHV0LnpmLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBfdGhpczMudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlT25CbHVyKSB7XG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2JsdXIuemYuYWJpZGUnKS5vbignYmx1ci56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgX3RoaXMzLnZhbGlkYXRlSW5wdXQoJChlLnRhcmdldCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgQWJpZGUgdXBvbiBET00gY2hhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHN1Ym1pdHRlZCBmb3JtIHNob3VsZCBiZSB2YWxpZGF0ZWQgb3Igbm90LCBjb25zb2RlcmluZyBmb3Jtbm92YWxpZGF0ZSBhbmQgaXNFbmFibGVkXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl92YWxpZGF0aW9uSXNEaXNhYmxlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGlvbklzRGlzYWJsZWQoKSB7XG4gICAgICBpZiAodGhpcy5pc0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHdob2xlIHZhbGlkYXRpb24gZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmZvcm1ub3ZhbGlkYXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5ICRzdWJtaXRcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybW5vdmFsaWRhdGU7XG4gICAgICB9IC8vIHRyaWdnZXJlZCBieSBFbnRlciBpbiBub24tc3VibWl0IGlucHV0XG5cblxuICAgICAgcmV0dXJuIHRoaXMuJHN1Ym1pdHMubGVuZ3RoID8gdGhpcy4kc3VibWl0c1swXS5nZXRBdHRyaWJ1dGUoJ2Zvcm1ub3ZhbGlkYXRlJykgIT09IG51bGwgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd2hvbGUgdmFsaWRhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlVmFsaWRhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVWYWxpZGF0aW9uKCkge1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgd2hvbGUgdmFsaWRhdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVZhbGlkYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVZhbGlkYXRpb24oKSB7XG4gICAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSBmb3JtIGVsZW1lbnQgaGFzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYW5kIGlmIGl0J3MgY2hlY2tlZCBvciBub3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlcXVpcmVkQ2hlY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWlyZWRDaGVjaygkZWwpIHtcbiAgICAgIGlmICghJGVsLmF0dHIoJ3JlcXVpcmVkJykpIHJldHVybiB0cnVlO1xuICAgICAgdmFyIGlzR29vZCA9IHRydWU7XG5cbiAgICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICAgIGlzR29vZCA9ICRlbFswXS5jaGVja2VkO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgIHZhciBvcHQgPSAkZWwuZmluZCgnb3B0aW9uOnNlbGVjdGVkJyk7XG4gICAgICAgICAgaWYgKCFvcHQubGVuZ3RoIHx8ICFvcHQudmFsKCkpIGlzR29vZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCEkZWwudmFsKCkgfHwgISRlbC52YWwoKS5sZW5ndGgpIGlzR29vZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNHb29kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQ6XG4gICAgICogLSBCYXNlZCBvbiAkZWwsIHRoZSBmaXJzdCBlbGVtZW50KHMpIGNvcnJlc3BvbmRpbmcgdG8gYGZvcm1FcnJvclNlbGVjdG9yYCBpbiB0aGlzIG9yZGVyOlxuICAgICAqICAgMS4gVGhlIGVsZW1lbnQncyBkaXJlY3Qgc2libGluZygncykuXG4gICAgICogICAyLiBUaGUgZWxlbWVudCdzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAqIC0gRWxlbWVudChzKSB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtkYXRhLWZvcm0tZXJyb3ItZm9yXWAgc2V0IHdpdGggdGhlIGVsZW1lbnQncyBpZC5cbiAgICAgKlxuICAgICAqIFRoaXMgYWxsb3dzIGZvciBtdWx0aXBsZSBmb3JtIGVycm9ycyBwZXIgaW5wdXQsIHRob3VnaCBpZiBub25lIGFyZSBmb3VuZCwgbm8gZm9ybSBlcnJvcnMgd2lsbCBiZSBzaG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyByZWZlcmVuY2UgdG8gZmluZCB0aGUgZm9ybSBlcnJvciBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbZmFpbGVkVmFsaWRhdG9yc10gLSBMaXN0IG9mIGZhaWxlZCB2YWxpZGF0b3JzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGpRdWVyeSBvYmplY3Qgd2l0aCB0aGUgc2VsZWN0b3IuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRm9ybUVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRGb3JtRXJyb3IoJGVsLCBmYWlsZWRWYWxpZGF0b3JzKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGlkID0gJGVsLmxlbmd0aCA/ICRlbFswXS5pZCA6ICcnO1xuICAgICAgdmFyICRlcnJvciA9ICRlbC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xuXG4gICAgICBpZiAoISRlcnJvci5sZW5ndGgpIHtcbiAgICAgICAgJGVycm9yID0gJGVsLnBhcmVudCgpLmZpbmQodGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgICRlcnJvciA9ICRlcnJvci5hZGQodGhpcy4kZWxlbWVudC5maW5kKFwiW2RhdGEtZm9ybS1lcnJvci1mb3I9XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXVwiKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISFmYWlsZWRWYWxpZGF0b3JzKSB7XG4gICAgICAgICRlcnJvciA9ICRlcnJvci5ub3QoJ1tkYXRhLWZvcm0tZXJyb3Itb25dJyk7XG4gICAgICAgIGZhaWxlZFZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICRlcnJvciA9ICRlcnJvci5hZGQoJGVsLnNpYmxpbmdzKFwiW2RhdGEtZm9ybS1lcnJvci1vbj1cXFwiXCIuY29uY2F0KHYsIFwiXFxcIl1cIikpKTtcbiAgICAgICAgICAkZXJyb3IgPSAkZXJyb3IuYWRkKF90aGlzNC4kZWxlbWVudC5maW5kKFwiW2RhdGEtZm9ybS1lcnJvci1mb3I9XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXVtkYXRhLWZvcm0tZXJyb3Itb249XFxcIlwiKS5jb25jYXQodiwgXCJcXFwiXVwiKSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICRlcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgb3JkZXI6XG4gICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZExhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRMYWJlbCgkZWwpIHtcbiAgICAgIHZhciBpZCA9ICRlbFswXS5pZDtcbiAgICAgIHZhciAkbGFiZWwgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJsYWJlbFtmb3I9XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXVwiKSk7XG5cbiAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJGVsLmNsb3Nlc3QoJ2xhYmVsJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkbGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2V0IG9mIGxhYmVscyBhc3NvY2lhdGVkIHdpdGggYSBzZXQgb2YgcmFkaW8gZWxzIGluIHRoaXMgb3JkZXJcbiAgICAgKiAyLiBUaGUgPGxhYmVsPiB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtmb3I9XCJzb21lSW5wdXRJZFwiXWBcbiAgICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUmFkaW9MYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFJhZGlvTGFiZWxzKCRlbHMpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgbGFiZWxzID0gJGVscy5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIHZhciBpZCA9IGVsLmlkO1xuXG4gICAgICAgIHZhciAkbGFiZWwgPSBfdGhpczUuJGVsZW1lbnQuZmluZChcImxhYmVsW2Zvcj1cXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJdXCIpKTtcblxuICAgICAgICBpZiAoISRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAkbGFiZWwgPSAkKGVsKS5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRsYWJlbFswXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICQobGFiZWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzZXQgb2YgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBhIHNldCBvZiBjaGVja2JveCBlbHMgaW4gdGhpcyBvcmRlclxuICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cInNvbWVJbnB1dElkXCJdYFxuICAgICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZpbmRDaGVja2JveExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQ2hlY2tib3hMYWJlbHMoJGVscykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBsYWJlbHMgPSAkZWxzLm1hcChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgdmFyIGlkID0gZWwuaWQ7XG5cbiAgICAgICAgdmFyICRsYWJlbCA9IF90aGlzNi4kZWxlbWVudC5maW5kKFwibGFiZWxbZm9yPVxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIl1cIikpO1xuXG4gICAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAgICRsYWJlbCA9ICQoZWwpLmNsb3Nlc3QoJ2xhYmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJGxhYmVsWzBdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gJChsYWJlbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyB0byB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGNsYXNzIHRvXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gW2ZhaWxlZFZhbGlkYXRvcnNdIC0gTGlzdCBvZiBmYWlsZWQgdmFsaWRhdG9ycy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFkZEVycm9yQ2xhc3Nlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFcnJvckNsYXNzZXMoJGVsLCBmYWlsZWRWYWxpZGF0b3JzKSB7XG4gICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcbiAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCwgZmFpbGVkVmFsaWRhdG9ycyk7XG5cbiAgICAgIGlmICgkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICRsYWJlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICRmb3JtRXJyb3IuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogJycsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBbZm9yXSBhbmQgW3JvbGU9YWxlcnRdIGF0dHJpYnV0ZXMgdG8gYWxsIGZvcm0gZXJyb3IgdGFyZ2V0dGluZyAkZWwsXG4gICAgICogYW5kIFthcmlhLWRlc2NyaWJlZGJ5XSBhdHRyaWJ1dGUgdG8gJGVsIHRvd2FyZCB0aGUgZmlyc3QgZm9ybSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQTExeUF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQTExeUF0dHJpYnV0ZXMoJGVsKSB7XG4gICAgICB2YXIgJGVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xuICAgICAgdmFyICRsYWJlbHMgPSAkZXJyb3JzLmZpbHRlcignbGFiZWwnKTtcbiAgICAgIHZhciAkZXJyb3IgPSAkZXJyb3JzLmZpcnN0KCk7XG4gICAgICBpZiAoISRlcnJvcnMubGVuZ3RoKSByZXR1cm47IC8vIFNldCBbYXJpYS1kZXNjcmliZWRieV0gb24gdGhlIGlucHV0IHRvd2FyZCB0aGUgZmlyc3QgZm9ybSBlcnJvciBpZiBpdCBpcyBub3Qgc2V0XG5cbiAgICAgIGlmICh0eXBlb2YgJGVsLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBmaXJzdCBlcnJvciBJRCBvciBjcmVhdGUgb25lXG4gICAgICAgIHZhciBlcnJvcklkID0gJGVycm9yLmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVycm9ySWQgPSBHZXRZb0RpZ2l0cyg2LCAnYWJpZGUtZXJyb3InKTtcbiAgICAgICAgICAkZXJyb3IuYXR0cignaWQnLCBlcnJvcklkKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JywgZXJyb3JJZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkbGFiZWxzLmZpbHRlcignW2Zvcl0nKS5sZW5ndGggPCAkbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAvLyBHZXQgdGhlIGlucHV0IElEIG9yIGNyZWF0ZSBvbmVcbiAgICAgICAgdmFyIGVsZW1JZCA9ICRlbC5hdHRyKCdpZCcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVsZW1JZCA9IEdldFlvRGlnaXRzKDYsICdhYmlkZS1pbnB1dCcpO1xuICAgICAgICAgICRlbC5hdHRyKCdpZCcsIGVsZW1JZCk7XG4gICAgICAgIH0gLy8gRm9yIGVhY2ggbGFiZWwgdGFyZ2V0aW5nICRlbCwgc2V0IFtmb3JdIGlmIGl0IGlzIG5vdCBzZXQuXG5cblxuICAgICAgICAkbGFiZWxzLmVhY2goZnVuY3Rpb24gKGksIGxhYmVsKSB7XG4gICAgICAgICAgdmFyICRsYWJlbCA9ICQobGFiZWwpO1xuICAgICAgICAgIGlmICh0eXBlb2YgJGxhYmVsLmF0dHIoJ2ZvcicpID09PSAndW5kZWZpbmVkJykgJGxhYmVsLmF0dHIoJ2ZvcicsIGVsZW1JZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgZWFjaCBlcnJvciB0YXJnZXRpbmcgJGVsLCBzZXQgW3JvbGU9YWxlcnRdIGlmIGl0IGlzIG5vdCBzZXQuXG5cblxuICAgICAgJGVycm9ycy5lYWNoKGZ1bmN0aW9uIChpLCBsYWJlbCkge1xuICAgICAgICB2YXIgJGxhYmVsID0gJChsYWJlbCk7XG4gICAgICAgIGlmICh0eXBlb2YgJGxhYmVsLmF0dHIoJ3JvbGUnKSA9PT0gJ3VuZGVmaW5lZCcpICRsYWJlbC5hdHRyKCdyb2xlJywgJ2FsZXJ0Jyk7XG4gICAgICB9KS5lbmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBbYXJpYS1saXZlXSBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIGdsb2JhbCBmb3JtIGVycm9yICRlbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGF0dHJpYnV0ZSB0b1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkR2xvYmFsRXJyb3JBMTF5QXR0cmlidXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzKCRlbCkge1xuICAgICAgaWYgKHR5cGVvZiAkZWwuYXR0cignYXJpYS1saXZlJykgPT09ICd1bmRlZmluZWQnKSAkZWwuYXR0cignYXJpYS1saXZlJywgdGhpcy5vcHRpb25zLmExMXlFcnJvckxldmVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIENTUyBlcnJvciBjbGFzc2VzIGV0YyBmcm9tIGFuIGVudGlyZSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlUmFkaW9FcnJvckNsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMoZ3JvdXBOYW1lKSB7XG4gICAgICB2YXIgJGVscyA9IHRoaXMuJGVsZW1lbnQuZmluZChcIjpyYWRpb1tuYW1lPVxcXCJcIi5jb25jYXQoZ3JvdXBOYW1lLCBcIlxcXCJdXCIpKTtcbiAgICAgIHZhciAkbGFiZWxzID0gdGhpcy5maW5kUmFkaW9MYWJlbHMoJGVscyk7XG4gICAgICB2YXIgJGZvcm1FcnJvcnMgPSB0aGlzLmZpbmRGb3JtRXJyb3IoJGVscyk7XG5cbiAgICAgIGlmICgkbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAkbGFiZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGZvcm1FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICRmb3JtRXJyb3JzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgICRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cih7XG4gICAgICAgICdkYXRhLWludmFsaWQnOiBudWxsLFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBDU1MgZXJyb3IgY2xhc3NlcyBldGMgZnJvbSBhbiBlbnRpcmUgY2hlY2tib3ggZ3JvdXBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSBjaGVja2JveCBncm91cFxuICAgICAqXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVDaGVja2JveEVycm9yQ2xhc3Nlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVDaGVja2JveEVycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcbiAgICAgIHZhciAkZWxzID0gdGhpcy4kZWxlbWVudC5maW5kKFwiOmNoZWNrYm94W25hbWU9XFxcIlwiLmNvbmNhdChncm91cE5hbWUsIFwiXFxcIl1cIikpO1xuICAgICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRDaGVja2JveExhYmVscygkZWxzKTtcbiAgICAgIHZhciAkZm9ybUVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWxzKTtcblxuICAgICAgaWYgKCRsYWJlbHMubGVuZ3RoKSB7XG4gICAgICAgICRsYWJlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkZm9ybUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgJGZvcm1FcnJvcnMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgJGVscy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5hdHRyKHtcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyBmcm9tIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRXJyb3JDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUVycm9yQ2xhc3NlcygkZWwpIHtcbiAgICAgIC8vIHJhZGlvcyBuZWVkIHRvIGNsZWFyIGFsbCBvZiB0aGUgZWxzXG4gICAgICBpZiAoJGVsWzBdLnR5cGUgPT0gJ3JhZGlvJykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVSYWRpb0Vycm9yQ2xhc3NlcygkZWwuYXR0cignbmFtZScpKTtcbiAgICAgIH0gLy8gY2hlY2tib3hlcyBuZWVkIHRvIGNsZWFyIGFsbCBvZiB0aGUgZWxzXG4gICAgICBlbHNlIGlmICgkZWxbMF0udHlwZSA9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ2hlY2tib3hFcnJvckNsYXNzZXMoJGVsLmF0dHIoJ25hbWUnKSk7XG4gICAgICAgIH1cblxuICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XG4gICAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xuXG4gICAgICBpZiAoJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAkbGFiZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkZm9ybUVycm9yLmxlbmd0aCkge1xuICAgICAgICAkZm9ybUVycm9yLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgICRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5hdHRyKHtcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR29lcyB0aHJvdWdoIGEgZm9ybSB0byBmaW5kIGlucHV0cyBhbmQgcHJvY2VlZHMgdG8gdmFsaWRhdGUgdGhlbSBpbiB3YXlzIHNwZWNpZmljIHRvIHRoZWlyIHR5cGUuXG4gICAgICogSWdub3JlcyBpbnB1dHMgd2l0aCBkYXRhLWFiaWRlLWlnbm9yZSwgdHlwZT1cImhpZGRlblwiIG9yIGRpc2FibGVkIGF0dHJpYnV0ZXMgc2V0XG4gICAgICogQGZpcmVzIEFiaWRlI2ludmFsaWRcbiAgICAgKiBAZmlyZXMgQWJpZGUjdmFsaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGdvb2RUb0dvIC0gSWYgdGhlIGlucHV0IGlzIHZhbGlkIG9yIG5vdC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlSW5wdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVJbnB1dCgkZWwpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xlYXJSZXF1aXJlID0gdGhpcy5yZXF1aXJlZENoZWNrKCRlbCksXG4gICAgICAgICAgdmFsaWRhdG9yID0gJGVsLmF0dHIoJ2RhdGEtdmFsaWRhdG9yJyksXG4gICAgICAgICAgZmFpbGVkVmFsaWRhdG9ycyA9IFtdLFxuICAgICAgICAgIG1hbmFnZUVycm9yQ2xhc3NlcyA9IHRydWU7IC8vIHNraXAgdmFsaWRhdGlvbiBpZiBkaXNhYmxlZFxuXG4gICAgICBpZiAodGhpcy5fdmFsaWRhdGlvbklzRGlzYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gZG9uJ3QgdmFsaWRhdGUgaWdub3JlZCBpbnB1dHMgb3IgaGlkZGVuIGlucHV0cyBvciBkaXNhYmxlZCBpbnB1dHNcblxuXG4gICAgICBpZiAoJGVsLmlzKCdbZGF0YS1hYmlkZS1pZ25vcmVdJykgfHwgJGVsLmlzKCdbdHlwZT1cImhpZGRlblwiXScpIHx8ICRlbC5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlUmFkaW8oJGVsLmF0dHIoJ25hbWUnKSkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdyZXF1aXJlZCcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2hlY2tib3goJGVsLmF0dHIoJ25hbWUnKSkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdyZXF1aXJlZCcpOyAvLyB2YWxpZGF0ZUNoZWNrYm94KCkgYWRkcy9yZW1vdmVzIGVycm9yIGNsYXNzZXNcblxuICAgICAgICAgIG1hbmFnZUVycm9yQ2xhc3NlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3NlbGVjdC1vbmUnOlxuICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgIGNsZWFyUmVxdWlyZSB8fCBmYWlsZWRWYWxpZGF0b3JzLnB1c2goJ3JlcXVpcmVkJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjbGVhclJlcXVpcmUgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdyZXF1aXJlZCcpO1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVUZXh0KCRlbCkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdwYXR0ZXJuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgdmFyIHJlcXVpcmVkID0gJGVsLmF0dHIoJ3JlcXVpcmVkJykgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHZhbGlkYXRvci5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBfdGhpczcub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKHYpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKCRlbCkgfHwgZmFpbGVkVmFsaWRhdG9ycy5wdXNoKCdlcXVhbFRvJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBnb29kVG9HbyA9IGZhaWxlZFZhbGlkYXRvcnMubGVuZ3RoID09PSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAoZ29vZFRvR28gPyAndmFsaWQnIDogJ2ludmFsaWQnKSArICcuemYuYWJpZGUnO1xuXG4gICAgICBpZiAoZ29vZFRvR28pIHtcbiAgICAgICAgLy8gUmUtdmFsaWRhdGUgaW5wdXRzIHRoYXQgZGVwZW5kIG9uIHRoaXMgb25lIHdpdGggZXF1YWx0b1xuICAgICAgICB2YXIgZGVwZW5kZW50RWxlbWVudHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCJbZGF0YS1lcXVhbHRvPVxcXCJcIi5jb25jYXQoJGVsLmF0dHIoJ2lkJyksIFwiXFxcIl1cIikpO1xuXG4gICAgICAgIGlmIChkZXBlbmRlbnRFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgZGVwZW5kZW50RWxlbWVudHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoJCh0aGlzKS52YWwoKSkge1xuICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZUlucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYW5hZ2VFcnJvckNsYXNzZXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoJGVsKTtcblxuICAgICAgICBpZiAoIWdvb2RUb0dvKSB7XG4gICAgICAgICAgdGhpcy5hZGRFcnJvckNsYXNzZXMoJGVsLCBmYWlsZWRWYWxpZGF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxuICAgICAgICogVHJpZ2dlciBpbmNsdWRlcyB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGlucHV0LlxuICAgICAgICogQGV2ZW50IEFiaWRlI3ZhbGlkXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxuICAgICAgICovXG5cblxuICAgICAgJGVsLnRyaWdnZXIobWVzc2FnZSwgWyRlbF0pO1xuICAgICAgcmV0dXJuIGdvb2RUb0dvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIGFuZCBpZiB0aGVyZSBhcmUgYW55IGludmFsaWQgaW5wdXRzLCBpdCB3aWxsIGRpc3BsYXkgdGhlIGZvcm0gZXJyb3IgZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxuICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtdmFsaWRcbiAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybWludmFsaWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlRm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgdmFyIGFjYyA9IFtdO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hlY2tib3hHcm91cE5hbWU7IC8vIFJlbWVtYmVyIGZpcnN0IGZvcm0gc3VibWlzc2lvbiB0byBwcmV2ZW50IHNwZWNpZmljIGNoZWNrYm94IHZhbGlkYXRpb24gKG1vcmUgdGhhbiBvbmUgcmVxdWlyZWQpIHVudGlsIGZvcm0gZ290IGluaXRpYWxseSBzdWJtaXR0ZWRcblxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfSAvLyBza2lwIHZhbGlkYXRpb24gaWYgZGlzYWJsZWRcblxuXG4gICAgICBpZiAodGhpcy5fdmFsaWRhdGlvbklzRGlzYWJsZWQoKSkge1xuICAgICAgICB0aGlzLmZvcm1ub3ZhbGlkYXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT25seSB1c2Ugb25lIGNoZWNrYm94IHBlciBncm91cCBzaW5jZSB2YWxpZGF0ZUNoZWNrYm94KCkgaXRlcmF0ZXMgb3ZlciBhbGwgYXNzb2NpYXRlZCBjaGVja2JveGVzXG4gICAgICAgIGlmICgkKHRoaXMpWzBdLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5hdHRyKCduYW1lJykgPT09IGNoZWNrYm94R3JvdXBOYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjaGVja2JveEdyb3VwTmFtZSA9ICQodGhpcykuYXR0cignbmFtZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWNjLnB1c2goX3RoaXMudmFsaWRhdGVJbnB1dCgkKHRoaXMpKSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBub0Vycm9yID0gYWNjLmluZGV4T2YoZmFsc2UpID09PSAtMTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuZWFjaChmdW5jdGlvbiAoaSwgZWxlbSkge1xuICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pOyAvLyBFbnN1cmUgYTExeSBhdHRyaWJ1dGVzIGFyZSBzZXRcblxuICAgICAgICBpZiAoX3RoaXM4Lm9wdGlvbnMuYTExeUF0dHJpYnV0ZXMpIF90aGlzOC5hZGRHbG9iYWxFcnJvckExMXlBdHRyaWJ1dGVzKCRlbGVtKTsgLy8gU2hvdyBvciBoaWRlIHRoZSBlcnJvclxuXG4gICAgICAgICRlbGVtLmNzcygnZGlzcGxheScsIG5vRXJyb3IgPyAnbm9uZScgOiAnYmxvY2snKTtcbiAgICAgIH0pO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGlzIGZpbmlzaGVkIHZhbGlkYXRpbmcuIEV2ZW50IHRyaWdnZXIgaXMgZWl0aGVyIGBmb3JtdmFsaWQuemYuYWJpZGVgIG9yIGBmb3JtaW52YWxpZC56Zi5hYmlkZWAuXG4gICAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBlbGVtZW50IG9mIHRoZSBmb3JtLlxuICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm12YWxpZFxuICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm1pbnZhbGlkXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKChub0Vycm9yID8gJ2Zvcm12YWxpZCcgOiAnZm9ybWludmFsaWQnKSArICcuemYuYWJpZGUnLCBbdGhpcy4kZWxlbWVudF0pO1xuICAgICAgcmV0dXJuIG5vRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHRleHQgaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gdGhlIHBhdHRlcm4gc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUuIElmIG5vIG1hdGNoaW5nIHBhdHRlcm4gaXMgZm91bmQsIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGEgdGV4dCBpbnB1dCBIVE1MIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0dGVybiAtIHN0cmluZyB2YWx1ZSBvZiBvbmUgb2YgdGhlIFJlZ0V4IHBhdHRlcm5zIGluIEFiaWRlLm9wdGlvbnMucGF0dGVybnNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCB2YWx1ZSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHNwZWNpZmllZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlVGV4dCgkZWwsIHBhdHRlcm4pIHtcbiAgICAgIC8vIEEgcGF0dGVybiBjYW4gYmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgYmUgaW5mZXJlZCBmcm9tIHRoZSBpbnB1dCdzIFwicGF0dGVyblwiIGF0dHJpYnV0ZSwgb3IgaXQncyBcInR5cGVcIiBhdHRyaWJ1dGVcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIHx8ICRlbC5hdHRyKCdkYXRhLXBhdHRlcm4nKSB8fCAkZWwuYXR0cigncGF0dGVybicpIHx8ICRlbC5hdHRyKCd0eXBlJyk7XG4gICAgICB2YXIgaW5wdXRUZXh0ID0gJGVsLnZhbCgpO1xuICAgICAgdmFyIHZhbGlkID0gdHJ1ZTtcblxuICAgICAgaWYgKGlucHV0VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGlzIGluIEFiaWRlJ3MgbGlzdCBvZiBwYXR0ZXJucywgdGhlbiB0ZXN0IHRoYXQgcmVnZXhwXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGF0dGVybnMuaGFzT3duUHJvcGVydHkocGF0dGVybikpIHtcbiAgICAgICAgICB2YWxpZCA9IHRoaXMub3B0aW9ucy5wYXR0ZXJuc1twYXR0ZXJuXS50ZXN0KGlucHV0VGV4dCk7XG4gICAgICAgIH0gLy8gSWYgdGhlIHBhdHRlcm4gbmFtZSBpc24ndCBhbHNvIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgZmllbGQsIHRoZW4gdGVzdCBpdCBhcyBhIHJlZ2V4cFxuICAgICAgICBlbHNlIGlmIChwYXR0ZXJuICE9PSAkZWwuYXR0cigndHlwZScpKSB7XG4gICAgICAgICAgICB2YWxpZCA9IG5ldyBSZWdFeHAocGF0dGVybikudGVzdChpbnB1dFRleHQpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3IgYSBub3QgYSByYWRpbyBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBpdCBpcyByZXF1aXJlZCBhbmQgc2VsZWN0ZWQuIEFsdGhvdWdoIHRoZSBmdW5jdGlvbiB0YXJnZXRzIGEgc2luZ2xlIGA8aW5wdXQ+YCwgaXQgdmFsaWRhdGVzIGJ5IGNoZWNraW5nIHRoZSBgcmVxdWlyZWRgIGFuZCBgY2hlY2tlZGAgcHJvcGVydGllcyBvZiBhbGwgcmFkaW8gYnV0dG9ucyBpbiBpdHMgZ3JvdXAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdCBsZWFzdCBvbmUgcmFkaW8gaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgKGlmIGl0J3MgcmVxdWlyZWQpXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVJhZGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlUmFkaW8oZ3JvdXBOYW1lKSB7XG4gICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXG4gICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcbiAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCI6cmFkaW9bbmFtZT1cXFwiXCIuY29uY2F0KGdyb3VwTmFtZSwgXCJcXFwiXVwiKSk7XG4gICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlOyAvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHJlcXVpcmVkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgcmVxdWlyZWRcblxuICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgaWYgKCQoZSkuYXR0cigncmVxdWlyZWQnKSkge1xuICAgICAgICAgIHJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlcXVpcmVkKSB2YWxpZCA9IHRydWU7XG5cbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcbiAgICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgICBpZiAoJChlKS5wcm9wKCdjaGVja2VkJykpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIGNoZWNrYm94IGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlcXVpcmVkIGFuZCBjaGVja2VkLiBBbHRob3VnaCB0aGUgZnVuY3Rpb24gdGFyZ2V0cyBhIHNpbmdsZSBgPGlucHV0PmAsIGl0IHZhbGlkYXRlcyBieSBjaGVja2luZyB0aGUgYHJlcXVpcmVkYCBhbmQgYGNoZWNrZWRgIHByb3BlcnRpZXMgb2YgYWxsIGNoZWNrYm94ZXMgaW4gaXRzIGdyb3VwLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIGNoZWNrYm94IGdyb3VwXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdCBsZWFzdCBvbmUgY2hlY2tib3ggaW5wdXQgaGFzIGJlZW4gY2hlY2tlZCAoaWYgaXQncyByZXF1aXJlZClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInZhbGlkYXRlQ2hlY2tib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVDaGVja2JveChncm91cE5hbWUpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgY2hlY2tib3ggaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXG4gICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCBjaGVja2JveGVzIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcbiAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCI6Y2hlY2tib3hbbmFtZT1cXFwiXCIuY29uY2F0KGdyb3VwTmFtZSwgXCJcXFwiXVwiKSk7XG4gICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlLFxuICAgICAgICAgIG1pblJlcXVpcmVkID0gMSxcbiAgICAgICAgICBjaGVja2VkID0gMDsgLy8gRm9yIHRoZSBncm91cCB0byBiZSByZXF1aXJlZCwgYXQgbGVhc3Qgb25lIGNoZWNrYm94IG5lZWRzIHRvIGJlIHJlcXVpcmVkXG5cbiAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgIGlmICgkKGUpLmF0dHIoJ3JlcXVpcmVkJykpIHtcbiAgICAgICAgICByZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXF1aXJlZCkgdmFsaWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIC8vIENvdW50IGNoZWNrZWQgY2hlY2tib3hlcyB3aXRoaW4gdGhlIGdyb3VwXG4gICAgICAgIC8vIFVzZSBkYXRhLW1pbi1yZXF1aXJlZCBpZiBhdmFpbGFibGUgKGRlZmF1bHQ6IDEpXG4gICAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgaWYgKCQoZSkucHJvcCgnY2hlY2tlZCcpKSB7XG4gICAgICAgICAgICBjaGVja2VkKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiAkKGUpLmF0dHIoJ2RhdGEtbWluLXJlcXVpcmVkJykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtaW5SZXF1aXJlZCA9IHBhcnNlSW50KCQoZSkuYXR0cignZGF0YS1taW4tcmVxdWlyZWQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgdGhlIG1pblJlcXVpcmVkIGFtb3VudCBvZiBjaGVja2JveGVzIGhhdmUgdG8gYmUgY2hlY2tlZFxuXG4gICAgICAgIGlmIChjaGVja2VkID49IG1pblJlcXVpcmVkKSB7XG4gICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFNraXAgdmFsaWRhdGlvbiBpZiBtb3JlIHRoYW4gMSBjaGVja2JveCBoYXZlIHRvIGJlIGNoZWNrZWQgQU5EIGlmIHRoZSBmb3JtIGhhc24ndCBnb3Qgc3VibWl0dGVkIHlldCAob3RoZXJ3aXNlIGl0IHdpbGwgYWxyZWFkeSBzaG93IGFuIGVycm9yIGR1cmluZyB0aGUgZmlyc3QgZmlsbCBpbilcblxuXG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCAhPT0gdHJ1ZSAmJiBtaW5SZXF1aXJlZCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIFJlZnJlc2ggZXJyb3IgY2xhc3MgZm9yIGFsbCBpbnB1dFxuXG5cbiAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICBfdGhpczkuYWRkRXJyb3JDbGFzc2VzKCQoZSksIFsncmVxdWlyZWQnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXM5LnJlbW92ZUVycm9yQ2xhc3NlcygkKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBzZWxlY3RlZCBpbnB1dCBwYXNzZXMgYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi4gTXVsdGlwbGUgdmFsaWRhdGlvbnMgY2FuIGJlIHVzZWQsIGlmIHBhc3NlZCB0byB0aGUgZWxlbWVudCB3aXRoIGBkYXRhLXZhbGlkYXRvcj1cImZvbyBiYXIgYmF6XCJgIGluIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3RlZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IGlucHV0IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSByZXF1aXJlZCAtIHNlbGYgZXhwbGFuYXRvcnk/XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZGF0aW9ucyBwYXNzZWQuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaFZhbGlkYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hWYWxpZGF0aW9uKCRlbCwgdmFsaWRhdG9ycywgcmVxdWlyZWQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgcmVxdWlyZWQgPSByZXF1aXJlZCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIHZhciBjbGVhciA9IHZhbGlkYXRvcnMuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMTAub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjbGVhci5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBmb3JtIGlucHV0cyBhbmQgc3R5bGVzXG4gICAgICogQGZpcmVzIEFiaWRlI2Zvcm1yZXNldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRGb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Rm9ybSgpIHtcbiAgICAgIHZhciAkZm9ybSA9IHRoaXMuJGVsZW1lbnQsXG4gICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICQoXCIuXCIuY29uY2F0KG9wdHMubGFiZWxFcnJvckNsYXNzKSwgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICAkKFwiLlwiLmNvbmNhdChvcHRzLmlucHV0RXJyb3JDbGFzcyksICRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5pbnB1dEVycm9yQ2xhc3MpO1xuICAgICAgJChcIlwiLmNvbmNhdChvcHRzLmZvcm1FcnJvclNlbGVjdG9yLCBcIi5cIikuY29uY2F0KG9wdHMuZm9ybUVycm9yQ2xhc3MpKS5yZW1vdmVDbGFzcyhvcHRzLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgICRmb3JtLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAkKCc6aW5wdXQnLCAkZm9ybSkubm90KCc6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4sIDpyYWRpbywgOmNoZWNrYm94LCBbZGF0YS1hYmlkZS1pZ25vcmVdJykudmFsKCcnKS5hdHRyKHtcbiAgICAgICAgJ2RhdGEtaW52YWxpZCc6IG51bGwsXG4gICAgICAgICdhcmlhLWludmFsaWQnOiBudWxsXG4gICAgICB9KTtcbiAgICAgICQoJzppbnB1dDpyYWRpbycsICRmb3JtKS5ub3QoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpLmF0dHIoe1xuICAgICAgICAnZGF0YS1pbnZhbGlkJzogbnVsbCxcbiAgICAgICAgJ2FyaWEtaW52YWxpZCc6IG51bGxcbiAgICAgIH0pO1xuICAgICAgJCgnOmlucHV0OmNoZWNrYm94JywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSkuYXR0cih7XG4gICAgICAgICdkYXRhLWludmFsaWQnOiBudWxsLFxuICAgICAgICAnYXJpYS1pbnZhbGlkJzogbnVsbFxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaGFzIGJlZW4gcmVzZXQuXG4gICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybXJlc2V0XG4gICAgICAgKi9cblxuICAgICAgJGZvcm0udHJpZ2dlcignZm9ybXJlc2V0LnpmLmFiaWRlJywgWyRmb3JtXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIEFiaWRlLlxuICAgICAqIFJlbW92ZXMgZXJyb3Igc3R5bGVzIGFuZCBjbGFzc2VzIGZyb20gZWxlbWVudHMsIHdpdGhvdXQgcmVzZXR0aW5nIHRoZWlyIHZhbHVlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5hYmlkZScpLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICB0aGlzLiRpbnB1dHMub2ZmKCcuYWJpZGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVtb3ZlRXJyb3JDbGFzc2VzKCQodGhpcykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLiRzdWJtaXRzLm9mZignLmFiaWRlJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFiaWRlO1xufShQbHVnaW4pO1xuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAqL1xuXG5cbkFiaWRlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZXZlbnQgdG8gdmFsaWRhdGUgaW5wdXRzLiBDaGVja2JveGVzIGFuZCByYWRpb3MgdmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAqIFJlbW92ZSBvciBjaGFuZ2UgdGhpcyB2YWx1ZSBmb3IgbWFudWFsIHZhbGlkYXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdmaWVsZENoYW5nZSdcbiAgICovXG4gIHZhbGlkYXRlT246ICdmaWVsZENoYW5nZScsXG5cbiAgLyoqXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXQgbGFiZWxzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWxhYmVsJ1xuICAgKi9cbiAgbGFiZWxFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1sYWJlbCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXRzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWlucHV0J1xuICAgKi9cbiAgaW5wdXRFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1pbnB1dCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIHNlbGVjdG9yIHRvIHVzZSB0byB0YXJnZXQgRm9ybSBFcnJvcnMgZm9yIHNob3cvaGlkZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnLmZvcm0tZXJyb3InXG4gICAqL1xuICBmb3JtRXJyb3JTZWxlY3RvcjogJy5mb3JtLWVycm9yJyxcblxuICAvKipcbiAgICogQ2xhc3MgYWRkZWQgdG8gRm9ybSBFcnJvcnMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2lzLXZpc2libGUnXG4gICAqL1xuICBmb3JtRXJyb3JDbGFzczogJ2lzLXZpc2libGUnLFxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBhdXRvbWF0aWNhbGx5IGluc2VydCB3aGVuIHBvc3NpYmxlOlxuICAgKiAtIGBbYXJpYS1kZXNjcmliZWRieV1gIG9uIGZpZWxkc1xuICAgKiAtIGBbcm9sZT1hbGVydF1gIG9uIGZvcm0gZXJyb3JzIGFuZCBgW2Zvcl1gIG9uIGZvcm0gZXJyb3IgbGFiZWxzXG4gICAqIC0gYFthcmlhLWxpdmVdYCBvbiBnbG9iYWwgZXJyb3JzIGBbZGF0YS1hYmlkZS1lcnJvcl1gIChzZWUgb3B0aW9uIGBhMTF5RXJyb3JMZXZlbGApLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhMTF5QXR0cmlidXRlczogdHJ1ZSxcblxuICAvKipcbiAgICogW2FyaWEtbGl2ZV0gYXR0cmlidXRlIHZhbHVlIHRvIGJlIGFwcGxpZWQgb24gZ2xvYmFsIGVycm9ycyBgW2RhdGEtYWJpZGUtZXJyb3JdYC5cbiAgICogT3B0aW9ucyBhcmU6ICdhc3NlcnRpdmUnLCAncG9saXRlJyBhbmQgJ29mZicvbnVsbFxuICAgKiBAb3B0aW9uXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQWNjZXNzaWJpbGl0eS9BUklBL0FSSUFfTGl2ZV9SZWdpb25zXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdhc3NlcnRpdmUnXG4gICAqL1xuICBhMTF5RXJyb3JMZXZlbDogJ2Fzc2VydGl2ZScsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIHRleHQgaW5wdXRzIG9uIGFueSB2YWx1ZSBjaGFuZ2UuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBsaXZlVmFsaWRhdGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSB0byB2YWxpZGF0ZSBpbnB1dHMgb24gYmx1ci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHZhbGlkYXRlT25CbHVyOiBmYWxzZSxcbiAgcGF0dGVybnM6IHtcbiAgICBhbHBoYTogL15bYS16QS1aXSskLyxcbiAgICBhbHBoYV9udW1lcmljOiAvXlthLXpBLVowLTldKyQvLFxuICAgIGludGVnZXI6IC9eWy0rXT9cXGQrJC8sXG4gICAgbnVtYmVyOiAvXlstK10/XFxkKig/OltcXC5cXCxdXFxkKyk/JC8sXG4gICAgLy8gYW1leCwgdmlzYSwgZGluZXJzXG4gICAgY2FyZDogL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18KD86MjIyWzEtOV18MlszLTZdWzAtOV17Mn18MjdbMC0xXVswLTldfDI3MjApWzAtOV17MTJ9fDYoPzowMTF8NVswLTldWzAtOV0pWzAtOV17MTJ9fDNbNDddWzAtOV17MTN9fDMoPzowWzAtNV18WzY4XVswLTldKVswLTldezExfXwoPzoyMTMxfDE4MDB8MzVcXGR7M30pXFxkezExfSkkLyxcbiAgICBjdnY6IC9eKFswLTldKXszLDR9JC8sXG4gICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvc3RhdGVzLW9mLXRoZS10eXBlLWF0dHJpYnV0ZS5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG4gICAgZW1haWw6IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyQvLFxuICAgIC8vIEZyb20gQ29tbW9uUmVnZXhKUyAoQHRhbHlzc29ub2MpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RhbHlzc29ub2MvQ29tbW9uUmVnZXhKUy9ibG9iL2UyOTAxYjlmNTcyMjJiYzE0MDY5ZGM4ZjA1OThkNWY0MTI1NTU0MTEvbGliL2NvbW1vbnJlZ2V4LmpzI0w3NlxuICAgIC8vIEZvciBtb3JlIHJlc3RyaWN0aXZlIFVSTCBSZWdleHMsIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXguXG4gICAgdXJsOiAvXigoPzooaHR0cHM/fGZ0cHM/fGZpbGV8c3NofHNmdHApOlxcL1xcL3x3d3dcXGR7MCwzfVsuXXxbYS16MC05LlxcLV0rWy5dW2Etel17Miw0fVxcLykoPzpbXlxccygpPD5dK3xcXCgoPzpbXlxccygpPD5dK3woPzpcXChbXlxccygpPD5dK1xcKSkpKlxcKSkrKD86XFwoKD86W15cXHMoKTw+XSt8KD86XFwoW15cXHMoKTw+XStcXCkpKSpcXCl8W15cXHNgISgpXFxbXFxde307OlxcJ1wiLiw8Pj9cXHhhYlxceGJiXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOV0pKSQvLFxuICAgIC8vIGFiYy5kZVxuICAgIGRvbWFpbjogL14oW2EtekEtWjAtOV0oW2EtekEtWjAtOVxcLV17MCw2MX1bYS16QS1aMC05XSk/XFwuKStbYS16QS1aXXsyLDh9JC8sXG4gICAgZGF0ZXRpbWU6IC9eKFswLTJdWzAtOV17M30pXFwtKFswLTFdWzAtOV0pXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcOihbMC01XVswLTldKVxcOihbMC01XVswLTldKShafChbXFwtXFwrXShbMC0xXVswLTldKVxcOjAwKSkkLyxcbiAgICAvLyBZWVlZLU1NLUREXG4gICAgZGF0ZTogLyg/OjE5fDIwKVswLTldezJ9LSg/Oig/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXwxWzAtOV18MlswLTldKXwoPzooPyEwMikoPzowWzEtOV18MVswLTJdKS0oPzozMCkpfCg/Oig/OjBbMTM1NzhdfDFbMDJdKS0zMSkpJC8sXG4gICAgLy8gSEg6TU06U1NcbiAgICB0aW1lOiAvXigwWzAtOV18MVswLTldfDJbMC0zXSkoOlswLTVdWzAtOV0pezJ9JC8sXG4gICAgZGF0ZUlTTzogL15cXGR7NH1bXFwvXFwtXVxcZHsxLDJ9W1xcL1xcLV1cXGR7MSwyfSQvLFxuICAgIC8vIE1NL0REL1lZWVlcbiAgICBtb250aF9kYXlfeWVhcjogL14oMFsxLTldfDFbMDEyXSlbLSBcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dXFxkezR9JC8sXG4gICAgLy8gREQvTU0vWVlZWVxuICAgIGRheV9tb250aF95ZWFyOiAvXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFwvLl1cXGR7NH0kLyxcbiAgICAvLyAjRkZGIG9yICNGRkZGRkZcbiAgICBjb2xvcjogL14jPyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkkLyxcbiAgICAvLyBEb21haW4gfHwgVVJMXG4gICAgd2Vic2l0ZToge1xuICAgICAgdGVzdDogZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBBYmlkZS5kZWZhdWx0cy5wYXR0ZXJuc1snZG9tYWluJ10udGVzdCh0ZXh0KSB8fCBBYmlkZS5kZWZhdWx0cy5wYXR0ZXJuc1sndXJsJ10udGVzdCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIHZhbGlkYXRpb24gZnVuY3Rpb25zIHRvIGJlIHVzZWQuIGBlcXVhbFRvYCBiZWluZyB0aGUgb25seSBkZWZhdWx0IGluY2x1ZGVkIGZ1bmN0aW9uLlxuICAgKiBGdW5jdGlvbnMgc2hvdWxkIHJldHVybiBvbmx5IGEgYm9vbGVhbiBpZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LiBGdW5jdGlvbnMgYXJlIGdpdmVuIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgKiBlbCA6IFRoZSBqUXVlcnkgZWxlbWVudCB0byB2YWxpZGF0ZS5cbiAgICogcmVxdWlyZWQgOiBCb29sZWFuIHZhbHVlIG9mIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYmUgcHJlc2VudCBvciBub3QuXG4gICAqIHBhcmVudCA6IFRoZSBkaXJlY3QgcGFyZW50IG9mIHRoZSBpbnB1dC5cbiAgICogQG9wdGlvblxuICAgKi9cbiAgdmFsaWRhdG9yczoge1xuICAgIGVxdWFsVG86IGZ1bmN0aW9uIGVxdWFsVG8oZWwsIHJlcXVpcmVkLCBwYXJlbnQpIHtcbiAgICAgIHJldHVybiAkKFwiI1wiLmNvbmNhdChlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkpLnZhbCgpID09PSBlbC52YWwoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWNjb3JkaW9uIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqL1xuXG52YXIgQWNjb3JkaW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhBY2NvcmRpb24sIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIEFjY29yZGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWNjb3JkaW9uKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQWNjb3JkaW9uKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBY2NvcmRpb24sIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgQWNjb3JkaW9uXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhIHBsYWluIG9iamVjdCB3aXRoIHNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0FjY29yZGlvbic7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEtleWJvYXJkLnJlZ2lzdGVyKCdBY2NvcmRpb24nLCB7XG4gICAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cydcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IHRydWU7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3JvbGUnLCAndGFibGlzdCcpO1xuICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLWFjY29yZGlvbi1pdGVtXScpO1xuICAgICAgdGhpcy4kdGFicy5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAncHJlc2VudGF0aW9uJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgICAgICAgdmFyICRlbCA9ICQoZWwpLFxuICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxuICAgICAgICAgICAgaWQgPSAkY29udGVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnYWNjb3JkaW9uJyksXG4gICAgICAgICAgICBsaW5rSWQgPSBlbC5pZCA/IFwiXCIuY29uY2F0KGVsLmlkLCBcIi1sYWJlbFwiKSA6IFwiXCIuY29uY2F0KGlkLCBcIi1sYWJlbFwiKTtcbiAgICAgICAgJGVsLmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKHtcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICAgJ2lkJzogbGlua0lkLFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgJGNvbnRlbnQuYXR0cih7XG4gICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyICRpbml0QWN0aXZlID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGluaXRBY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIC8vIFNhdmUgdXAgdGhlIGluaXRpYWwgaGFzaCB0byByZXR1cm4gdG8gaXQgbGF0ZXIgd2hlbiBnb2luZyBiYWNrIGluIGhpc3RvcnlcbiAgICAgICAgdGhpcy5faW5pdGlhbEFuY2hvciA9ICRpbml0QWN0aXZlLnByZXYoJ2EnKS5hdHRyKCdocmVmJyk7XG5cbiAgICAgICAgdGhpcy5fb3BlblNpbmdsZVRhYigkaW5pdEFjdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcblxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgaW5pdGlhbGl6aW5nIGFuZCB0aGVyZSBpcyBubyBhbmNob3IsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICAgIGlmIChfdGhpczIuX2lzSW5pdGlhbGl6aW5nKSByZXR1cm47IC8vIE90aGVyd2lzZSwgbW92ZSB0byB0aGUgaW5pdGlhbCBhbmNob3JcblxuICAgICAgICAgIGlmIChfdGhpczIuX2luaXRpYWxBbmNob3IpIGFuY2hvciA9IF90aGlzMi5faW5pdGlhbEFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkYW5jaG9yID0gYW5jaG9yICYmICQoYW5jaG9yKTtcblxuICAgICAgICB2YXIgJGxpbmsgPSBhbmNob3IgJiYgX3RoaXMyLiRlbGVtZW50LmZpbmQoXCJbaHJlZiQ9XFxcIlwiLmNvbmNhdChhbmNob3IsIFwiXFxcIl1cIikpOyAvLyBXaGV0aGVyIHRoZSBhbmNob3IgZWxlbWVudCB0aGF0IGhhcyBiZWVuIGZvdW5kIGlzIHBhcnQgb2YgdGhpcyBlbGVtZW50XG5cblxuICAgICAgICB2YXIgaXNPd25BbmNob3IgPSAhISgkYW5jaG9yLmxlbmd0aCAmJiAkbGluay5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChpc093bkFuY2hvcikge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFuY2hvciBmb3IgdGhlIGhhc2gsIG9wZW4gaXQgKGlmIG5vdCBhbHJlYWR5IGFjdGl2ZSlcbiAgICAgICAgICBpZiAoJGFuY2hvciAmJiAkbGluayAmJiAkbGluay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghJGxpbmsucGFyZW50KCdbZGF0YS1hY2NvcmRpb24taXRlbV0nKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLl9vcGVuU2luZ2xlVGFiKCRhbmNob3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlLCBjbG9zZSBldmVyeXRoaW5nXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fY2xvc2VBbGxUYWJzKCk7XG4gICAgICAgICAgICB9IC8vIFJvbGwgdXAgYSBsaXR0bGUgdG8gc2hvdyB0aGUgdGl0bGVzXG5cblxuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZSkge1xuICAgICAgICAgICAgb25Mb2FkKCQod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IG9mZnNldC50b3AgLSBfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZU9mZnNldFxuICAgICAgICAgICAgICB9LCBfdGhpczIub3B0aW9ucy5kZWVwTGlua1NtdWRnZURlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGRlZXBsaW5rZWQgYXQgcGFnZWxvYWRcbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI2RlZXBsaW5rXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi5hY2NvcmRpb24nLCBbJGxpbmssICRhbmNob3JdKTtcbiAgICAgICAgfVxuICAgICAgfTsgLy91c2UgYnJvd3NlciB0byBvcGVuIGEgdGFiLCBpZiBpdCBleGlzdHMgaW4gdGhpcyB0YWJzZXRcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICAgIHRoaXMuX2lzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgYWNjb3JkaW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpO1xuICAgICAgICB2YXIgJHRhYkNvbnRlbnQgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XG5cbiAgICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICRlbGVtLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb24ga2V5ZG93bi56Zi5hY2NvcmRpb24nKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCR0YWJDb250ZW50KTtcbiAgICAgICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdBY2NvcmRpb24nLCB7XG4gICAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ubmV4dCgpLmZpbmQoJ2EnKS5mb2N1cygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5wcmV2KCkuZmluZCgnYScpLmZvY3VzKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICRhLnRyaWdnZXIoJ2NsaWNrLnpmLmFjY29yZGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb2YgdGhlIHBhbmUgdG8gdG9nZ2xlIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcbiAgICAgIGlmICgkdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWFjY29yZGlvbl0nKS5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IHRvZ2dsZSBhbiBhY2NvcmRpb24gdGhhdCBpcyBkaXNhYmxlZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcbiAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcbiAgICAgIH0gLy9laXRoZXIgcmVwbGFjZSBvciB1cGRhdGUgYnJvd3NlciBoaXN0b3J5XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICB2YXIgYW5jaG9yID0gJHRhcmdldC5wcmV2KCdhJykuYXR0cignaHJlZicpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xuICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgYW5jaG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gcGFuZSB0byBvcGVuIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd24oJHRhcmdldCkge1xuICAgICAgaWYgKCR0YXJnZXQuY2xvc2VzdCgnW2RhdGEtYWNjb3JkaW9uXScpLmlzKCdbZGlzYWJsZWRdJykpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDYW5ub3QgY2FsbCBkb3duIG9uIGFuIGFjY29yZGlvbiB0aGF0IGlzIGRpc2FibGVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHRoaXMuX29wZW5UYWIoJHRhcmdldCk7ZWxzZSB0aGlzLl9vcGVuU2luZ2xlVGFiKCR0YXJnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBJdCBtYXkgYmUgaWdub3JlZCBpZiB0aGUgQWNjb3JkaW9uIG9wdGlvbnMgZG9uJ3QgYWxsb3cgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cCgkdGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5pcygnW2Rpc2FibGVkXScpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ2Fubm90IGNhbGwgdXAgb24gYW4gYWNjb3JkaW9uIHRoYXQgaXMgZGlzYWJsZWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBjbG9zZWRcblxuXG4gICAgICB2YXIgJHRhcmdldEl0ZW0gPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgaWYgKCEkdGFyZ2V0SXRlbS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjsgLy8gRG9uJ3QgY2xvc2UgdGhlIGl0ZW0gaWYgdGhlcmUgaXMgbm8gb3RoZXIgYWN0aXZlIGl0ZW0gKHVubGVzcyB3aXRoIGBhbGxvd0FsbENsb3NlZGApXG5cbiAgICAgIHZhciAkb3RoZXJzSXRlbXMgPSAkdGFyZ2V0SXRlbS5zaWJsaW5ncygpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgJiYgISRvdGhlcnNJdGVtcy5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VUYWIoJHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YCB0aGUgb25seSBvcGVuZWQgdGFiLCBjbG9zaW5nIGFsbCBvdGhlcnMgdGFicy5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblNpbmdsZVRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblNpbmdsZVRhYigkdGFyZ2V0KSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG90aGVycyBhY3RpdmUgdGFicy5cbiAgICAgIHZhciAkYWN0aXZlQ29udGVudHMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGFjdGl2ZUNvbnRlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9jbG9zZVRhYigkYWN0aXZlQ29udGVudHMubm90KCR0YXJnZXQpKTtcbiAgICAgIH0gLy8gVGhlbiBvcGVuIHRoZSB0YXJnZXQuXG5cblxuICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gb3BlbiAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZG93blxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgIHZhciB0YXJnZXRDb250ZW50SWQgPSAkdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcbiAgICAgICR0YXJnZXRJdGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICQoXCIjXCIuY29uY2F0KHRhcmdldENvbnRlbnRJZCkpLmF0dHIoe1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAkdGFyZ2V0LmZpbmlzaCgpLnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkb3duXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczMuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZSAoYC5hY2NvcmRpb24tY29udGVudGApLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nsb3NlVGFiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZVRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyICR0YXJnZXRJdGVtID0gJHRhcmdldC5wYXJlbnQoKTtcbiAgICAgIHZhciB0YXJnZXRDb250ZW50SWQgPSAkdGFyZ2V0LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScpO1xuICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgJHRhcmdldEl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgJChcIiNcIi5jb25jYXQodGFyZ2V0Q29udGVudElkKSkuYXR0cih7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgJHRhcmdldC5maW5pc2goKS5zbGlkZVVwKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0YWIgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI3VwXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpczQuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uJywgWyR0YXJnZXRdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGFjdGl2ZSB0YWJzXG4gICAgICogQGZpcmVzIEFjY29yZGlvbiN1cFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2xvc2VBbGxUYWJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZUFsbFRhYnMoKSB7XG4gICAgICB2YXIgJGFjdGl2ZVRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO1xuXG4gICAgICBpZiAoJGFjdGl2ZVRhYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlVGFiKCRhY3RpdmVUYWJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdGFiLWNvbnRlbnRdJykuc3RvcCh0cnVlKS5zbGlkZVVwKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWNjb3JkaW9uO1xufShQbHVnaW4pO1xuXG5BY2NvcmRpb24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGFuIGFjY29yZGlvbiBwYW5lLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuXG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG11bHRpRXhwYW5kOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0FsbENsb3NlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIG9wZW4gcGFuZS5cbiAgICogU2V0IHRoZSBsb2NhdGlvbiBoYXNoIHdoZW4gdGhlIG9wZW5lZCBwYW5lIGNoYW5nZXMsIGFuZCBvcGVuIGFuZCBzY3JvbGwgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcGFuZSB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVlcExpbms6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIGFkanVzdCB0aGUgZGVlcCBsaW5rIHNjcm9sbCB0byBtYWtlIHN1cmUgdGhlIHRvcCBvZiB0aGUgYWNjb3JkaW9uIHBhbmVsIGlzIHZpc2libGVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCBhbmltYXRpb24gdGltZSAobXMpIGZvciB0aGUgZGVlcCBsaW5rIGFkanVzdG1lbnRcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzMDBcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCB0aGUgb2Zmc2V0IGZvciBzY3JvbGxUb1R0b3AgdG8gcHJldmVudCBvdmVybGFwIGJ5IGEgc3RpY2t5IGVsZW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgcGFnZVxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlT2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIHVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gYWNjb3JkaW9uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB1cGRhdGVIaXN0b3J5OiBmYWxzZVxufTtcblxuLyoqXG4gKiBBY2NvcmRpb25NZW51IG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25NZW51XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqL1xuXG52YXIgQWNjb3JkaW9uTWVudSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoQWNjb3JkaW9uTWVudSwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gQWNjb3JkaW9uTWVudSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWNjb3JkaW9uTWVudSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFjY29yZGlvbk1lbnUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbk1lbnUsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24gbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBBY2NvcmRpb25NZW51XG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQWNjb3JkaW9uTWVudSc7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEtleWJvYXJkLnJlZ2lzdGVyKCdBY2NvcmRpb25NZW51Jywge1xuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICdvcGVuJyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ2Nsb3NlJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZUFsbCdcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIG1lbnUgYnkgaGlkaW5nIGFsbCBuZXN0ZWQgbWVudXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLm5vdCgnLmlzLWFjdGl2ZScpLnNsaWRlVXAoMCk7IC8vLmZpbmQoJ2EnKS5jc3MoJ3BhZGRpbmctbGVmdCcsICcxcmVtJyk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ3RyZWUnLFxuICAgICAgICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJG1lbnVMaW5rcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpO1xuICAgICAgdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlua0lkID0gdGhpcy5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnYWNjLW1lbnUtbGluaycpLFxuICAgICAgICAgICAgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgJHN1YiA9ICRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLFxuICAgICAgICAgICAgc3ViSWQgPSAkc3ViWzBdLmlkIHx8IEdldFlvRGlnaXRzKDYsICdhY2MtbWVudScpLFxuICAgICAgICAgICAgaXNBY3RpdmUgPSAkc3ViLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XG4gICAgICAgICAgdmFyICRhbmNob3IgPSAkZWxlbS5jaGlsZHJlbignYScpO1xuICAgICAgICAgICRhbmNob3IuY2xvbmUoKS5wcmVwZW5kVG8oJHN1Yikud3JhcCgnPGxpIGRhdGEtaXMtcGFyZW50LWxpbmsgY2xhc3M9XCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1hY2NvcmRpb24tc3VibWVudS1pdGVtXCI+PC9saT4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGUpIHtcbiAgICAgICAgICAkZWxlbS5hZGRDbGFzcygnaGFzLXN1Ym1lbnUtdG9nZ2xlJyk7XG4gICAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ2EnKS5hZnRlcignPGJ1dHRvbiBpZD1cIicgKyBsaW5rSWQgKyAnXCIgY2xhc3M9XCJzdWJtZW51LXRvZ2dsZVwiIGFyaWEtY29udHJvbHM9XCInICsgc3ViSWQgKyAnXCIgYXJpYS1leHBhbmRlZD1cIicgKyBpc0FjdGl2ZSArICdcIiB0aXRsZT1cIicgKyBfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGVUZXh0ICsgJ1wiPjxzcGFuIGNsYXNzPVwic3VibWVudS10b2dnbGUtdGV4dFwiPicgKyBfdGhpcy5vcHRpb25zLnN1Ym1lbnVUb2dnbGVUZXh0ICsgJzwvc3Bhbj48L2J1dHRvbj4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbS5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogc3ViSWQsXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGlzQWN0aXZlLFxuICAgICAgICAgICAgJ2lkJzogbGlua0lkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkc3ViLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogIWlzQWN0aXZlLFxuICAgICAgICAgICdyb2xlJzogJ2dyb3VwJyxcbiAgICAgICAgICAnaWQnOiBzdWJJZFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0cmVlaXRlbSdcbiAgICAgIH0pO1xuICAgICAgdmFyIGluaXRQYW5lcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpO1xuXG4gICAgICBpZiAoaW5pdFBhbmVzLmxlbmd0aCkge1xuICAgICAgICBpbml0UGFuZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZG93bigkKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIG1lbnUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRzdWJtZW51ID0gJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcblxuICAgICAgICBpZiAoJHN1Ym1lbnUubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAgICAgJCh0aGlzKS5jaGlsZHJlbignLnN1Ym1lbnUtdG9nZ2xlJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKS5vbignY2xpY2suemYuYWNjb3JkaW9uTWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudCxcbiAgICAgICAgICAgICR0YXJnZXQgPSAkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV06dmlzaWJsZScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpIHtcbiAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkcHJldkVsZW1lbnQucGFyZW50cygnbGknKS5maW5kKCdsaTpsYXN0LWNoaWxkJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCc6bGFzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgICAgIC8vIGlzIGxhc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkubmV4dCgnbGknKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uTWVudScsIHtcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgICBfdGhpcy5kb3duKCR0YXJnZXQpO1xuXG4gICAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgICAvLyBjbG9zZSBhY3RpdmUgc3ViIG9mIHRoaXMgaXRlbVxuICAgICAgICAgICAgICBfdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcbiAgICAgICAgICAgICAgX3RoaXMudXAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpKTtcblxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwOiBmdW5jdGlvbiB1cCgpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb3duOiBmdW5jdGlvbiBkb3duKCkge1xuICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlQWxsOiBmdW5jdGlvbiBjbG9zZUFsbCgpIHtcbiAgICAgICAgICAgIF90aGlzLmhpZGVBbGwoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLy5hdHRyKCd0YWJpbmRleCcsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZUFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQWxsKCkge1xuICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbGwgcGFuZXMgb2YgdGhlIG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzaG93QWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dBbGwoKSB7XG4gICAgICB0aGlzLmRvd24odGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZSBzdGF0ZSBvZiBhIHN1Ym1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSB0aGUgc3VibWVudSB0byB0b2dnbGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xuICAgICAgaWYgKCEkdGFyZ2V0LmlzKCc6YW5pbWF0ZWQnKSkge1xuICAgICAgICBpZiAoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgIHRoaXMudXAoJHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzdWItbWVudSBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIG9wZW4uXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZG93blxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBJZiBoYXZpbmcgbXVsdGlwbGUgc3VibWVudXMgYWN0aXZlIGlzIGRpc2FibGVkLCBjbG9zZSBhbGwgdGhlIHN1Ym1lbnVzXG4gICAgICAvLyB0aGF0IGFyZSBub3QgcGFyZW50cyBvciBjaGlsZHJlbiBvZiB0aGUgdGFyZ2V0ZWQgc3VibWVudS5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpT3Blbikge1xuICAgICAgICAvLyBUaGUgXCJicmFuY2hcIiBvZiB0aGUgdGFyZ2V0dGVkIHN1Ym1lbnUsIGZyb20gdGhlIGNvbXBvbmVudCByb290IHRvXG4gICAgICAgIC8vIHRoZSBhY3RpdmUgc3VibWVudXMgbmVzdGVkIGluIGl0LlxuICAgICAgICB2YXIgJHRhcmdldEJyYW5jaCA9ICR0YXJnZXQucGFyZW50c1VudGlsKHRoaXMuJGVsZW1lbnQpLmFkZCgkdGFyZ2V0KS5hZGQoJHRhcmdldC5maW5kKCcuaXMtYWN0aXZlJykpOyAvLyBBbGwgdGhlIGFjdGl2ZSBzdWJtZW51cyB0aGF0IGFyZSBub3QgaW4gdGhlIGJyYW5jaC5cblxuICAgICAgICB2YXIgJG90aGVyc0FjdGl2ZVN1Ym1lbnVzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykubm90KCR0YXJnZXRCcmFuY2gpO1xuICAgICAgICB0aGlzLnVwKCRvdGhlcnNBY3RpdmVTdWJtZW51cyk7XG4gICAgICB9XG5cbiAgICAgICR0YXJnZXQuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoe1xuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAkdGFyZ2V0LnByZXYoJy5zdWJtZW51LXRvZ2dsZScpLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR0YXJnZXQucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0LnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXG4gICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I2Rvd25cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I3VwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cCgkdGFyZ2V0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyICRzdWJtZW51cyA9ICR0YXJnZXQuZmluZCgnW2RhdGEtc3VibWVudV0nKTtcbiAgICAgIHZhciAkYWxsbWVudXMgPSAkdGFyZ2V0LmFkZCgkc3VibWVudXMpO1xuICAgICAgJHN1Ym1lbnVzLnNsaWRlVXAoMCk7XG4gICAgICAkYWxsbWVudXMucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VibWVudVRvZ2dsZSkge1xuICAgICAgICAkYWxsbWVudXMucHJldignLnN1Ym1lbnUtdG9nZ2xlJykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhbGxtZW51cy5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAkdGFyZ2V0LnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rlc3Ryb3llZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVEb3duKDApLmNzcygnZGlzcGxheScsICcnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1pcy1wYXJlbnQtbGlua10nKS5kZXRhY2goKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJtZW51VG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnLmhhcy1zdWJtZW51LXRvZ2dsZScpLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudS10b2dnbGUnKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCcuc3VibWVudS10b2dnbGUnKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQWNjb3JkaW9uTWVudTtcbn0oUGx1Z2luKTtcblxuQWNjb3JkaW9uTWVudS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcGFyZW50TGluazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDI1MFxuICAgKi9cbiAgc2xpZGVTcGVlZDogMjUwLFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc2VwYXJhdGUgc3VibWVudSB0b2dnbGUgYnV0dG9uLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IGl0ZW0gdG8gaGF2ZSBhIGxpbmsuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgc3VibWVudVRvZ2dsZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFRoZSB0ZXh0IHVzZWQgZm9yIHRoZSBzdWJtZW51IHRvZ2dsZSBpZiBlbmFibGVkLiBUaGlzIGlzIHVzZWQgZm9yIHNjcmVlbiByZWFkZXJzIG9ubHkuXG4gICAqIEBvcHRpb25cbiAgICogQGV4YW1wbGUgdHJ1ZVxuICAgKi9cbiAgc3VibWVudVRvZ2dsZVRleHQ6ICdUb2dnbGUgbWVudScsXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBtZW51IHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgbXVsdGlPcGVuOiB0cnVlXG59O1xuXG4vKipcbiAqIERyaWxsZG93biBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKi9cblxudmFyIERyaWxsZG93biA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoRHJpbGxkb3duLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBEcmlsbGRvd24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyaWxsZG93bik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKERyaWxsZG93bikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRHJpbGxkb3duLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBEcmlsbGRvd25cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyaWxsZG93bi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnRHJpbGxkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicsIHtcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAgICdUQUInOiAnZG93bicsXG4gICAgICAgICdTSElGVF9UQUInOiAndXAnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBOZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgJ2RyaWxsZG93bicpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9BcHBseUNsYXNzKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2RyaWxsZG93bicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0cmVlJyxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCdhJyk7XG4gICAgICB0aGlzLiRzdWJtZW51cyA9IHRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudCgnbGknKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hdHRyKCdyb2xlJywgJ2dyb3VwJyk7XG4gICAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykubm90KCcuanMtZHJpbGxkb3duLWJhY2snKS5hdHRyKCdyb2xlJywgJ3RyZWVpdGVtJykuZmluZCgnYScpOyAvLyBTZXQgdGhlIG1haW4gbWVudSBhcyBjdXJyZW50IGJ5IGRlZmF1bHQgKHVubGVzcyBhIHN1Ym1lbnUgaXMgc2VsZWN0ZWQpXG4gICAgICAvLyBVc2VkIHRvIHNldCB0aGUgd3JhcHBlciBoZWlnaHQgd2hlbiB0aGUgZHJpbGxkb3duIGlzIGNsb3NlZC9yZW9wZW5lZCBmcm9tIGFueSAoc3ViKW1lbnVcblxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSB0aGlzLiRlbGVtZW50O1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1kcmlsbGRvd24nKSB8fCBHZXRZb0RpZ2l0cyg2LCAnZHJpbGxkb3duJykpO1xuXG4gICAgICB0aGlzLl9wcmVwYXJlTWVudSgpO1xuXG4gICAgICB0aGlzLl9yZWdpc3RlckV2ZW50cygpO1xuXG4gICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXG4gICAgICogc2V0cyBhIG1pbiBoZWlnaHQgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmdcbiAgICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wcmVwYXJlTWVudVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZU1lbnUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBpZighdGhpcy5vcHRpb25zLmhvbGRPcGVuKXtcbiAgICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcbiAgICAgIC8vIH1cblxuXG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgdmFyICRzdWIgPSAkbGluay5wYXJlbnQoKTtcblxuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XG4gICAgICAgICAgJGxpbmsuY2xvbmUoKS5wcmVwZW5kVG8oJHN1Yi5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSkud3JhcCgnPGxpIGRhdGEtaXMtcGFyZW50LWxpbmsgY2xhc3M9XCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXCIgcm9sZT1cIm5vbmVcIj48L2xpPicpO1xuICAgICAgICB9XG5cbiAgICAgICAgJGxpbmsuZGF0YSgnc2F2ZWRIcmVmJywgJGxpbmsuYXR0cignaHJlZicpKS5yZW1vdmVBdHRyKCdocmVmJykuYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgJGxpbmsuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAndGFiaW5kZXgnOiAwLFxuICAgICAgICAgICdyb2xlJzogJ2dyb3VwJ1xuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5fZXZlbnRzKCRsaW5rKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kc3VibWVudXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkbWVudSA9ICQodGhpcyksXG4gICAgICAgICAgICAkYmFjayA9ICRtZW51LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaycpO1xuXG4gICAgICAgIGlmICghJGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgc3dpdGNoIChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b25Qb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAkbWVudS5hcHBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgJG1lbnUucHJlcGVuZChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b24pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVuc3VwcG9ydGVkIGJhY2tCdXR0b25Qb3NpdGlvbiB2YWx1ZSAnXCIgKyBfdGhpcy5vcHRpb25zLmJhY2tCdXR0b25Qb3NpdGlvbiArIFwiJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fYmFjaygkbWVudSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdpbnZpc2libGUnKTtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICB0aGlzLiRzdWJtZW51cy5hZGRDbGFzcygnZHJpbGxkb3duLXN1Ym1lbnUtY292ZXItcHJldmlvdXMnKTtcbiAgICAgIH0gLy8gY3JlYXRlIGEgd3JhcHBlciBvbiBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG5cblxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24nKSkge1xuICAgICAgICB0aGlzLiR3cmFwcGVyID0gJCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bicpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGVIZWlnaHQpIHRoaXMuJHdyYXBwZXIuYWRkQ2xhc3MoJ2FuaW1hdGUtaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKTtcbiAgICAgIH0gLy8gc2V0IHdyYXBwZXJcblxuXG4gICAgICB0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcbiAgICAgICAgJ21heC13aWR0aCc6ICdub25lJyxcbiAgICAgICAgJ21pbi1oZWlnaHQnOiAnbm9uZSdcbiAgICAgIH0pOyAvLyBfZ2V0TWF4RGltcyBoYXMgc2lkZSBlZmZlY3RzIChib28pIGJ1dCBjYWxsaW5nIGl0IHNob3VsZCB1cGRhdGUgYWxsIG90aGVyIG5lY2Vzc2FyeSBoZWlnaHRzICYgd2lkdGhzXG5cbiAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCRlbGVtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdsaScpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSAvLyBpZihlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkKXtcbiAgICAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIF90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG5cbiAgICAgICAgICAgICRib2R5Lm9mZignLnpmLmRyaWxsZG93bicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgbWVudSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVnaXN0ZXJFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRXZlbnRzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUb3ApIHtcbiAgICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxUb3AuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignb3Blbi56Zi5kcmlsbGRvd24gaGlkZS56Zi5kcmlsbGRvd24gY2xvc2UuemYuZHJpbGxkb3duIGNsb3NlZC56Zi5kcmlsbGRvd24nLCB0aGlzLl9iaW5kSGFuZGxlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9yZXNpemUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbCB0byBUb3Agb2YgRWxlbWVudCBvciBkYXRhLXNjcm9sbC10b3AtZWxlbWVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jc2Nyb2xsbWVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zY3JvbGxUb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbFRvcCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciAkc2Nyb2xsVG9wRWxlbWVudCA9IF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wRWxlbWVudCAhPSAnJyA/ICQoX3RoaXMub3B0aW9ucy5zY3JvbGxUb3BFbGVtZW50KSA6IF90aGlzLiRlbGVtZW50LFxuICAgICAgICAgIHNjcm9sbFBvcyA9IHBhcnNlSW50KCRzY3JvbGxUb3BFbGVtZW50Lm9mZnNldCgpLnRvcCArIF90aGlzLm9wdGlvbnMuc2Nyb2xsVG9wT2Zmc2V0LCAxMCk7XG4gICAgICAkKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHtcbiAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxQb3NcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICogRmlyZXMgYWZ0ZXIgdGhlIG1lbnUgaGFzIHNjcm9sbGVkXG4gICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI3Njcm9sbG1lXG4gICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMgPT09ICQoJ2h0bWwnKVswXSkgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignc2Nyb2xsbWUuemYuZHJpbGxkb3duJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBrZXlkb3duIGV2ZW50IGxpc3RlbmVyIHRvIGBsaWAncyBpbiB0aGUgbWVudS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2tleWJvYXJkRXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlib2FyZEV2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2sgPiBhLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbSA+IGEnKSkub24oJ2tleWRvd24uemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSxcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICRuZXh0RWxlbWVudDtcbiAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnRHJpbGxkb3duJywge1xuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpO1xuXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUodHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykuZmluZCgndWwgbGkgYScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrIGEnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xuXG4gICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZSh0cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5jaGlsZHJlbignYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXA6IGZ1bmN0aW9uIHVwKCkge1xuICAgICAgICAgICAgJHByZXZFbGVtZW50LmZvY3VzKCk7IC8vIERvbid0IHRhcCBmb2N1cyBvbiBmaXJzdCBlbGVtZW50IGluIHJvb3QgdWxcblxuICAgICAgICAgICAgcmV0dXJuICEkZWxlbWVudC5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCc+IGxpOmZpcnN0LWNoaWxkID4gYScpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRvd246IGZ1bmN0aW9uIGRvd24oKSB7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQuZm9jdXMoKTsgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGxhc3QgZWxlbWVudCBpbiByb290IHVsXG5cbiAgICAgICAgICAgIHJldHVybiAhJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaTpsYXN0LWNoaWxkID4gYScpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNsb3NlIG9uIGVsZW1lbnQgaW4gcm9vdCB1bFxuICAgICAgICAgICAgaWYgKCEkZWxlbWVudC5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCc+IGxpID4gYScpKSkge1xuICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoKS5wYXJlbnQoKSk7XG5cbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCkucGFyZW50KCkuc2libGluZ3MoJ2EnKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnBhcmVudExpbmsgJiYgJGVsZW1lbnQuYXR0cignaHJlZicpKSB7XG4gICAgICAgICAgICAgIC8vIExpbmsgd2l0aCBocmVmXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRtZW51SXRlbXMpKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBtZW51IGl0ZW0gbWVhbnMgYmFjayBidXR0b25cbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKSk7XG5cbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUodHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcbiAgICAgICAgICAgICAgLy8gU3ViIG1lbnUgaXRlbVxuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpO1xuXG4gICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUodHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykuZmluZCgndWwgbGkgYScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrIGEnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBlbmQga2V5Ym9hcmRBY2Nlc3NcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGFsbCBvcGVuIGVsZW1lbnRzLCBhbmQgcmV0dXJucyB0byByb290IG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZVxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jY2xvc2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGlkZUFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZUFsbCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgJGVsZW0gPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmUnKTtcbiAgICAgICRlbGVtLmFkZENsYXNzKCdpcy1jbG9zaW5nJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICB2YXIgY2FsY0hlaWdodCA9ICRlbGVtLnBhcmVudCgpLmNsb3Nlc3QoJ3VsJykuZGF0YSgnY2FsY0hlaWdodCcpO1xuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh7XG4gICAgICAgICAgaGVpZ2h0OiBjYWxjSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGNsb3NpbmcuXG4gICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlLnpmLmRyaWxsZG93bicpO1xuICAgICAgJGVsZW0ub25lKHRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBmdWxseSBjbG9zZWQuXG4gICAgICAgICAqIEBldmVudCBEcmlsbGRvd24jY2xvc2VkXG4gICAgICAgICAqL1xuXG4gICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lciBmb3IgZWFjaCBgYmFja2AgYnV0dG9uLCBhbmQgY2xvc2VzIG9wZW4gbWVudXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyaWxsZG93biNiYWNrXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gYWRkIGBiYWNrYCBldmVudC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9iYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrKCRlbGVtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpO1xuICAgICAgJGVsZW0uY2hpbGRyZW4oJy5qcy1kcmlsbGRvd24tYmFjaycpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbW91c2V1cCBvbiBiYWNrJyk7XG4gICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTsgLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQgc3VibWVudSwgY2FsbCBzaG93XG5cblxuICAgICAgICB2YXIgcGFyZW50U3ViTWVudSA9ICRlbGVtLnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xuXG4gICAgICAgIGlmIChwYXJlbnRTdWJNZW51Lmxlbmd0aCkge1xuICAgICAgICAgIF90aGlzLl9zaG93KHBhcmVudFN1Yk1lbnUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWVudUxpbmtFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21lbnVMaW5rRXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIHNob3cgaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciAtIHRyaWdnZXIgZHJpbGxkb3duIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2hvd1N1Yk1lbnVDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaG93U3ViTWVudUNsYXNzZXMoJGVsZW0sIHRyaWdnZXIpIHtcbiAgICAgICRlbGVtLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSk7XG4gICAgICAkZWxlbS5wYXJlbnQoJ2xpJykuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICBpZiAodHJpZ2dlciA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIENTUyBjbGFzc2VzIGZvciBzdWJtZW51IHRvIGhpZGUgaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgdGFyZ2V0IHN1Ym1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlciAtIHRyaWdnZXIgZHJpbGxkb3duIGV2ZW50XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0SGlkZVN1Yk1lbnVDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIaWRlU3ViTWVudUNsYXNzZXMoJGVsZW0sIHRyaWdnZXIpIHtcbiAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hZGRDbGFzcygnaW52aXNpYmxlJykuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgICRlbGVtLnBhcmVudCgnbGknKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuXG4gICAgICBpZiAodHJpZ2dlciA9PT0gdHJ1ZSkge1xuICAgICAgICAkZWxlbS50cmlnZ2VyKCdoaWRlLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIHNwZWNpZmljIGRyaWxsZG93biAoc3ViKW1lbnUgbm8gbWF0dGVyIHdoaWNoIChzdWIpbWVudSBpbiBpdCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKiBDb21wYXJlZCB0byBfc2hvdygpIHRoaXMgbGV0cyB5b3UganVtcCBpbnRvIGFueSBzdWJtZW51IHdpdGhvdXQgY2xpY2tpbmcgdGhyb3VnaCBldmVyeSBzdWJtZW51IG9uIHRoZSB3YXkgdG8gaXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyaWxsZG93biNvcGVuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIHRhcmdldCAoc3ViKW1lbnUgKGB1bGAgdGFnKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYXV0b0ZvY3VzIC0gaWYgdHJ1ZSB0aGUgZmlyc3QgbGluayBpbiB0aGUgdGFyZ2V0IChzdWIpbWVudSBnZXRzIGF1dG8gZm9jdXNlZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dNZW51XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93TWVudSgkZWxlbSwgYXV0b0ZvY3VzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzOyAvLyBSZXNldCBkcmlsbGRvd25cblxuXG4gICAgICB2YXIgJGV4cGFuZGVkU3VibWVudXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpW2FyaWEtZXhwYW5kZWQ9XCJ0cnVlXCJdID4gdWxbZGF0YS1zdWJtZW51XScpO1xuICAgICAgJGV4cGFuZGVkU3VibWVudXMuZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgX3RoaXMuX3NldEhpZGVTdWJNZW51Q2xhc3NlcygkKHRoaXMpKTtcbiAgICAgIH0pOyAvLyBTYXZlIHRoZSBtZW51IGFzIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIG9uZS5cblxuICAgICAgdGhpcy4kY3VycmVudE1lbnUgPSAkZWxlbTsgLy8gSWYgdGFyZ2V0IG1lbnUgaXMgcm9vdCwgZm9jdXMgZmlyc3QgbGluayAmIGV4aXRcblxuICAgICAgaWYgKCRlbGVtLmlzKCdbZGF0YS1kcmlsbGRvd25dJykpIHtcbiAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkgJGVsZW0uZmluZCgnbGlbcm9sZT1cInRyZWVpdGVtXCJdID4gYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcygnaGVpZ2h0JywgJGVsZW0uZGF0YSgnY2FsY0hlaWdodCcpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGaW5kIGFsbCBzdWJtZW51cyBvbiB3YXkgdG8gcm9vdCBpbmNsLiB0aGUgZWxlbWVudCBpdHNlbGZcblxuXG4gICAgICB2YXIgJHN1Ym1lbnVzID0gJGVsZW0uY2hpbGRyZW4oKS5maXJzdCgpLnBhcmVudHNVbnRpbCgnW2RhdGEtZHJpbGxkb3duXScsICdbZGF0YS1zdWJtZW51XScpOyAvLyBPcGVuIHRhcmdldCBtZW51IGFuZCBhbGwgc3VibWVudXMgb24gaXRzIHdheSB0byByb290XG5cbiAgICAgICRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGZpcnN0IGNoaWxkICh0YXJnZXQgbWVudSkgaWYgYXV0b0hlaWdodCBvcHRpb24gdHJ1ZVxuICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgX3RoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgX3RoaXMuJHdyYXBwZXIuY3NzKCdoZWlnaHQnLCAkKHRoaXMpLmRhdGEoJ2NhbGNIZWlnaHQnKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNMYXN0Q2hpbGQgPSBpbmRleCA9PSAkc3VibWVudXMubGVuZ3RoIC0gMTsgLy8gQWRkIHRyYW5zaXRpb25zZW5kIGxpc3RlbmVyIHRvIGxhc3QgY2hpbGQgKHJvb3QgZHVlIHRvIHJldmVyc2Ugb3JkZXIpIHRvIG9wZW4gdGFyZ2V0IG1lbnUncyBmaXJzdCBsaW5rXG4gICAgICAgIC8vIExhc3QgY2hpbGQgbWFrZXMgc3VyZSB0aGUgZXZlbnQgZ2V0cyBhbHdheXMgdHJpZ2dlcmVkIGV2ZW4gaWYgZ29pbmcgdGhyb3VnaCBzZXZlcmFsIG1lbnVzXG5cbiAgICAgICAgaWYgKGlzTGFzdENoaWxkID09PSB0cnVlKSB7XG4gICAgICAgICAgJCh0aGlzKS5vbmUodHJhbnNpdGlvbmVuZCgkKHRoaXMpKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGF1dG9Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAkZWxlbS5maW5kKCdsaVtyb2xlPVwidHJlZWl0ZW1cIl0gPiBhJykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX3NldFNob3dTdWJNZW51Q2xhc3NlcygkKHRoaXMpLCBpc0xhc3RDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBzdWJtZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gb3BlbiwgaS5lLiB0aGUgYGxpYCB0YWcuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkZWxlbSkge1xuICAgICAgdmFyICRzdWJtZW51ID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG4gICAgICAkZWxlbS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICB0aGlzLiRjdXJyZW50TWVudSA9ICRzdWJtZW51O1xuICAgICAgJHN1Ym1lbnUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcbiAgICAgICAgICBoZWlnaHQ6ICRzdWJtZW51LmRhdGEoJ2NhbGNIZWlnaHQnKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgb3BlbmVkLlxuICAgICAgICogQGV2ZW50IERyaWxsZG93biNvcGVuXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIGEgc3VibWVudVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcmlsbGRvd24jaGlkZVxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGhpZGUsIGkuZS4gdGhlIGB1bGAgdGFnLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0pIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkgdGhpcy4kd3JhcHBlci5jc3Moe1xuICAgICAgICBoZWlnaHQ6ICRlbGVtLnBhcmVudCgpLmNsb3Nlc3QoJ3VsJykuZGF0YSgnY2FsY0hlaWdodCcpXG4gICAgICB9KTtcblxuICAgICAgJGVsZW0ucGFyZW50KCdsaScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAkZWxlbS5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKS5vbmUodHJhbnNpdGlvbmVuZCgkZWxlbSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nJyk7XG4gICAgICAgICRlbGVtLmJsdXIoKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxuICAgICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXG4gICAgICAgKi9cblxuICAgICAgJGVsZW0udHJpZ2dlcignaGlkZS56Zi5kcmlsbGRvd24nLCBbJGVsZW1dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIG1lbnVzIHRvIGNhbGN1bGF0ZSB0aGUgbWluLWhlaWdodCwgYW5kIG1heC13aWR0aCBmb3IgdGhlIG1lbnUuXG4gICAgICogUHJldmVudHMgY29udGVudCBqdW1waW5nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TWF4RGltc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4RGltcygpIHtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gUmVjYWxjdWxhdGUgbWVudSBoZWlnaHRzIGFuZCB0b3RhbCBtYXggaGVpZ2h0XG5cblxuICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbnVtT2ZFbGVtcyA9ICQodGhpcykuY2hpbGRyZW4oJ2xpJykubGVuZ3RoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gQm94LkdldERpbWVuc2lvbnModGhpcykuaGVpZ2h0O1xuICAgICAgICBtYXhIZWlnaHQgPSBoZWlnaHQgPiBtYXhIZWlnaHQgPyBoZWlnaHQgOiBtYXhIZWlnaHQ7XG5cbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICAgICQodGhpcykuZGF0YSgnY2FsY0hlaWdodCcsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSByZXN1bHRbJ2hlaWdodCddID0gdGhpcy4kY3VycmVudE1lbnUuZGF0YSgnY2FsY0hlaWdodCcpO2Vsc2UgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBcIlwiLmNvbmNhdChtYXhIZWlnaHQsIFwicHhcIik7XG4gICAgICByZXN1bHRbJ21heC13aWR0aCddID0gXCJcIi5jb25jYXQodGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCwgXCJweFwiKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFRvcCkgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5kcmlsbGRvd24nLCB0aGlzLl9iaW5kSGFuZGxlcik7XG5cbiAgICAgIHRoaXMuX2hpZGVBbGwoKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgIE5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpLmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaywgLmlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0nKS5yZW1vdmUoKS5lbmQoKS5maW5kKCcuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51JykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51JykuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJyk7XG4gICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1pcy1wYXJlbnQtbGlua10nKS5kZXRhY2goKTtcbiAgICAgIHRoaXMuJHN1Ym1lbnVzLnJlbW92ZUNsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cyBpbnZpc2libGUnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGxpbmsgPSAkKHRoaXMpO1xuICAgICAgICAkbGluay5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuXG4gICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xuICAgICAgICAgICRsaW5rLmF0dHIoJ2hyZWYnLCAkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkucmVtb3ZlRGF0YSgnc2F2ZWRIcmVmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJpbGxkb3duO1xufShQbHVnaW4pO1xuXG5EcmlsbGRvd24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBEcmlsbGRvd25zIGRlcGVuZCBvbiBzdHlsZXMgaW4gb3JkZXIgdG8gZnVuY3Rpb24gcHJvcGVybHk7IGluIHRoZSBkZWZhdWx0IGJ1aWxkIG9mIEZvdW5kYXRpb24gdGhlc2UgYXJlXG4gICAqIG9uIHRoZSBgZHJpbGxkb3duYCBjbGFzcy4gVGhpcyBvcHRpb24gYXV0by1hcHBsaWVzIHRoaXMgY2xhc3MgdG8gdGhlIGRyaWxsZG93biB1cG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhdXRvQXBwbHlDbGFzczogdHJ1ZSxcblxuICAvKipcbiAgICogTWFya3VwIHVzZWQgZm9yIEpTIGdlbmVyYXRlZCBiYWNrIGJ1dHRvbi4gUHJlcGVuZGVkICBvciBhcHBlbmRlZCAoc2VlIGJhY2tCdXR0b25Qb3NpdGlvbikgdG8gc3VibWVudSBsaXN0cyBhbmQgZGVsZXRlZCBvbiBgZGVzdHJveWAgbWV0aG9kLCAnanMtZHJpbGxkb3duLWJhY2snIGNsYXNzIHJlcXVpcmVkLiBSZW1vdmUgdGhlIGJhY2tzbGFzaCAoYFxcYCkgaWYgY29weSBhbmQgcGFzdGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnPGxpIGNsYXNzPVwianMtZHJpbGxkb3duLWJhY2tcIj48YSB0YWJpbmRleD1cIjBcIj5CYWNrPC9hPjwvbGk+J1xuICAgKi9cbiAgYmFja0J1dHRvbjogJzxsaSBjbGFzcz1cImpzLWRyaWxsZG93bi1iYWNrXCI+PGEgdGFiaW5kZXg9XCIwXCI+QmFjazwvYT48L2xpPicsXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIHRoZSBiYWNrIGJ1dHRvbiBlaXRoZXIgYXQgdGhlIHRvcCBvciBib3R0b20gb2YgZHJpbGxkb3duIHN1Ym1lbnVzLiBDYW4gYmUgYCdsZWZ0J2Agb3IgYCdib3R0b20nYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCB0b3BcbiAgICovXG4gIGJhY2tCdXR0b25Qb3NpdGlvbjogJ3RvcCcsXG5cbiAgLyoqXG4gICAqIE1hcmt1cCB1c2VkIHRvIHdyYXAgZHJpbGxkb3duIG1lbnUuIFVzZSBhIGNsYXNzIG5hbWUgZm9yIGluZGVwZW5kZW50IHN0eWxpbmc7IHRoZSBKUyBhcHBsaWVkIGNsYXNzOiBgaXMtZHJpbGxkb3duYCBpcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJzxkaXY+PC9kaXY+J1xuICAgKi9cbiAgd3JhcHBlcjogJzxkaXY+PC9kaXY+JyxcblxuICAvKipcbiAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBwYXJlbnRMaW5rOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIG1lbnUgdG8gYXV0byBhZGp1c3QgaGVpZ2h0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b0hlaWdodDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgdGhlIGF1dG8gYWRqdXN0IGhlaWdodC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFuaW1hdGVIZWlnaHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgbWVudSBhZnRlciBvcGVuaW5nIGEgc3VibWVudSBvciBuYXZpZ2F0aW5nIGJhY2sgdXNpbmcgdGhlIG1lbnUgYmFjayBidXR0b25cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNjcm9sbFRvcDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFN0cmluZyBqcXVlcnkgc2VsZWN0b3IgKGZvciBleGFtcGxlICdib2R5Jykgb2YgZWxlbWVudCB0byB0YWtlIG9mZnNldCgpLnRvcCBmcm9tLCBpZiBlbXB0eSBzdHJpbmcgdGhlIGRyaWxsZG93biBtZW51IG9mZnNldCgpLnRvcCBpcyB0YWtlblxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBzY3JvbGxUb3BFbGVtZW50OiAnJyxcblxuICAvKipcbiAgICogU2Nyb2xsVG9wIG9mZnNldFxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHNjcm9sbFRvcE9mZnNldDogMCxcblxuICAvKipcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBkdXJhdGlvblxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDUwMFxuICAgKi9cbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcblxuICAvKipcbiAgICogU2Nyb2xsIGFuaW1hdGlvbiBlYXNpbmcuIENhbiBiZSBgJ3N3aW5nJ2Agb3IgYCdsaW5lYXInYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwaS5qcXVlcnkuY29tL2FuaW1hdGV8SlF1ZXJ5IGFuaW1hdGV9XG4gICAqIEBkZWZhdWx0ICdzd2luZydcbiAgICovXG4gIGFuaW1hdGlvbkVhc2luZzogJ3N3aW5nJyAvLyBob2xkT3BlbjogZmFsc2VcblxufTtcblxudmFyIFBPU0lUSU9OUyA9IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ107XG52YXIgVkVSVElDQUxfQUxJR05NRU5UUyA9IFsndG9wJywgJ2JvdHRvbScsICdjZW50ZXInXTtcbnZhciBIT1JJWk9OVEFMX0FMSUdOTUVOVFMgPSBbJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJ107XG52YXIgQUxJR05NRU5UUyA9IHtcbiAgJ2xlZnQnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxuICAncmlnaHQnOiBWRVJUSUNBTF9BTElHTk1FTlRTLFxuICAndG9wJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTLFxuICAnYm90dG9tJzogSE9SSVpPTlRBTF9BTElHTk1FTlRTXG59O1xuXG5mdW5jdGlvbiBuZXh0SXRlbShpdGVtLCBhcnJheSkge1xuICB2YXIgY3VycmVudElkeCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG5cbiAgaWYgKGN1cnJlbnRJZHggPT09IGFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gYXJyYXlbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFycmF5W2N1cnJlbnRJZHggKyAxXTtcbiAgfVxufVxuXG52YXIgUG9zaXRpb25hYmxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhQb3NpdGlvbmFibGUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uYWJsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zaXRpb25hYmxlKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUG9zaXRpb25hYmxlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb3NpdGlvbmFibGUsIFt7XG4gICAga2V5OiBcIl9pbml0XCIsXG5cbiAgICAvKipcbiAgICAgKiBBYnN0cmFjdCBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSB0ZXRoZXItbGlrZSBleHBsaWNpdCBwb3NpdGlvbmluZyBsb2dpY1xuICAgICAqIGluY2x1ZGluZyByZXBvc2l0aW9uaW5nIGJhc2VkIG9uIG92ZXJsYXAuXG4gICAgICogRXhwZWN0cyBjbGFzc2VzIHRvIGRlZmluZSBkZWZhdWx0cyBmb3Igdk9mZnNldCwgaE9mZnNldCwgcG9zaXRpb24sXG4gICAgICogYWxpZ25tZW50LCBhbGxvd092ZXJsYXAsIGFuZCBhbGxvd0JvdHRvbU92ZXJsYXAuIFRoZXkgY2FuIGRvIHRoaXMgYnlcbiAgICAgKiBleHRlbmRpbmcgdGhlIGRlZmF1bHRzLCBvciAoZm9yIG5vdyByZWNvbW1lbmRlZCBkdWUgdG8gdGhlIHdheSBkb2NzIGFyZVxuICAgICAqIGdlbmVyYXRlZCkgYnkgZXhwbGljaXRseSBkZWNsYXJpbmcgdGhlbS5cbiAgICAgKlxuICAgICAqKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zID0ge307XG4gICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYXV0bycgPyB0aGlzLl9nZXREZWZhdWx0UG9zaXRpb24oKSA6IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYWxpZ25tZW50ID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2F1dG8nID8gdGhpcy5fZ2V0RGVmYXVsdEFsaWdubWVudCgpIDogdGhpcy5vcHRpb25zLmFsaWdubWVudDtcbiAgICAgIHRoaXMub3JpZ2luYWxQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICB0aGlzLm9yaWdpbmFsQWxpZ25tZW50ID0gdGhpcy5hbGlnbm1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiAnYm90dG9tJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERlZmF1bHRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZXR1cm4gcnRsKCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmV0dXJuICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBwb3NpdGlvbmFibGUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcbiAgICAgKiBhbmQgcG9zaXRpb25zLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVwb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwb3NpdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9hbGlnbm1lbnRzRXhoYXVzdGVkKHRoaXMucG9zaXRpb24pKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXh0SXRlbSh0aGlzLnBvc2l0aW9uLCBQT1NJVElPTlMpO1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9IEFMSUdOTUVOVFNbdGhpcy5wb3NpdGlvbl1bMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWFsaWduKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIGRyb3Bkb3duIHBhbmUgcG9zc2libGUgcG9zaXRpb25zIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsaWdubWVudHNcbiAgICAgKiBvbiB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlYWxpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWxpZ24oKSB7XG4gICAgICB0aGlzLl9hZGRUcmllZFBvc2l0aW9uKHRoaXMucG9zaXRpb24sIHRoaXMuYWxpZ25tZW50KTtcblxuICAgICAgdGhpcy5hbGlnbm1lbnQgPSBuZXh0SXRlbSh0aGlzLmFsaWdubWVudCwgQUxJR05NRU5UU1t0aGlzLnBvc2l0aW9uXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRUcmllZFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRUcmllZFBvc2l0aW9uKHBvc2l0aW9uLCBhbGlnbm1lbnQpIHtcbiAgICAgIHRoaXMudHJpZWRQb3NpdGlvbnNbcG9zaXRpb25dID0gdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gfHwgW107XG4gICAgICB0aGlzLnRyaWVkUG9zaXRpb25zW3Bvc2l0aW9uXS5wdXNoKGFsaWdubWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wb3NpdGlvbnNFeGhhdXN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uc0V4aGF1c3RlZCgpIHtcbiAgICAgIHZhciBpc0V4aGF1c3RlZCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUE9TSVRJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlzRXhoYXVzdGVkID0gaXNFeGhhdXN0ZWQgJiYgdGhpcy5fYWxpZ25tZW50c0V4aGF1c3RlZChQT1NJVElPTlNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNFeGhhdXN0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hbGlnbm1lbnRzRXhoYXVzdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hbGlnbm1lbnRzRXhoYXVzdGVkKHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0gJiYgdGhpcy50cmllZFBvc2l0aW9uc1twb3NpdGlvbl0ubGVuZ3RoID09IEFMSUdOTUVOVFNbcG9zaXRpb25dLmxlbmd0aDtcbiAgICB9IC8vIFdoZW4gd2UncmUgdHJ5aW5nIHRvIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBhcHBseSBvZmZzZXQgdGhhdCdzIGdvaW5nIHRvXG4gICAgLy8gdGFrZSB1cyBqdXN0IG9mZiBjZW50ZXIsIHNvIHdyYXAgYXJvdW5kIHRvIHJldHVybiAwIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgICAvLyBvZmZzZXQgaW4gdGhvc2UgYWxpZ25tZW50cy4gIFRPRE86IEZpZ3VyZSBvdXQgaWYgd2Ugd2FudCB0byBtYWtlIHRoaXNcbiAgICAvLyBjb25maWd1cmFibGUgYmVoYXZpb3IuLi4gaXQgZmVlbHMgbW9yZSBpbnR1aXRpdmUsIGVzcGVjaWFsbHkgZm9yIHRvb2x0aXBzLCBidXRcbiAgICAvLyBpdCdzIHBvc3NpYmxlIHNvbWVvbmUgbWlnaHQgYWN0dWFsbHkgd2FudCB0byBzdGFydCBmcm9tIGNlbnRlciBhbmQgdGhlbiBudWRnZVxuICAgIC8vIHNsaWdodGx5IG9mZi5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0SE9mZnNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaE9mZnNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigkYW5jaG9yLCAkZWxlbWVudCwgJHBhcmVudCkge1xuICAgICAgaWYgKCRhbmNob3IuYXR0cignYXJpYS1leHBhbmRlZCcpID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dPdmVybGFwKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgcG9zaXRpb24gJiBhbGlnbm1lbnQgYmVmb3JlIGNoZWNraW5nIG92ZXJsYXBcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMub3JpZ2luYWxQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hbGlnbm1lbnQgPSB0aGlzLm9yaWdpbmFsQWxpZ25tZW50O1xuICAgICAgfVxuXG4gICAgICAkZWxlbWVudC5vZmZzZXQoQm94LkdldEV4cGxpY2l0T2Zmc2V0cygkZWxlbWVudCwgJGFuY2hvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbGlnbm1lbnQsIHRoaXMuX2dldFZPZmZzZXQoKSwgdGhpcy5fZ2V0SE9mZnNldCgpKSk7XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93T3ZlcmxhcCkge1xuICAgICAgICB2YXIgbWluT3ZlcmxhcCA9IDEwMDAwMDAwMDsgLy8gZGVmYXVsdCBjb29yZGluYXRlcyB0byBob3cgd2Ugc3RhcnQsIGluIGNhc2Ugd2UgY2FuJ3QgZmlndXJlIG91dCBiZXR0ZXJcblxuICAgICAgICB2YXIgbWluQ29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgcG9zaXRpb246IHRoaXMucG9zaXRpb24sXG4gICAgICAgICAgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudFxuICAgICAgICB9O1xuXG4gICAgICAgIHdoaWxlICghdGhpcy5fcG9zaXRpb25zRXhoYXVzdGVkKCkpIHtcbiAgICAgICAgICB2YXIgb3ZlcmxhcCA9IEJveC5PdmVybGFwQXJlYSgkZWxlbWVudCwgJHBhcmVudCwgZmFsc2UsIGZhbHNlLCB0aGlzLm9wdGlvbnMuYWxsb3dCb3R0b21PdmVybGFwKTtcblxuICAgICAgICAgIGlmIChvdmVybGFwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgIG1pbkNvb3JkaW5hdGVzID0ge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgYWxpZ25tZW50OiB0aGlzLmFsaWdubWVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yZXBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAkZWxlbWVudC5vZmZzZXQoQm94LkdldEV4cGxpY2l0T2Zmc2V0cygkZWxlbWVudCwgJGFuY2hvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbGlnbm1lbnQsIHRoaXMuX2dldFZPZmZzZXQoKSwgdGhpcy5fZ2V0SE9mZnNldCgpKSk7XG4gICAgICAgIH0gLy8gSWYgd2UgZ2V0IHRocm91Z2ggdGhlIGVudGlyZSBsb29wLCB0aGVyZSB3YXMgbm8gbm9uLW92ZXJsYXBwaW5nXG4gICAgICAgIC8vIHBvc2l0aW9uIGF2YWlsYWJsZS4gUGljayB0aGUgdmVyc2lvbiB3aXRoIGxlYXN0IG92ZXJsYXAuXG5cblxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbWluQ29vcmRpbmF0ZXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYWxpZ25tZW50ID0gbWluQ29vcmRpbmF0ZXMuYWxpZ25tZW50O1xuICAgICAgICAkZWxlbWVudC5vZmZzZXQoQm94LkdldEV4cGxpY2l0T2Zmc2V0cygkZWxlbWVudCwgJGFuY2hvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy5hbGlnbm1lbnQsIHRoaXMuX2dldFZPZmZzZXQoKSwgdGhpcy5fZ2V0SE9mZnNldCgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvc2l0aW9uYWJsZTtcbn0oUGx1Z2luKTtcblxuUG9zaXRpb25hYmxlLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9zaXRpb24gb2YgcG9zaXRpb25hYmxlIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgb3IgYXV0by5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIHBvc2l0aW9uOiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsaWdubWVudCBvZiBwb3NpdGlvbmFibGUgcmVsYXRpdmUgdG8gYW5jaG9yLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBjZW50ZXIsIG9yIGF1dG8uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICBhbGlnbm1lbnQ6ICdhdXRvJyxcblxuICAvKipcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBjb250YWluZXIvd2luZG93LiBJZiBmYWxzZSwgZHJvcGRvd24gcG9zaXRpb25hYmxlIGZpcnN0XG4gICAqIHRyeSB0byBwb3NpdGlvbiBhcyBkZWZpbmVkIGJ5IGRhdGEtcG9zaXRpb24gYW5kIGRhdGEtYWxpZ25tZW50LCBidXRcbiAgICogcmVwb3NpdGlvbiBpZiBpdCB3b3VsZCBjYXVzZSBhbiBvdmVyZmxvdy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFsbG93T3ZlcmxhcDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2Ygb25seSB0aGUgYm90dG9tIG9mIHRoZSBjb250YWluZXIuIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uXG4gICAqIGJlaGF2aW9yIGZvciBkcm9wZG93bnMsIGFsbG93aW5nIHRoZSBkcm9wZG93biB0byBleHRlbmQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICogc2NyZWVuIGJ1dCBub3Qgb3RoZXJ3aXNlIGluZmx1ZW5jZSBvciBicmVhayBvdXQgb2YgdGhlIGNvbnRhaW5lci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWxsb3dCb3R0b21PdmVybGFwOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRoZSBwb3NpdGlvbmFibGUgc2hvdWxkIGJlIHNlcGFyYXRlZCB2ZXJ0aWNhbGx5IGZyb20gYW5jaG9yXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgdk9mZnNldDogMCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0aGUgcG9zaXRpb25hYmxlIHNob3VsZCBiZSBzZXBhcmF0ZWQgaG9yaXpvbnRhbGx5IGZyb20gYW5jaG9yXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgaE9mZnNldDogMFxufTtcblxuLyoqXG4gKiBEcm9wZG93biBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKi9cblxudmFyIERyb3Bkb3duID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUG9zaXRpb25hYmxlKSB7XG4gIF9pbmhlcml0cyhEcm9wZG93biwgX1Bvc2l0aW9uYWJsZSk7XG5cbiAgZnVuY3Rpb24gRHJvcGRvd24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBEcm9wZG93blxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cbiAgICAgKiAgICAgICAgT2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZHJvcGRvd24gcGFuZWwsIHJhdGhlciB0aGFuIGl0cyBhbmNob3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJvcGRvd24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0Ryb3Bkb3duJzsgLy8gaWU5IGJhY2sgY29tcGF0XG4gICAgICAvLyBUb3VjaCBhbmQgVHJpZ2dlcnMgaW5pdCBhcmUgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBpbml0aWFsaXplZFxuXG4gICAgICBUb3VjaC5pbml0KCQpO1xuICAgICAgVHJpZ2dlcnMuaW5pdCgkKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignRHJvcGRvd24nLCB7XG4gICAgICAgICdFTlRFUic6ICd0b2dnbGUnLFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IHNldHRpbmcvY2hlY2tpbmcgb3B0aW9ucyBhbmQgYXR0cmlidXRlcywgYWRkaW5nIGhlbHBlciB2YXJpYWJsZXMsIGFuZCBzYXZpbmcgdGhlIGFuY2hvci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB2YXIgJGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xuICAgICAgdGhpcy4kYW5jaG9ycyA9ICQoXCJbZGF0YS10b2dnbGU9XFxcIlwiLmNvbmNhdCgkaWQsIFwiXFxcIl1cIikpLmxlbmd0aCA/ICQoXCJbZGF0YS10b2dnbGU9XFxcIlwiLmNvbmNhdCgkaWQsIFwiXFxcIl1cIikpIDogJChcIltkYXRhLW9wZW49XFxcIlwiLmNvbmNhdCgkaWQsIFwiXFxcIl1cIikpO1xuICAgICAgdGhpcy4kYW5jaG9ycy5hdHRyKHtcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiAkaWQsXG4gICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXG4gICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zZXRDdXJyZW50QW5jaG9yKHRoaXMuJGFuY2hvcnMuZmlyc3QoKSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50Q2xhc3MpIHtcbiAgICAgICAgdGhpcy4kcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcuJyArIHRoaXMub3B0aW9ucy5wYXJlbnRDbGFzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRwYXJlbnQgPSBudWxsO1xuICAgICAgfSAvLyBTZXQgW2FyaWEtbGFiZWxsZWRieV0gb24gdGhlIERyb3Bkb3duIGlmIGl0IGlzIG5vdCBzZXRcblxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEdldCB0aGUgYW5jaG9yIElEIG9yIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiRjdXJyZW50QW5jaG9yLmF0dHIoJ2lkJykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhpcy4kY3VycmVudEFuY2hvci5hdHRyKCdpZCcsIEdldFlvRGlnaXRzKDYsICdkZC1hbmNob3InKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignaWQnKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiAkaWQsXG4gICAgICAgICdkYXRhLXJlc2l6ZSc6ICRpZFxuICAgICAgfSk7XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksIFwiX2luaXRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgY2xhc3NuYW1lc1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyh0b3B8bGVmdHxyaWdodHxib3R0b20pL2cpO1xuXG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGVmYXVsdEFsaWdubWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGVmYXVsdEFsaWdubWVudCgpIHtcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgZmxvYXQgYXBwcm9hY2hcbiAgICAgIHZhciBob3Jpem9udGFsUG9zaXRpb24gPSAvZmxvYXQtKFxcUyspLy5leGVjKHRoaXMuJGN1cnJlbnRBbmNob3IuYXR0cignY2xhc3MnKSk7XG5cbiAgICAgIGlmIChob3Jpem9udGFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGhvcml6b250YWxQb3NpdGlvblsxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKERyb3Bkb3duLnByb3RvdHlwZSksIFwiX2dldERlZmF1bHRBbGlnbm1lbnRcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBkcm9wZG93biBwYW5lLCBjaGVja3MgZm9yIGNvbGxpc2lvbnMgaWYgYWxsb3ctb3ZlcmxhcCBpcyBub3QgdHJ1ZS5cbiAgICAgKiBSZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgaWYgYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQsIHdpdGggYSBuZXcgcG9zaXRpb24gY2xhc3MuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaGFzLXBvc2l0aW9uLVwiLmNvbmNhdCh0aGlzLnBvc2l0aW9uLCBcIiBoYXMtYWxpZ25tZW50LVwiKS5jb25jYXQodGhpcy5hbGlnbm1lbnQpKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoRHJvcGRvd24ucHJvdG90eXBlKSwgXCJfc2V0UG9zaXRpb25cIiwgdGhpcykuY2FsbCh0aGlzLCB0aGlzLiRjdXJyZW50QW5jaG9yLCB0aGlzLiRlbGVtZW50LCB0aGlzLiRwYXJlbnQpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiaGFzLXBvc2l0aW9uLVwiLmNvbmNhdCh0aGlzLnBvc2l0aW9uLCBcIiBoYXMtYWxpZ25tZW50LVwiKS5jb25jYXQodGhpcy5hbGlnbm1lbnQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBpdCBhIGN1cnJlbnQgYW5jaG9yLlxuICAgICAqIEN1cnJlbnQgYW5jaG9yIGFzIHRoZSByZWZlcmVuY2UgZm9yIHRoZSBwb3NpdGlvbiBvZiBEcm9wZG93biBwYW5lcy5cbiAgICAgKiBAcGFyYW0ge0hUTUx9IGVsIC0gRE9NIGVsZW1lbnQgb2YgdGhlIGFuY2hvci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEN1cnJlbnRBbmNob3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEN1cnJlbnRBbmNob3IoZWwpIHtcbiAgICAgIHRoaXMuJGN1cnJlbnRBbmNob3IgPSAkKGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGVsZW1lbnQgdXRpbGl6aW5nIHRoZSB0cmlnZ2VycyB1dGlsaXR5IGxpYnJhcnkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgaGFzVG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgdHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGFuY2hvcnMub2ZmKCdjbGljay56Zi50cmlnZ2VyJykub24oJ2NsaWNrLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpcy5fc2V0Q3VycmVudEFuY2hvcih0aGlzKTtcblxuICAgICAgICBpZiAoIC8vIGlmIGZvcmNlRm9sbG93IGZhbHNlLCBhbHdheXMgcHJldmVudCBkZWZhdWx0IGFjdGlvblxuICAgICAgICBfdGhpcy5vcHRpb25zLmZvcmNlRm9sbG93ID09PSBmYWxzZSB8fCAvLyBpZiBmb3JjZUZvbGxvdyB0cnVlIGFuZCBob3ZlciBvcHRpb24gdHJ1ZSwgb25seSBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uIG9uIDFzdCBjbGlja1xuICAgICAgICAvLyBvbiAybmQgY2xpY2sgKGRyb3Bvd24gb3BlbmVkKSB0aGUgZGVmYXVsdCBhY3Rpb24gKGUuZy4gZm9sbG93IGEgaHJlZikgZ2V0cyBleGVjdXRlZFxuICAgICAgICBoYXNUb3VjaCAmJiBfdGhpcy5vcHRpb25zLmhvdmVyICYmIF90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3Zlcikge1xuICAgICAgICB0aGlzLiRhbmNob3JzLm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX3NldEN1cnJlbnRBbmNob3IodGhpcyk7XG5cbiAgICAgICAgICB2YXIgYm9keURhdGEgPSAkKCdib2R5JykuZGF0YSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBib2R5RGF0YS53aGF0aW5wdXQgPT09ICd1bmRlZmluZWQnIHx8IGJvZHlEYXRhLndoYXRpbnB1dCA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIGlnbm9yZU1vdXNlZGlzYXBwZWFyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcblxuICAgICAgICAgICAgX3RoaXMuJGFuY2hvcnMuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJQYW5lKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93bicpLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgaWdub3JlTW91c2VkaXNhcHBlYXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3JzLmRhdGEoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kYW5jaG9ycy5hZGQodGhpcy4kZWxlbWVudCkub24oJ2tleWRvd24uemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgJHRhcmdldCA9ICQodGhpcyksXG4gICAgICAgICAgICB2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMgPSBLZXlib2FyZC5maW5kRm9jdXNhYmxlKF90aGlzLiRlbGVtZW50KTtcbiAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcm9wZG93bicsIHtcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoX3RoaXMuJGFuY2hvcnMpICYmICEkdGFyZ2V0LmlzKCdpbnB1dCwgdGV4dGFyZWEnKSkge1xuICAgICAgICAgICAgICBfdGhpcy5vcGVuKCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSkuZm9jdXMoKTtcblxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuXG4gICAgICAgICAgICBfdGhpcy4kYW5jaG9ycy5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIHRoZSBib2R5IHRvIGNsb3NlIGFueSBkcm9wZG93bnMgb24gYSBjbGljay5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEJvZHlIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcbiAgICAgIHZhciAkYm9keSA9ICQoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLFxuICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93biB0YXAuemYuZHJvcGRvd24nKS5vbignY2xpY2suemYuZHJvcGRvd24gdGFwLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKF90aGlzLiRhbmNob3JzLmlzKGUudGFyZ2V0KSB8fCBfdGhpcy4kYW5jaG9ycy5maW5kKGUudGFyZ2V0KS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuaXMoZS50YXJnZXQpIHx8IF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNsb3NlKCk7XG5cbiAgICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93biB0YXAuemYuZHJvcGRvd24nKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBEcm9wZG93biNjbG9zZW1lXG4gICAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIC8vIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgdG8gY2xvc2Ugb3RoZXIgb3BlbiBkcm9wZG93bnMsIHR5cGljYWxseSB3aGVuIGRyb3Bkb3duIGlzIG9wZW5pbmdcbiAgICAgICAqIEBldmVudCBEcm9wZG93biNjbG9zZW1lXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5kcm9wZG93bicsIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG4gICAgICB0aGlzLiRhbmNob3JzLmFkZENsYXNzKCdob3ZlcicpLmF0dHIoe1xuICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWVcbiAgICAgIH0pOyAvLyB0aGlzLiRlbGVtZW50Lyouc2hvdygpKi87XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW5pbmcnKTtcblxuICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbmluZycpLmFkZENsYXNzKCdpcy1vcGVuJykuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcbiAgICAgICAgdmFyICRmb2N1c2FibGUgPSBLZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICgkZm9jdXNhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICRmb2N1c2FibGUuZXEoMCkuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cykge1xuICAgICAgICBLZXlib2FyZC50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIHZpc2libGUuXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd24jc2hvd1xuICAgICAgICovXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBvcGVuIGRyb3Bkb3duIHBhbmUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIERyb3Bkb3duI2hpZGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJykuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kYW5jaG9ycy5yZW1vdmVDbGFzcygnaG92ZXInKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyBubyBsb25nZXIgdmlzaWJsZS5cbiAgICAgICAqIEBldmVudCBEcm9wZG93biNoaWRlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcbiAgICAgICAgS2V5Ym9hcmQucmVsZWFzZUZvY3VzKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBkcm9wZG93biBwYW5lJ3MgdmlzaWJpbGl0eS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgIGlmICh0aGlzLiRhbmNob3JzLmRhdGEoJ2hvdmVyJykpIHJldHVybjtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBkcm9wZG93bi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyJykuaGlkZSgpO1xuICAgICAgdGhpcy4kYW5jaG9ycy5vZmYoJy56Zi5kcm9wZG93bicpO1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duIHRhcC56Zi5kcm9wZG93bicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEcm9wZG93bjtcbn0oUG9zaXRpb25hYmxlKTtcblxuRHJvcGRvd24uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBDbGFzcyB0aGF0IGRlc2lnbmF0ZXMgYm91bmRpbmcgY29udGFpbmVyIG9mIERyb3Bkb3duIChkZWZhdWx0OiB3aW5kb3cpXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIHBhcmVudENsYXNzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAyNTBcbiAgICovXG4gIGhvdmVyRGVsYXk6IDI1MCxcblxuICAvKipcbiAgICogQWxsb3cgc3VibWVudXMgdG8gb3BlbiBvbiBob3ZlciBldmVudHNcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogRG9uJ3QgY2xvc2UgZHJvcGRvd24gd2hlbiBob3ZlcmluZyBvdmVyIGRyb3Bkb3duIHBhbmVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGhvdmVyUGFuZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHZPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGhPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIGRyb3Bkb3duLiBDYW4gYmUgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBvciBhdXRvLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgcG9zaXRpb246ICdhdXRvJyxcblxuICAvKipcbiAgICogQWxpZ25tZW50IG9mIGRyb3Bkb3duIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgY2VudGVyLCBvciBhdXRvLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgYWxpZ25tZW50OiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIGRyb3Bkb3duIHdpbGwgZmlyc3QgdHJ5IHRvIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgZGF0YS1wb3NpdGlvbiBhbmQgZGF0YS1hbGlnbm1lbnQsIGJ1dCByZXBvc2l0aW9uIGlmIGl0IHdvdWxkIGNhdXNlIGFuIG92ZXJmbG93LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cbiAgICogYmVoYXZpb3IgZm9yIGRyb3Bkb3ducywgYWxsb3dpbmcgdGhlIGRyb3Bkb3duIHRvIGV4dGVuZCB0aGUgYm90dG9tIG9mIHRoZVxuICAgKiBzY3JlZW4gYnV0IG5vdCBvdGhlcndpc2UgaW5mbHVlbmNlIG9yIGJyZWFrIG91dCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhbGxvd0JvdHRvbU92ZXJsYXA6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gdHJhcCBmb2N1cyB0byB0aGUgZHJvcGRvd24gcGFuZSBpZiBvcGVuZWQgd2l0aCBrZXlib2FyZCBjb21tYW5kcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRyYXBGb2N1czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gc2V0IGZvY3VzIHRvIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCB3aXRoaW4gdGhlIHBhbmUsIHJlZ2FyZGxlc3Mgb2YgbWV0aG9kIG9mIG9wZW5pbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhdXRvRm9jdXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keSB0byBjbG9zZSB0aGUgZHJvcGRvd24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiB0cnVlIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgdG9nZ2xlIChlLmcuIGZvbGxvdyBhIGxpbmsgd2l0aCBocmVmKSBnZXRzIGV4ZWN1dGVkIG9uIGNsaWNrLiBJZiBob3ZlciBvcHRpb24gaXMgYWxzbyB0cnVlIHRoZSBkZWZhdWx0IGFjdGlvbiBnZXRzIHByZXZlbnRlZCBvbiBmaXJzdCBjbGljayBmb3IgbW9iaWxlIC8gdG91Y2ggZGV2aWNlcyBhbmQgZXhlY3V0ZWQgb24gc2Vjb25kIGNsaWNrLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBmb3JjZUZvbGxvdzogdHJ1ZVxufTtcblxuLyoqXG4gKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duTWVudVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxuICovXG5cbnZhciBEcm9wZG93bk1lbnUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKERyb3Bkb3duTWVudSwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gRHJvcGRvd25NZW51KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bk1lbnUpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihEcm9wZG93bk1lbnUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duTWVudSwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIERyb3Bkb3duTWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBEcm9wZG93bk1lbnVcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0Ryb3Bkb3duTWVudSc7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICBUb3VjaC5pbml0KCQpOyAvLyBUb3VjaCBpbml0IGlzIGlkZW1wb3RlbnQsIHdlIGp1c3QgbmVlZCB0byBtYWtlIHN1cmUgaXQncyBpbml0aWFsaWVkLlxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEtleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLCB7XG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiwgYW5kIGNhbGxzIF9wcmVwYXJlTWVudVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIE5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICAgIHZhciBzdWJzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xuICAgICAgdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpO1xuICAgICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaVtyb2xlPVwibm9uZVwiXScpO1xuICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ2xpW3JvbGU9XCJub25lXCJdJyk7XG4gICAgICB0aGlzLiR0YWJzLmZpbmQoJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLnJpZ2h0Q2xhc3MpIHx8IHJ0bCgpIHx8IHRoaXMuJGVsZW1lbnQucGFyZW50cygnLnRvcC1iYXItcmlnaHQnKS5pcygnKicpKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgc3Vicy5hZGRDbGFzcygnb3BlbnMtbGVmdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgc3Vicy5hZGRDbGFzcygnb3BlbnMtcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Vicy5hZGRDbGFzcygnb3BlbnMtcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc1ZlcnRpY2FsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZlcnRpY2FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHRhYnMuY3NzKCdkaXNwbGF5JykgPT09ICdibG9jaycgfHwgdGhpcy4kZWxlbWVudC5jc3MoJ2ZsZXgtZGlyZWN0aW9uJykgPT09ICdjb2x1bW4nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNSdGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzUnRsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FsaWduLXJpZ2h0JykgfHwgcnRsKCkgJiYgIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2FsaWduLWxlZnQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gZWxlbWVudHMgd2l0aGluIHRoZSBtZW51XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgaGFzVG91Y2ggPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgfHwgdHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09ICd1bmRlZmluZWQnLFxuICAgICAgICAgIHBhckNsYXNzID0gJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JzsgLy8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXG5cblxuICAgICAgdmFyIGhhbmRsZUNsaWNrRm4gPSBmdW5jdGlvbiBoYW5kbGVDbGlja0ZuKGUpIHtcbiAgICAgICAgdmFyICRlbGVtID0gJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsIFwiLlwiLmNvbmNhdChwYXJDbGFzcykpLFxuICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpLFxuICAgICAgICAgICAgaGFzQ2xpY2tlZCA9ICRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgJHN1YiA9ICRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpO1xuXG4gICAgICAgIGlmIChoYXNTdWIpIHtcbiAgICAgICAgICBpZiAoaGFzQ2xpY2tlZCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCAhX3RoaXMub3B0aW9ucy5jbGlja09wZW4gJiYgIWhhc1RvdWNoIHx8IF90aGlzLm9wdGlvbnMuZm9yY2VGb2xsb3cgJiYgaGFzVG91Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9zaG93KCRzdWIpO1xuXG4gICAgICAgICAgICAkZWxlbS5hZGQoJGVsZW0ucGFyZW50c1VudGlsKF90aGlzLiRlbGVtZW50LCBcIi5cIi5jb25jYXQocGFyQ2xhc3MpKSkuYXR0cignZGF0YS1pcy1jbGljaycsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4gfHwgaGFzVG91Y2gpIHtcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdjbGljay56Zi5kcm9wZG93bk1lbnUgdG91Y2hzdGFydC56Zi5kcm9wZG93bk1lbnUnLCBoYW5kbGVDbGlja0ZuKTtcbiAgICAgIH0gLy8gSGFuZGxlIExlYWYgZWxlbWVudCBDbGlja3NcblxuXG4gICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2tJbnNpZGUpIHtcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdjbGljay56Zi5kcm9wZG93bk1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcblxuICAgICAgICAgIGlmICghaGFzU3ViKSB7XG4gICAgICAgICAgICBfdGhpcy5faGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xuICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd25NZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XG5cbiAgICAgICAgICBpZiAoaGFzU3ViKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xuICAgICAgICAgICAgJGVsZW0uZGF0YSgnX2RlbGF5Jywgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd25NZW51JywgaWdub3JlTW91c2VkaXNhcHBlYXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XG5cbiAgICAgICAgICBpZiAoaGFzU3ViICYmIF90aGlzLm9wdGlvbnMuYXV0b2Nsb3NlKSB7XG4gICAgICAgICAgICBpZiAoJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScgJiYgX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xuICAgICAgICAgICAgJGVsZW0uZGF0YSgnX2RlbGF5Jywgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2xvc2luZ1RpbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdrZXlkb3duLnpmLmRyb3Bkb3duTWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnW3JvbGU9XCJub25lXCJdJyksXG4gICAgICAgICAgICBpc1RhYiA9IF90aGlzLiR0YWJzLmluZGV4KCRlbGVtZW50KSA+IC0xLFxuICAgICAgICAgICAgJGVsZW1lbnRzID0gaXNUYWIgPyBfdGhpcy4kdGFicyA6ICRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSAtIDEpO1xuICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkgKyAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGZ1bmN0aW9uIG5leHRTaWJsaW5nKCkge1xuICAgICAgICAgICRuZXh0RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICAgICAgcHJldlNpYmxpbmcgPSBmdW5jdGlvbiBwcmV2U2libGluZygpIHtcbiAgICAgICAgICAkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgICAgIG9wZW5TdWIgPSBmdW5jdGlvbiBvcGVuU3ViKCkge1xuICAgICAgICAgIHZhciAkc3ViID0gJGVsZW1lbnQuY2hpbGRyZW4oJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcblxuICAgICAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3coJHN1Yik7XG5cbiAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJ2xpID4gYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZVN1YiA9IGZ1bmN0aW9uIGNsb3NlU3ViKCkge1xuICAgICAgICAgIC8vaWYgKCRlbGVtZW50LmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xuICAgICAgICAgIHZhciBjbG9zZSA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJyk7XG4gICAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xuXG4gICAgICAgICAgX3RoaXMuX2hpZGUoY2xvc2UpO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvL31cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZnVuY3Rpb25zID0ge1xuICAgICAgICAgIG9wZW46IG9wZW5TdWIsXG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgX3RoaXMuX2hpZGUoX3RoaXMuJGVsZW1lbnQpO1xuXG4gICAgICAgICAgICBfdGhpcy4kbWVudUl0ZW1zLmVxKDApLmNoaWxkcmVuKCdhJykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuXG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzVGFiKSB7XG4gICAgICAgICAgaWYgKF90aGlzLl9pc1ZlcnRpY2FsKCkpIHtcbiAgICAgICAgICAgIC8vIHZlcnRpY2FsIG1lbnVcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNSdGwoKSkge1xuICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXG4gICAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICBuZXh0OiBjbG9zZVN1YixcbiAgICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcbiAgICAgICAgICAgICAgICBwcmV2aW91czogY2xvc2VTdWJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhvcml6b250YWwgbWVudVxuICAgICAgICAgICAgaWYgKF90aGlzLl9pc1J0bCgpKSB7XG4gICAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgbmV4dDogcHJldlNpYmxpbmcsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGRvd246IG9wZW5TdWIsXG4gICAgICAgICAgICAgICAgdXA6IGNsb3NlU3ViXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXG4gICAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICBkb3duOiBvcGVuU3ViLFxuICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm90IHRhYnMgLT4gb25lIHN1YlxuICAgICAgICAgIGlmIChfdGhpcy5faXNSdGwoKSkge1xuICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxuICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxuICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YixcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGxlZnQgYWxpZ25lZFxuICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YixcbiAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcm9wZG93bk1lbnUnLCBmdW5jdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRCb2R5SGFuZGxlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQm9keUhhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICAgICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIoKTtcblxuICAgICAgJGJvZHkub24oJ2NsaWNrLnpmLmRyb3Bkb3duTWVudSB0YXAuemYuZHJvcGRvd25NZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGlzSXRzZWxmID0gISEkKGUudGFyZ2V0KS5jbG9zZXN0KF90aGlzMi4kZWxlbWVudCkubGVuZ3RoO1xuICAgICAgICBpZiAoaXNJdHNlbGYpIHJldHVybjtcblxuICAgICAgICBfdGhpczIuX2hpZGUoKTtcblxuICAgICAgICBfdGhpczIuX3JlbW92ZUJvZHlIYW5kbGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBib2R5IGV2ZW50IGhhbmRsZXIuIFNlZSBgX2FkZEJvZHlIYW5kbGVyYC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUJvZHlIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVCb2R5SGFuZGxlcigpIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKCdjbGljay56Zi5kcm9wZG93bk1lbnUgdGFwLnpmLmRyb3Bkb3duTWVudScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBhIGRyb3Bkb3duIHBhbmUsIGFuZCBjaGVja3MgZm9yIGNvbGxpc2lvbnMgZmlyc3QuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRzdWIgLSB1bCBlbGVtZW50IHRoYXQgaXMgYSBzdWJtZW51IHRvIHNob3dcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjc2hvd1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coJHN1Yikge1xuICAgICAgdmFyIGlkeCA9IHRoaXMuJHRhYnMuaW5kZXgodGhpcy4kdGFicy5maWx0ZXIoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgIHJldHVybiAkKGVsKS5maW5kKCRzdWIpLmxlbmd0aCA+IDA7XG4gICAgICB9KSk7XG4gICAgICB2YXIgJHNpYnMgPSAkc3ViLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5zaWJsaW5ncygnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcblxuICAgICAgdGhpcy5faGlkZSgkc2licywgaWR4KTtcblxuICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuYWRkQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICB2YXIgY2xlYXIgPSBCb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcblxuICAgICAgaWYgKCFjbGVhcikge1xuICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAnLXJpZ2h0JyA6ICctbGVmdCcsXG4gICAgICAgICAgICAkcGFyZW50TGkgPSAkc3ViLnBhcmVudCgnLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XG4gICAgICAgICRwYXJlbnRMaS5yZW1vdmVDbGFzcyhcIm9wZW5zXCIuY29uY2F0KG9sZENsYXNzKSkuYWRkQ2xhc3MoXCJvcGVucy1cIi5jb25jYXQodGhpcy5vcHRpb25zLmFsaWdubWVudCkpO1xuICAgICAgICBjbGVhciA9IEJveC5JbU5vdFRvdWNoaW5nWW91KCRzdWIsIG51bGwsIHRydWUpO1xuXG4gICAgICAgIGlmICghY2xlYXIpIHtcbiAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoXCJvcGVucy1cIi5jb25jYXQodGhpcy5vcHRpb25zLmFsaWdubWVudCkpLmFkZENsYXNzKCdvcGVucy1pbm5lcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG5ldyBkcm9wZG93biBwYW5lIGlzIHZpc2libGUuXG4gICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I3Nob3dcbiAgICAgICAqL1xuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bk1lbnUnLCBbJHN1Yl0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyBhIHNpbmdsZSwgY3VycmVudGx5IG9wZW4gZHJvcGRvd24gcGFuZSwgaWYgcGFzc2VkIGEgcGFyYW1ldGVyLCBvdGhlcndpc2UsIGhpZGVzIGV2ZXJ5dGhpbmcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSAkdGFicyBjb2xsZWN0aW9uIHRvIGhpZGVcbiAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I2hpZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0sIGlkeCkge1xuICAgICAgdmFyICR0b0Nsb3NlO1xuXG4gICAgICBpZiAoJGVsZW0gJiYgJGVsZW0ubGVuZ3RoKSB7XG4gICAgICAgICR0b0Nsb3NlID0gJGVsZW07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZHggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICR0b0Nsb3NlID0gdGhpcy4kdGFicy5ub3QoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGkgPT09IGlkeDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb21ldGhpbmdUb0Nsb3NlID0gJHRvQ2xvc2UuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpIHx8ICR0b0Nsb3NlLmZpbmQoJy5pcy1hY3RpdmUnKS5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoc29tZXRoaW5nVG9DbG9zZSkge1xuICAgICAgICB2YXIgJGFjdGl2ZUl0ZW0gPSAkdG9DbG9zZS5maW5kKCdsaS5pcy1hY3RpdmUnKTtcbiAgICAgICAgJGFjdGl2ZUl0ZW0uYWRkKCR0b0Nsb3NlKS5hdHRyKHtcbiAgICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXG4gICAgICAgIH0pLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICAgJHRvQ2xvc2UuZmluZCgndWwuanMtZHJvcGRvd24tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmNoYW5nZWQgfHwgJHRvQ2xvc2UuZmluZCgnb3BlbnMtaW5uZXInKS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKS5yZW1vdmVDbGFzcyhcIm9wZW5zLWlubmVyIG9wZW5zLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSkuYWRkQ2xhc3MoXCJvcGVucy1cIi5jb25jYXQob2xkQ2xhc3MpKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCgkYWN0aXZlSXRlbS5kYXRhKCdfZGVsYXknKSk7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9wZW4gbWVudXMgYXJlIGNsb3NlZC5cbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNoaWRlXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3duTWVudScsIFskdG9DbG9zZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRtZW51SXRlbXMub2ZmKCcuemYuZHJvcGRvd25NZW51JykucmVtb3ZlQXR0cignZGF0YS1pcy1jbGljaycpLnJlbW92ZUNsYXNzKCdpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IGlzLWRvd24tYXJyb3cgb3BlbnMtcmlnaHQgb3BlbnMtbGVmdCBvcGVucy1pbm5lcicpO1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5vZmYoJy56Zi5kcm9wZG93bk1lbnUnKTtcbiAgICAgIE5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRHJvcGRvd25NZW51O1xufShQbHVnaW4pO1xuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAqL1xuXG5cbkRyb3Bkb3duTWVudS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIERpc2FsbG93cyBob3ZlciBldmVudHMgZnJvbSBvcGVuaW5nIHN1Ym1lbnVzXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gYXV0b21hdGljYWxseSBjbG9zZSBvbiBhIG1vdXNlbGVhdmUgZXZlbnQsIGlmIG5vdCBjbGlja2VkIG9wZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGF1dG9jbG9zZTogdHJ1ZSxcblxuICAvKipcbiAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTBcbiAgICovXG4gIGhvdmVyRGVsYXk6IDUwLFxuXG4gIC8qKlxuICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gb3Blbi9yZW1haW4gb3BlbiBvbiBwYXJlbnQgY2xpY2sgZXZlbnQuIEFsbG93cyBjdXJzb3IgdG8gbW92ZSBhd2F5IGZyb20gbWVudS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGNsaWNrT3BlbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGNsb3NpbmcgYSBzdWJtZW51IG9uIGEgbW91c2VsZWF2ZSBldmVudC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1MDBcbiAgICovXG4gIGNsb3NpbmdUaW1lOiA1MDAsXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHdoYXQgZGlyZWN0aW9uIHRoZSBzdWJtZW51cyBzaG91bGQgb3Blbi4gSGFuZGxlZCBieSBKUy4gQ2FuIGJlIGAnYXV0bydgLCBgJ2xlZnQnYCBvciBgJ3JpZ2h0J2AuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICBhbGlnbm1lbnQ6ICdhdXRvJyxcblxuICAvKipcbiAgICogQWxsb3cgY2xpY2tzIG9uIHRoZSBib2R5IHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93IGNsaWNrcyBvbiBsZWFmIGFuY2hvciBsaW5rcyB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xvc2VPbkNsaWNrSW5zaWRlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHZlcnRpY2FsIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYHZlcnRpY2FsYC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgKi9cbiAgdmVydGljYWxDbGFzczogJ3ZlcnRpY2FsJyxcblxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byByaWdodC1zaWRlIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYGFsaWduLXJpZ2h0YC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2FsaWduLXJpZ2h0J1xuICAgKi9cbiAgcmlnaHRDbGFzczogJ2FsaWduLXJpZ2h0JyxcblxuICAvKipcbiAgICogQm9vbGVhbiB0byBmb3JjZSBvdmVyaWRlIHRoZSBjbGlja2luZyBvZiBsaW5rcyB0byBwZXJmb3JtIGRlZmF1bHQgYWN0aW9uLCBvbiBzZWNvbmQgdG91Y2ggZXZlbnQgZm9yIG1vYmlsZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZm9yY2VGb2xsb3c6IHRydWVcbn07XG5cbi8qKlxuICogRXF1YWxpemVyIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5lcXVhbGl6ZXJcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciBpZiBlcXVhbGl6ZXIgY29udGFpbnMgaW1hZ2VzXG4gKi9cblxudmFyIEVxdWFsaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoRXF1YWxpemVyLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBFcXVhbGl6ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVxdWFsaXplcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEVxdWFsaXplcikuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXF1YWxpemVyLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIEVxdWFsaXplclxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRXF1YWxpemVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdFcXVhbGl6ZXInOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgRXF1YWxpemVyIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICB2YXIgZXFJZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1lcXVhbGl6ZXInKSB8fCAnJztcbiAgICAgIHZhciAkd2F0Y2hlZCA9IHRoaXMuJGVsZW1lbnQuZmluZChcIltkYXRhLWVxdWFsaXplci13YXRjaD1cXFwiXCIuY29uY2F0KGVxSWQsIFwiXFxcIl1cIikpO1xuXG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7XG5cbiAgICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLXJlc2l6ZScsIGVxSWQgfHwgR2V0WW9EaWdpdHMoNiwgJ2VxJykpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIGVxSWQgfHwgR2V0WW9EaWdpdHMoNiwgJ2VxJykpO1xuICAgICAgdGhpcy5oYXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xuICAgICAgdGhpcy5pc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksICdbZGF0YS1lcXVhbGl6ZXJdJykubGVuZ3RoID4gMDtcbiAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB7XG4gICAgICAgIG9uUmVzaXplTWVCb3VuZDogdGhpcy5fb25SZXNpemVNZS5iaW5kKHRoaXMpLFxuICAgICAgICBvblBvc3RFcXVhbGl6ZWRCb3VuZDogdGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcylcbiAgICAgIH07XG4gICAgICB2YXIgaW1ncyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7XG4gICAgICB2YXIgdG9vU21hbGw7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbikge1xuICAgICAgICB0b29TbWFsbCA9IHRoaXMuX2NoZWNrTVEoKTtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGVja01RLmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdG9vU21hbGwgIT09ICd1bmRlZmluZWQnICYmIHRvb1NtYWxsID09PSBmYWxzZSB8fCB0eXBlb2YgdG9vU21hbGwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChpbWdzLmxlbmd0aCkge1xuICAgICAgICAgIG9uSW1hZ2VzTG9hZGVkKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBpZiB0aGUgYnJlYWtwb2ludCBpcyB0b28gc21hbGwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wYXVzZUV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF1c2VFdmVudHMoKSB7XG4gICAgICB0aGlzLmlzT24gPSBmYWxzZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHtcbiAgICAgICAgJy56Zi5lcXVhbGl6ZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCxcbiAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQsXG4gICAgICAgICdtdXRhdGVtZS56Zi50cmlnZ2VyJzogdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyByZXNpemVtZS56Zi50cmlnZ2VyLCB3aXRoIGJvdW5kIHRoaXMgb24gX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25SZXNpemVNZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemVNZShlKSB7XG4gICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyBwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb25Qb3N0RXF1YWxpemVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBvc3RFcXVhbGl6ZWQoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbGVtZW50WzBdKSB7XG4gICAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEVxdWFsaXplci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuXG4gICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xuXG4gICAgICBpZiAodGhpcy5oYXNOZXN0ZWQpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgdGhpcy5fYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNPbiA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHNpemUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja01RXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01RKCkge1xuICAgICAgdmFyIHRvb1NtYWxsID0gIU1lZGlhUXVlcnkuaXModGhpcy5vcHRpb25zLmVxdWFsaXplT24pO1xuXG4gICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPbikge1xuICAgICAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG5cbiAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT24pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9vU21hbGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbm9vcCB2ZXJzaW9uIGZvciB0aGUgcGx1Z2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9raWxsc3dpdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9raWxsc3dpdGNoKCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBFcXVhbGl6ZXIgdXBvbiBET00gY2hhbmdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjaykge1xuICAgICAgICBpZiAodGhpcy5faXNTdGFja2VkKCkpIHtcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93KSB7XG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0c0J5Um93KHRoaXMuYXBwbHlIZWlnaHRCeVJvdy5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBkZXRlcm1pbmVzIGlmIHRoZSBmaXJzdCAyIGVsZW1lbnRzIGFyZSAqTk9UKiBzdGFja2VkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaXNTdGFja2VkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1N0YWNrZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuJHdhdGNoZWRbMF0gfHwgIXRoaXMuJHdhdGNoZWRbMV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiR3YXRjaGVkWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdGhpcy4kd2F0Y2hlZFsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBoZWlnaHRzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGVpZ2h0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWlnaHRzKGNiKSB7XG4gICAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgaGVpZ2h0cy5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY2IoaGVpZ2h0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWlnaHRzQnlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0c0J5Um93KGNiKSB7XG4gICAgICB2YXIgbGFzdEVsVG9wT2Zmc2V0ID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGggPyB0aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wIDogMCxcbiAgICAgICAgICBncm91cHMgPSBbXSxcbiAgICAgICAgICBncm91cCA9IDA7IC8vZ3JvdXAgYnkgUm93XG5cbiAgICAgIGdyb3Vwc1tncm91cF0gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7IC8vbWF5YmUgY291bGQgdXNlIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0VG9wXG5cbiAgICAgICAgdmFyIGVsT2Zmc2V0VG9wID0gJCh0aGlzLiR3YXRjaGVkW2ldKS5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgaWYgKGVsT2Zmc2V0VG9wICE9IGxhc3RFbFRvcE9mZnNldCkge1xuICAgICAgICAgIGdyb3VwKys7XG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgIGxhc3RFbFRvcE9mZnNldCA9IGVsT2Zmc2V0VG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKFt0aGlzLiR3YXRjaGVkW2ldLCB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodF0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgbG4gPSBncm91cHMubGVuZ3RoOyBqIDwgbG47IGorKykge1xuICAgICAgICB2YXIgaGVpZ2h0cyA9ICQoZ3JvdXBzW2pdKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzWzFdO1xuICAgICAgICB9KS5nZXQoKTtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuICAgICAgICBncm91cHNbal0ucHVzaChtYXgpO1xuICAgICAgfVxuXG4gICAgICBjYihncm91cHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhlaWdodHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNwcmVlcXVhbGl6ZWRcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5SGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5SGVpZ2h0KGhlaWdodHMpIHtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxuICAgICAgICovXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsIG1heCk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxuICAgICAgICovXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgQ1NTIGhlaWdodCBwcm9wZXJ0eSBvZiBlYWNoIGNoaWxkIGluIGFuIEVxdWFsaXplciBwYXJlbnQgdG8gbWF0Y2ggdGhlIHRhbGxlc3QgYnkgcm93XG4gICAgICogQHBhcmFtIHthcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNwcmVlcXVhbGl6ZWRyb3dcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRyb3dcbiAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5SGVpZ2h0QnlSb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHRCeVJvdyhncm91cHMpIHtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICAgKi9cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cHNJTGVuZ3RoID0gZ3JvdXBzW2ldLmxlbmd0aCxcbiAgICAgICAgICAgIG1heCA9IGdyb3Vwc1tpXVtncm91cHNJTGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGdyb3Vwc0lMZW5ndGggPD0gMikge1xuICAgICAgICAgICQoZ3JvdXBzW2ldWzBdWzBdKS5jc3Moe1xuICAgICAgICAgICAgJ2hlaWdodCc6ICdhdXRvJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIHBlciByb3cgYXJlIGFwcGxpZWRcbiAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkcm93XG4gICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5KID0gZ3JvdXBzSUxlbmd0aCAtIDE7IGogPCBsZW5KOyBqKyspIHtcbiAgICAgICAgICAkKGdyb3Vwc1tpXVtqXVswXSkuY3NzKHtcbiAgICAgICAgICAgICdoZWlnaHQnOiBtYXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgcGVyIHJvdyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkcm93XG4gICAgICAgICAgKi9cblxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXInKTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAgICovXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG5cbiAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFcXVhbGl6ZXI7XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5cblxuRXF1YWxpemVyLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogRW5hYmxlIGhlaWdodCBlcXVhbGl6YXRpb24gd2hlbiBzdGFja2VkIG9uIHNtYWxsZXIgc2NyZWVucy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVxdWFsaXplT25TdGFjazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHJvdyBieSByb3cuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBlcXVhbGl6ZUJ5Um93OiBmYWxzZSxcblxuICAvKipcbiAgICogU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWluaW11bSBicmVha3BvaW50IHNpemUgdGhlIHBsdWdpbiBzaG91bGQgZXF1YWxpemUgaGVpZ2h0cyBvbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgZXF1YWxpemVPbjogJydcbn07XG5cbi8qKlxuICogSW50ZXJjaGFuZ2UgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLmludGVyY2hhbmdlXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqL1xuXG52YXIgSW50ZXJjaGFuZ2UgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKEludGVyY2hhbmdlLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBJbnRlcmNoYW5nZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJjaGFuZ2UpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihJbnRlcmNoYW5nZSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJjaGFuZ2UsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBJbnRlcmNoYW5nZS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBJbnRlcmNoYW5nZVxuICAgICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBJbnRlcmNoYW5nZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9ICcnO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnSW50ZXJjaGFuZ2UnOyAvLyBpZTkgYmFjayBjb21wYXRcbiAgICAgIC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxuXG4gICAgICBUcmlnZ2Vycy5pbml0KCQpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgSW50ZXJjaGFuZ2UgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGludGVyY2hhbmdlIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEdldFlvRGlnaXRzKDYsICdpbnRlcmNoYW5nZScpO1xuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcGFyc2VPcHRpb25zKCk7XG5cbiAgICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzKCk7XG5cbiAgICAgIHRoaXMuX2dlbmVyYXRlUnVsZXMoKTtcblxuICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgSW50ZXJjaGFuZ2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fcmVmbG93KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgSW50ZXJjaGFuZ2UgdXBvbiBET00gY2hhbmdlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZsb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcbiAgICAgIHZhciBtYXRjaDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSwgYnV0IG9ubHkgc2F2ZSB0aGUgbGFzdCBtYXRjaFxuXG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucnVsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XG5cbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocnVsZS5xdWVyeSkubWF0Y2hlcykge1xuICAgICAgICAgICAgbWF0Y2ggPSBydWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBvcHRpb25zIHZhbGlmaXR5IGFuZCBzZXQgZGVmYXVsdHMgZm9yOlxuICAgICAqIC0gYGRhdGEtaW50ZXJjaGFuZ2UtdHlwZWA6IGlmIHNldCwgZW5mb3JjZSB0aGUgdHlwZSBvZiByZXBsYWNlbWVudCAoYXV0bywgc3JjLCBiYWNrZ3JvdW5kIG9yIGh0bWwpXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wYXJzZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlT3B0aW9ucygpIHtcbiAgICAgIHZhciB0eXBlcyA9IFsnYXV0bycsICdzcmMnLCAnYmFja2dyb3VuZCcsICdodG1sJ107XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy50eXBlID09PSAndW5kZWZpbmVkJykgdGhpcy5vcHRpb25zLnR5cGUgPSAnYXV0byc7ZWxzZSBpZiAodHlwZXMuaW5kZXhPZih0aGlzLm9wdGlvbnMudHlwZSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogaW52YWxpZCB2YWx1ZSBcXFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy50eXBlLCBcIlxcXCIgZm9yIEludGVyY2hhbmdlIG9wdGlvbiBcXFwidHlwZVxcXCJcIikpO1xuICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9ICdhdXRvJztcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQnJlYWtwb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJyZWFrcG9pbnRzKCkge1xuICAgICAgZm9yICh2YXIgaSBpbiBNZWRpYVF1ZXJ5LnF1ZXJpZXMpIHtcbiAgICAgICAgaWYgKE1lZGlhUXVlcnkucXVlcmllcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHZhciBxdWVyeSA9IE1lZGlhUXVlcnkucXVlcmllc1tpXTtcbiAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXG4gICAgICogQHJldHVybnMge0FycmF5fSBzY2VuYXJpb3MgLSBBcnJheSBvZiBvYmplY3RzIHRoYXQgaGF2ZSAnbXEnIGFuZCAncGF0aCcga2V5cyB3aXRoIGNvcnJlc3BvbmRpbmcga2V5c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dlbmVyYXRlUnVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlUnVsZXMoZWxlbWVudCkge1xuICAgICAgdmFyIHJ1bGVzTGlzdCA9IFtdO1xuICAgICAgdmFyIHJ1bGVzO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJ1bGVzKSB7XG4gICAgICAgIHJ1bGVzID0gdGhpcy5vcHRpb25zLnJ1bGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2ludGVyY2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIHJ1bGVzID0gdHlwZW9mIHJ1bGVzID09PSAnc3RyaW5nJyA/IHJ1bGVzLm1hdGNoKC9cXFsuKj8sIC4qP1xcXS9nKSA6IHJ1bGVzO1xuXG4gICAgICBmb3IgKHZhciBpIGluIHJ1bGVzKSB7XG4gICAgICAgIGlmIChydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsICcpO1xuICAgICAgICAgIHZhciBwYXRoID0gcnVsZS5zbGljZSgwLCAtMSkuam9pbignJyk7XG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gcnVsZVtydWxlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFU1txdWVyeV0pIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBydWxlc0xpc3QucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzTGlzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIHRoZSBpbWFnZSBvciBIVE1MIHBhcnRpYWwuXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoID09PSBwYXRoKSByZXR1cm47XG4gICAgICB2YXIgdHJpZ2dlciA9ICdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZSc7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMub3B0aW9ucy50eXBlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lID09PSAnSU1HJykgdHlwZSA9ICdzcmMnO2Vsc2UgaWYgKHBhdGgubWF0Y2goL1xcLihnaWZ8anBlP2d8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKSkgdHlwZSA9ICdiYWNrZ3JvdW5kJztlbHNlIHR5cGUgPSAnaHRtbCc7XG4gICAgICB9IC8vIFJlcGxhY2luZyBpbWFnZXNcblxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NyYycpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdzcmMnLCBwYXRoKS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuY3VycmVudFBhdGggPSBwYXRoO1xuICAgICAgICB9KS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgfSAvLyBSZXBsYWNpbmcgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcKC9nLCAnJTI4JykucmVwbGFjZSgvXFwpL2csICclMjknKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoJyArIHBhdGggKyAnKSdcbiAgICAgICAgICB9KS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgICB9IC8vIFJlcGxhY2luZyBIVE1MXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdodG1sJykge1xuICAgICAgICAgICAgJC5nZXQocGF0aCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC5odG1sKHJlc3BvbnNlKS50cmlnZ2VyKHRyaWdnZXIpO1xuXG4gICAgICAgICAgICAgICQocmVzcG9uc2UpLmZvdW5kYXRpb24oKTtcbiAgICAgICAgICAgICAgX3RoaXMyLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiBjb250ZW50IGluIGFuIEludGVyY2hhbmdlIGVsZW1lbnQgaXMgZG9uZSBiZWluZyBsb2FkZWQuXG4gICAgICAgKiBAZXZlbnQgSW50ZXJjaGFuZ2UjcmVwbGFjZWRcbiAgICAgICAqL1xuICAgICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZScpO1xuXG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGludGVyY2hhbmdlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcmNoYW5nZTtcbn0oUGx1Z2luKTtcbi8qKlxuICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gKi9cblxuXG5JbnRlcmNoYW5nZS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUgez9hcnJheX1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgcnVsZXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIFR5cGUgb2YgdGhlIHJlc3BvbnNpdmUgcmVzc291cmNlIHRvIHJlcGxhY2UuIEl0IGNhbiB0YWtlIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcbiAgICogLSBgYXV0b2AgKGRlZmF1bHQpOiBjaG9vc2UgdGhlIHR5cGUgYWNjb3JkaW5nIHRvIHRoZSBlbGVtZW50IHRhZyBvciB0aGUgcmVzc291cmNlIGV4dGVuc2lvbixcbiAgICogLSBgc3JjYDogcmVwbGFjZSB0aGUgYFtzcmNdYCBhdHRyaWJ1dGUsIHJlY29tbWVuZGVkIGZvciBpbWFnZXMgYDxpbWc+YC5cbiAgICogLSBgYmFja2dyb3VuZGA6IHJlcGxhY2UgdGhlIGBiYWNrZ3JvdW5kLWltYWdlYCBDU1MgcHJvcGVydHkuXG4gICAqIC0gYGh0bWxgOiByZXBsYWNlIHRoZSBlbGVtZW50IGNvbnRlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICB0eXBlOiAnYXV0bydcbn07XG5JbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgPSB7XG4gICdsYW5kc2NhcGUnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAncG9ydHJhaXQnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KScsXG4gICdyZXRpbmEnOiAnb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xufTtcblxuLyoqXG4gKiBTbW9vdGhTY3JvbGwgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNtb290aFNjcm9sbFxuICovXG5cbnZhciBTbW9vdGhTY3JvbGwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFNtb290aFNjcm9sbCwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gU21vb3RoU2Nyb2xsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbW9vdGhTY3JvbGwpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTbW9vdGhTY3JvbGwpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNtb290aFNjcm9sbCwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFNtb290aFNjcm9sbC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBTbW9vdGhTY3JvbGxcbiAgICAgKiBAZmlyZXMgU21vb3RoU2Nyb2xsI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFNtb290aFNjcm9sbC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU21vb3RoU2Nyb2xsJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgU21vb3RoU2Nyb2xsIHBsdWdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgR2V0WW9EaWdpdHMoNiwgJ3Ntb290aC1zY3JvbGwnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIFNtb290aFNjcm9sbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdGhpcy5fbGlua0NsaWNrTGlzdGVuZXIgPSB0aGlzLl9oYW5kbGVMaW5rQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLnpmLnNtb290aFNjcm9sbCcsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2NsaWNrLnpmLnNtb290aFNjcm9sbCcsICdhW2hyZWZePVwiI1wiXScsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBnaXZlbiBldmVudCB0byBzbW9vdGhseSBzY3JvbGwgdG8gdGhlIGFuY2hvciBwb2ludGVkIGJ5IHRoZSBldmVudCB0YXJnZXQuXG4gICAgICogQHBhcmFtIHsqfSBlIC0gZXZlbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUxpbmtDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlTGlua0NsaWNrKGUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIEZvbGxvdyB0aGUgbGluayBpZiBpdCBkb2VzIG5vdCBwb2ludCB0byBhbiBhbmNob3IuXG4gICAgICBpZiAoISQoZS5jdXJyZW50VGFyZ2V0KS5pcygnYVtocmVmXj1cIiNcIl0nKSkgcmV0dXJuO1xuICAgICAgdmFyIGFycml2YWwgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICB0aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgU21vb3RoU2Nyb2xsLnNjcm9sbFRvTG9jKGFycml2YWwsIHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5faW5UcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTbW9vdGhTY3JvbGwgaW5zdGFuY2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2NsaWNrLnpmLnNtb290aFNjcm9sbCcsIHRoaXMuX2xpbmtDbGlja0xpc3RlbmVyKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbW9vdGhTY3JvbGwnLCAnYVtocmVmXj1cIiNcIl0nLCB0aGlzLl9saW5rQ2xpY2tMaXN0ZW5lcik7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwic2Nyb2xsVG9Mb2NcIixcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBBIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogU21vb3RoU2Nyb2xsLmRlZmF1bHRzO1xuICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgJGxvYyA9ICQobG9jKTsgLy8gRG8gbm90aGluZyBpZiB0YXJnZXQgZG9lcyBub3QgZXhpc3QgdG8gcHJldmVudCBlcnJvcnNcblxuICAgICAgaWYgKCEkbG9jLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHNjcm9sbFBvcyA9IE1hdGgucm91bmQoJGxvYy5vZmZzZXQoKS50b3AgLSBvcHRpb25zLnRocmVzaG9sZCAvIDIgLSBvcHRpb25zLm9mZnNldCk7XG4gICAgICAkKCdodG1sLCBib2R5Jykuc3RvcCh0cnVlKS5hbmltYXRlKHtcbiAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxQb3NcbiAgICAgIH0sIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU21vb3RoU2Nyb2xsO1xufShQbHVnaW4pO1xuLyoqXG4gKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW4uXG4gKi9cblxuXG5TbW9vdGhTY3JvbGwuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTAwXG4gICAqL1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gc3R5bGUgdG8gdXNlIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gbG9jYXRpb25zLiBDYW4gYmUgYCdzd2luZydgIG9yIGAnbGluZWFyJ2AuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2xpbmVhcidcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxuICAgKi9cbiAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTBcbiAgICovXG4gIHRocmVzaG9sZDogNTAsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IHRoZSBzY3JvbGwgb2YgdGhlIHBhZ2Ugb24gaXRlbSBjbGljayBpZiB1c2luZyBhIHN0aWNreSBuYXYgYmFyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIG9mZnNldDogMFxufTtcblxuLyoqXG4gKiBNYWdlbGxhbiBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ubWFnZWxsYW5cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnNtb290aFNjcm9sbFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICovXG5cbnZhciBNYWdlbGxhbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoTWFnZWxsYW4sIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIE1hZ2VsbGFuKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYWdlbGxhbik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE1hZ2VsbGFuKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYWdlbGxhbiwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIE1hZ2VsbGFuLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIE1hZ2VsbGFuXG4gICAgICogQGZpcmVzIE1hZ2VsbGFuI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIE1hZ2VsbGFuLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdNYWdlbGxhbic7IC8vIGllOSBiYWNrIGNvbXBhdFxuICAgICAgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNYWdlbGxhbiBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBHZXRZb0RpZ2l0cyg2LCAnbWFnZWxsYW4nKTtcblxuICAgICAgdGhpcy4kdGFyZ2V0cyA9ICQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTtcbiAgICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICAgIHRoaXMuc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGFuIGFycmF5IG9mIHBpeGVsIHZhbHVlcyB0aGF0IGFyZSB0aGUgZGVtYXJjYXRpb24gbGluZXMgYmV0d2VlbiBsb2NhdGlvbnMgb24gdGhlIHBhZ2UuXG4gICAgICogQ2FuIGJlIGludm9rZWQgaWYgbmV3IGVsZW1lbnRzIGFyZSBhZGRlZCBvciB0aGUgc2l6ZSBvZiBhIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjYWxjUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQb2ludHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICB0aGlzLndpbkhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCkpO1xuICAgICAgdGhpcy5kb2NIZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCkpO1xuICAgICAgdGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0YXIgPSAkKHRoaXMpLFxuICAgICAgICAgICAgcHQgPSBNYXRoLnJvdW5kKCR0YXIub2Zmc2V0KCkudG9wIC0gX3RoaXMub3B0aW9ucy50aHJlc2hvbGQpO1xuICAgICAgICAkdGFyLnRhcmdldFBvaW50ID0gcHQ7XG5cbiAgICAgICAgX3RoaXMucG9pbnRzLnB1c2gocHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgTWFnZWxsYW4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICQod2luZG93KS5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGxvY2F0aW9uLmhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmNhbGNQb2ludHMoKTtcblxuICAgICAgICBfdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gICAgICB9KTtcbiAgICAgIF90aGlzLm9uTG9hZExpc3RlbmVyID0gb25Mb2FkKCQod2luZG93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiBfdGhpcy5yZWZsb3cuYmluZChfdGhpcyksXG4gICAgICAgICAgJ3Njcm9sbG1lLnpmLnRyaWdnZXInOiBfdGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQoX3RoaXMpXG4gICAgICAgIH0pLm9uKCdjbGljay56Zi5tYWdlbGxhbicsICdhW2hyZWZePVwiI1wiXScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHZhciBhcnJpdmFsID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblxuICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGFycml2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWVwTGlua1Njcm9sbCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2Mod2luZG93LmxvY2F0aW9uLmhhc2gpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9kZWVwTGlua1Njcm9sbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBhIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2Nyb2xsVG9Mb2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2Nyb2xsVG9Mb2MobG9jKSB7XG4gICAgICB0aGlzLl9pblRyYW5zaXRpb24gPSB0cnVlO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMub3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICAgIG9mZnNldDogdGhpcy5vcHRpb25zLm9mZnNldFxuICAgICAgfTtcbiAgICAgIFNtb290aFNjcm9sbC5zY3JvbGxUb0xvYyhsb2MsIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2luVHJhbnNpdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIE1hZ2VsbGFuIHVwb24gRE9NIGNoYW5nZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZmxvdygpIHtcbiAgICAgIHRoaXMuY2FsY1BvaW50cygpO1xuXG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVBY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFjdGl2ZSgpXG4gICAgLypldnQsIGVsZW0sIHNjcm9sbFBvcyovXG4gICAge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pblRyYW5zaXRpb24pIHJldHVybjtcbiAgICAgIHZhciBuZXdTY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKTtcbiAgICAgIHZhciBpc1Njcm9sbGluZ1VwID0gdGhpcy5zY3JvbGxQb3MgPiBuZXdTY3JvbGxQb3M7XG4gICAgICB0aGlzLnNjcm9sbFBvcyA9IG5ld1Njcm9sbFBvcztcbiAgICAgIHZhciBhY3RpdmVJZHg7IC8vIEJlZm9yZSB0aGUgZmlyc3QgcG9pbnQ6IG5vIGxpbmtcblxuICAgICAgaWYgKG5ld1Njcm9sbFBvcyA8IHRoaXMucG9pbnRzWzBdKSA7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICAvLyBBdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlOiBsYXN0IGxpbmtcbiAgICAgIGVsc2UgaWYgKG5ld1Njcm9sbFBvcyArIHRoaXMud2luSGVpZ2h0ID09PSB0aGlzLmRvY0hlaWdodCkge1xuICAgICAgICAgIGFjdGl2ZUlkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0gLy8gT3RoZXJ3aGlzZSwgdXNlIHRoZSBsYXN0IHZpc2libGUgbGlua1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlTGlua3MgPSB0aGlzLnBvaW50cy5maWx0ZXIoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHAgLSBfdGhpczIub3B0aW9ucy5vZmZzZXQgLSAoaXNTY3JvbGxpbmdVcCA/IF90aGlzMi5vcHRpb25zLnRocmVzaG9sZCA6IDApIDw9IG5ld1Njcm9sbFBvcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWN0aXZlSWR4ID0gdmlzaWJsZUxpbmtzLmxlbmd0aCA/IHZpc2libGVMaW5rcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB9IC8vIEdldCB0aGUgbmV3IGFjdGl2ZSBsaW5rXG5cblxuICAgICAgdmFyICRvbGRBY3RpdmUgPSB0aGlzLiRhY3RpdmU7XG4gICAgICB2YXIgYWN0aXZlSGFzaCA9ICcnO1xuXG4gICAgICBpZiAodHlwZW9mIGFjdGl2ZUlkeCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cIiMnICsgdGhpcy4kdGFyZ2V0cy5lcShhY3RpdmVJZHgpLmRhdGEoJ21hZ2VsbGFuLXRhcmdldCcpICsgJ1wiXScpO1xuICAgICAgICBpZiAodGhpcy4kYWN0aXZlLmxlbmd0aCkgYWN0aXZlSGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzTmV3QWN0aXZlID0gISghdGhpcy4kYWN0aXZlLmxlbmd0aCAmJiAhJG9sZEFjdGl2ZS5sZW5ndGgpICYmICF0aGlzLiRhY3RpdmUuaXMoJG9sZEFjdGl2ZSk7XG4gICAgICB2YXIgaXNOZXdIYXNoID0gYWN0aXZlSGFzaCAhPT0gd2luZG93LmxvY2F0aW9uLmhhc2g7IC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGxpbmsgZWxlbWVudFxuXG4gICAgICBpZiAoaXNOZXdBY3RpdmUpIHtcbiAgICAgICAgJG9sZEFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICB0aGlzLiRhY3RpdmUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICAgIH0gLy8gVXBkYXRlIHRoZSBoYXNoIChpdCBtYXkgaGF2ZSBjaGFuZ2VkIHdpdGggdGhlIHNhbWUgYWN0aXZlIGxpbmspXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyAmJiBpc05ld0hhc2gpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xuICAgICAgICAgIC8vIFNldCBvciByZW1vdmUgdGhlIGhhc2ggKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyOTg2ODQvNDMxNzM4NFxuICAgICAgICAgIHZhciB1cmwgPSBhY3RpdmVIYXNoID8gYWN0aXZlSGFzaCA6IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSArIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJycsIHVybCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gYWN0aXZlSGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNOZXdBY3RpdmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gbWFnZWxsYW4gaXMgZmluaXNoZWQgdXBkYXRpbmcgdG8gdGhlIG5ldyBhY3RpdmUgZWxlbWVudC5cbiAgICAgICAgICogQGV2ZW50IE1hZ2VsbGFuI3VwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLCBbdGhpcy4kYWN0aXZlXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIE1hZ2VsbGFuIGFuZCByZXNldHMgdGhlIHVybCBvZiB0aGUgd2luZG93LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm1hZ2VsbGFuJykuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xuICAgICAgICB2YXIgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZShoYXNoLCAnJyk7XG4gICAgICB9XG5cbiAgICAgICQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9kZWVwTGlua1Njcm9sbCk7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFnZWxsYW47XG59KFBsdWdpbik7XG4vKipcbiAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICovXG5cblxuTWFnZWxsYW4uZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIHRoZSBhbmltYXRlZCBzY3JvbGxpbmcgc2hvdWxkIHRha2UgYmV0d2VlbiBsb2NhdGlvbnMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTAwXG4gICAqL1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuXG4gIC8qKlxuICAgKiBBbmltYXRpb24gc3R5bGUgdG8gdXNlIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gbG9jYXRpb25zLiBDYW4gYmUgYCdzd2luZydgIG9yIGAnbGluZWFyJ2AuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2xpbmVhcidcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxuICAgKi9cbiAgYW5pbWF0aW9uRWFzaW5nOiAnbGluZWFyJyxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTBcbiAgICovXG4gIHRocmVzaG9sZDogNTAsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXG4gICAqL1xuICBhY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgc2NyaXB0IHRvIG1hbmlwdWxhdGUgdGhlIHVybCBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgaWYgc3VwcG9ydGVkLCBhbHRlciB0aGUgaGlzdG9yeS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZXBMaW5raW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgYWN0aXZlIGxpbmssIGlmIGRlZXAgbGlua2luZyBpcyBlbmFibGVkLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IHRoZSBzY3JvbGwgb2YgdGhlIHBhZ2Ugb24gaXRlbSBjbGljayBpZiB1c2luZyBhIHN0aWNreSBuYXYgYmFyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIG9mZnNldDogMFxufTtcblxuLyoqXG4gKiBPZmZDYW52YXMgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm9mZkNhbnZhc1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gKi9cblxudmFyIE9mZkNhbnZhcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoT2ZmQ2FudmFzLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBPZmZDYW52YXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9mZkNhbnZhcyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE9mZkNhbnZhcykuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT2ZmQ2FudmFzLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2ZmLWNhbnZhcyB3cmFwcGVyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIE9mZkNhbnZhc1xuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBpbml0aWFsaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdPZmZDYW52YXMnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNvbnRlbnRDbGFzc2VzID0ge1xuICAgICAgICBiYXNlOiBbXSxcbiAgICAgICAgcmV2ZWFsOiBbXVxuICAgICAgfTtcbiAgICAgIHRoaXMuJGxhc3RUcmlnZ2VyID0gJCgpO1xuICAgICAgdGhpcy4kdHJpZ2dlcnMgPSAkKCk7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gJ2xlZnQnO1xuICAgICAgdGhpcy4kY29udGVudCA9ICQoKTtcbiAgICAgIHRoaXMubmVzdGVkID0gISF0aGlzLm9wdGlvbnMubmVzdGVkO1xuICAgICAgdGhpcy4kc3RpY2t5ID0gJCgpO1xuICAgICAgdGhpcy5pc0luQ2FudmFzID0gZmFsc2U7IC8vIERlZmluZXMgdGhlIENTUyB0cmFuc2l0aW9uL3Bvc2l0aW9uIGNsYXNzZXMgb2YgdGhlIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIuXG5cbiAgICAgICQoWydwdXNoJywgJ292ZXJsYXAnXSkuZWFjaChmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xuICAgICAgICBfdGhpczIuY29udGVudENsYXNzZXMuYmFzZS5wdXNoKCdoYXMtdHJhbnNpdGlvbi0nICsgdmFsKTtcbiAgICAgIH0pO1xuICAgICAgJChbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgdmFsKSB7XG4gICAgICAgIF90aGlzMi5jb250ZW50Q2xhc3Nlcy5iYXNlLnB1c2goJ2hhcy1wb3NpdGlvbi0nICsgdmFsKTtcblxuICAgICAgICBfdGhpczIuY29udGVudENsYXNzZXMucmV2ZWFsLnB1c2goJ2hhcy1yZXZlYWwtJyArIHZhbCk7XG4gICAgICB9KTsgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIE1lZGlhUXVlcnkuX2luaXQoKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ09mZkNhbnZhcycsIHtcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpOyAvLyBGaW5kIG9mZi1jYW52YXMgY29udGVudCwgZWl0aGVyIGJ5IElEIChpZiBzcGVjaWZpZWQpLCBieSBzaWJsaW5ncyBvciBieSBjbG9zZXN0IHNlbGVjdG9yIChmYWxsYmFjaylcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50SWQpIHtcbiAgICAgICAgdGhpcy4kY29udGVudCA9ICQoJyMnICsgdGhpcy5vcHRpb25zLmNvbnRlbnRJZCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4kY29udGVudCA9IHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5maXJzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kY29udGVudCA9IHRoaXMuJGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmZpcnN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnRlbnRJZCkge1xuICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIG5lc3RlZCBpZiBpdCBpc24ndCBhIHNpYmxpbmcgb2YgdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykubGVuZ3RoID09PSAwO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY29udGVudElkICYmIHRoaXMub3B0aW9ucy5uZXN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gV2FybmluZyBpZiB1c2luZyBjb250ZW50IElEIHdpdGhvdXQgc2V0dGluZyB0aGUgbmVzdGVkIG9wdGlvblxuICAgICAgICAvLyBPbmNlIHRoZSBlbGVtZW50IGlzIG5lc3RlZCBpdCBpcyByZXF1aXJlZCB0byB3b3JrIHByb3Blcmx5IGluIHRoaXMgY2FzZVxuICAgICAgICBjb25zb2xlLndhcm4oJ1JlbWVtYmVyIHRvIHVzZSB0aGUgbmVzdGVkIG9wdGlvbiBpZiB1c2luZyB0aGUgY29udGVudCBJRCBvcHRpb24hJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5lc3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBGb3JjZSB0cmFuc2l0aW9uIG92ZXJsYXAgaWYgbmVzdGVkXG4gICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uID0gJ292ZXJsYXAnOyAvLyBSZW1vdmUgYXBwcm9wcmlhdGUgY2xhc3NlcyBpZiBhbHJlYWR5IGFzc2lnbmVkIGluIG1hcmt1cFxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLXRyYW5zaXRpb24tcHVzaCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiaXMtdHJhbnNpdGlvbi1cIi5jb25jYXQodGhpcy5vcHRpb25zLnRyYW5zaXRpb24sIFwiIGlzLWNsb3NlZFwiKSk7IC8vIEZpbmQgdHJpZ2dlcnMgdGhhdCBhZmZlY3QgdGhpcyBlbGVtZW50IGFuZCBhZGQgYXJpYS1leHBhbmRlZCB0byB0aGVtXG5cbiAgICAgIHRoaXMuJHRyaWdnZXJzID0gJChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cIicgKyBpZCArICdcIl0sIFtkYXRhLWNsb3NlPVwiJyArIGlkICsgJ1wiXSwgW2RhdGEtdG9nZ2xlPVwiJyArIGlkICsgJ1wiXScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKS5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpOyAvLyBHZXQgcG9zaXRpb24gYnkgY2hlY2tpbmcgZm9yIHJlbGF0ZWQgQ1NTIGNsYXNzXG5cbiAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLiRlbGVtZW50LmlzKCcucG9zaXRpb24tbGVmdCwgLnBvc2l0aW9uLXRvcCwgLnBvc2l0aW9uLXJpZ2h0LCAucG9zaXRpb24tYm90dG9tJykgPyB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3Bvc2l0aW9uXFwtKGxlZnR8dG9wfHJpZ2h0fGJvdHRvbSkvKVsxXSA6IHRoaXMucG9zaXRpb247IC8vIEFkZCBhbiBvdmVybGF5IG92ZXIgdGhlIGNvbnRlbnQgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdmFyIG92ZXJsYXlQb3NpdGlvbiA9ICQodGhpcy4kZWxlbWVudCkuY3NzKFwicG9zaXRpb25cIikgPT09ICdmaXhlZCcgPyAnaXMtb3ZlcmxheS1maXhlZCcgOiAnaXMtb3ZlcmxheS1hYnNvbHV0ZSc7XG4gICAgICAgIG92ZXJsYXkuc2V0QXR0cmlidXRlKCdjbGFzcycsICdqcy1vZmYtY2FudmFzLW92ZXJsYXkgJyArIG92ZXJsYXlQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSAkKG92ZXJsYXkpO1xuXG4gICAgICAgIGlmIChvdmVybGF5UG9zaXRpb24gPT09ICdpcy1vdmVybGF5LWZpeGVkJykge1xuICAgICAgICAgICQodGhpcy4kb3ZlcmxheSkuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kY29udGVudC5hcHBlbmQodGhpcy4kb3ZlcmxheSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gR2V0IHRoZSByZXZlYWxPbiBvcHRpb24gZnJvbSB0aGUgY2xhc3MuXG5cblxuICAgICAgdmFyIHJldmVhbE9uUmVnRXhwID0gbmV3IFJlZ0V4cChSZWdFeHBFc2NhcGUodGhpcy5vcHRpb25zLnJldmVhbENsYXNzKSArICcoW15cXFxcc10rKScsICdnJyk7XG4gICAgICB2YXIgcmV2ZWFsT25DbGFzcyA9IHJldmVhbE9uUmVnRXhwLmV4ZWModGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUpO1xuXG4gICAgICBpZiAocmV2ZWFsT25DbGFzcykge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXZlYWxPbiA9IHRoaXMub3B0aW9ucy5yZXZlYWxPbiB8fCByZXZlYWxPbkNsYXNzWzFdO1xuICAgICAgfSAvLyBFbnN1cmUgdGhlIGByZXZlYWwtb24tKmAgY2xhc3MgaXMgc2V0LlxuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMucmV2ZWFsT24pIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maXJzdCgpLmFkZENsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcykuY29uY2F0KHRoaXMub3B0aW9ucy5yZXZlYWxPbikpO1xuXG4gICAgICAgIHRoaXMuX3NldE1RQ2hlY2tlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKTtcbiAgICAgIH0gLy8gRmluZCBmaXhlZCBlbGVtZW50cyB0aGF0IHNob3VsZCBzdGF5IGZpeGVkIHdoaWxlIG9mZi1jYW52YXMgaXMgb3BlbmVkXG5cblxuICAgICAgdGhpcy4kc3RpY2t5ID0gdGhpcy4kY29udGVudC5maW5kKCdbZGF0YS1vZmYtY2FudmFzLXN0aWNreV0nKTtcblxuICAgICAgaWYgKHRoaXMuJHN0aWNreS5sZW5ndGggPiAwICYmIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uID09PSAncHVzaCcpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgbWF0Y2ggZm9yY2UgY29udGVudFNjcm9sbDpmYWxzZSBiZWNhdXNlIHRoZSBhYnNvbHV0ZSB0b3AgdmFsdWUgZG9lc24ndCBnZXQgcmVjYWxjdWxhdGVkIG9uIHNjcm9sbFxuICAgICAgICAvLyBMaW1pdCB0byBwdXNoIHRyYW5zaXRpb24gc2luY2UgdGhlcmUncyBubyB0cmFuc2Zvcm0gc2NvcGUgZm9yIG92ZXJsYXBcbiAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnRTY3JvbGwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluQ2FudmFzRm9yID0gdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLm1hdGNoKC9cXGJpbi1jYW52YXMtZm9yLShcXHcrKS8pO1xuXG4gICAgICBpZiAoaW5DYW52YXNGb3IgJiYgaW5DYW52YXNGb3IubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIFNldCBgaW5DYW52YXNPbmAgb3B0aW9uIGlmIGZvdW5kIGluLWNhbnZhcy1mb3ItW0JSRUFLUE9OVF0gQ1NTIGNsYXNzXG4gICAgICAgIHRoaXMub3B0aW9ucy5pbkNhbnZhc09uID0gaW5DYW52YXNGb3JbMV07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5pbkNhbnZhc09uKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgQ1NTIGNsYXNzIGlzIHNldFxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKFwiaW4tY2FudmFzLWZvci1cIi5jb25jYXQodGhpcy5vcHRpb25zLmluQ2FudmFzT24pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbkNhbnZhc09uKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrSW5DYW52YXMoKTtcbiAgICAgIH0gLy8gSW5pdGFsbHkgcmVtb3ZlIGFsbCB0cmFuc2l0aW9uL3Bvc2l0aW9uIENTUyBjbGFzc2VzIGZyb20gb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cblxuXG4gICAgICB0aGlzLl9yZW1vdmVDb250ZW50Q2xhc3NlcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYW5kIHRoZSBleGl0IG92ZXJsYXkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZkNhbnZhcycpLm9uKHtcbiAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSxcbiAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbiAgICAgICAgJ2tleWRvd24uemYub2ZmQ2FudmFzJzogdGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XG4gICAgICAgIHZhciAkdGFyZ2V0ID0gdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID8gdGhpcy4kb3ZlcmxheSA6IHRoaXMuJGNvbnRlbnQ7XG4gICAgICAgICR0YXJnZXQub24oe1xuICAgICAgICAgICdjbGljay56Zi5vZmZDYW52YXMnOiB0aGlzLmNsb3NlLmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5DYW52YXNPbikge1xuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuX2NoZWNrSW5DYW52YXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZXZlbnQgbGlzdGVuZXIgZm9yIGVsZW1lbnRzIHRoYXQgd2lsbCByZXZlYWwgYXQgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE1RQ2hlY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0TVFDaGVja2VyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IG9uTG9hZCgkKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xuICAgICAgICAgIF90aGlzLnJldmVhbCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xuICAgICAgICAgIF90aGlzLnJldmVhbCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5yZXZlYWwoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIEluQ2FudmFzIG9uIGN1cnJlbnQgYnJlYWtwb2ludCBhbmQgYWRqdXN0IG9mZi1jYW52YXMgYWNjb3JkaW5nbHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrSW5DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrSW5DYW52YXMoKSB7XG4gICAgICB0aGlzLmlzSW5DYW52YXMgPSBNZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmluQ2FudmFzT24pO1xuXG4gICAgICBpZiAodGhpcy5pc0luQ2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgQ1NTIHRyYW5zaXRpb24vcG9zaXRpb24gY2xhc3NlcyBvZiB0aGUgb2ZmLWNhbnZhcyBjb250ZW50IGNvbnRhaW5lci5cbiAgICAgKiBSZW1vdmluZyB0aGUgY2xhc3NlcyBpcyBpbXBvcnRhbnQgd2hlbiBhbm90aGVyIG9mZi1jYW52YXMgZ2V0cyBvcGVuZWQgdGhhdCB1c2VzIHRoZSBzYW1lIGNvbnRlbnQgY29udGFpbmVyLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaGFzUmV2ZWFsIC0gdHJ1ZSBpZiByZWxhdGVkIG9mZi1jYW52YXMgZWxlbWVudCBpcyByZXZlYWxlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUNvbnRlbnRDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVDb250ZW50Q2xhc3NlcyhoYXNSZXZlYWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFzUmV2ZWFsICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5yZW1vdmVDbGFzcyh0aGlzLmNvbnRlbnRDbGFzc2VzLmJhc2Uuam9pbignICcpKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzUmV2ZWFsID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLiRjb250ZW50LnJlbW92ZUNsYXNzKFwiaGFzLXJldmVhbC1cIi5jb25jYXQodGhpcy5wb3NpdGlvbikpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBDU1MgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzc2VzIG9mIHRoZSBvZmYtY2FudmFzIGNvbnRlbnQgY29udGFpbmVyLCBiYXNlZCBvbiB0aGUgb3BlbmluZyBvZmYtY2FudmFzIGVsZW1lbnQuXG4gICAgICogQmVmb3JlaGFuZCBhbnkgdHJhbnNpdGlvbi9wb3NpdGlvbiBjbGFzcyBnZXRzIHJlbW92ZWQuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBoYXNSZXZlYWwgLSB0cnVlIGlmIHJlbGF0ZWQgb2ZmLWNhbnZhcyBlbGVtZW50IGlzIHJldmVhbGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ29udGVudENsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENvbnRlbnRDbGFzc2VzKGhhc1JldmVhbCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQ29udGVudENsYXNzZXMoaGFzUmV2ZWFsKTtcblxuICAgICAgaWYgKHR5cGVvZiBoYXNSZXZlYWwgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLiRjb250ZW50LmFkZENsYXNzKFwiaGFzLXRyYW5zaXRpb24tXCIuY29uY2F0KHRoaXMub3B0aW9ucy50cmFuc2l0aW9uLCBcIiBoYXMtcG9zaXRpb24tXCIpLmNvbmNhdCh0aGlzLnBvc2l0aW9uKSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1JldmVhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLiRjb250ZW50LmFkZENsYXNzKFwiaGFzLXJldmVhbC1cIi5jb25jYXQodGhpcy5wb3NpdGlvbikpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVzZXJ2ZXMgdGhlIGZpeGVkIGJlaGF2aW9yIG9mIHN0aWNreSBlbGVtZW50cyBvbiBvcGVuaW5nIGFuIG9mZi1jYW52YXMgd2l0aCBwdXNoIHRyYW5zaXRpb24uXG4gICAgICogU2luY2UgdGhlIG9mZi1jYW52YXMgY29udGFpbmVyIGhhcyBnb3QgYSB0cmFuc2Zvcm0gc2NvcGUgaW4gc3VjaCBhIGNhc2UsIGl0IGlzIGRvbmUgYnkgY2FsY3VsYXRpbmcgcG9zaXRpb24gYWJzb2x1dGUgdmFsdWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZml4U3RpY2t5RWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeFN0aWNreUVsZW1lbnRzKCkge1xuICAgICAgdGhpcy4kc3RpY2t5LmVhY2goZnVuY3Rpb24gKF8sIGVsKSB7XG4gICAgICAgIHZhciAkZWwgPSAkKGVsKTsgLy8gSWYgc3RpY2t5IGVsZW1lbnQgaXMgY3VycmVudGx5IGZpeGVkLCBhZGp1c3QgaXRzIHRvcCB2YWx1ZSB0byBtYXRjaCBhYnNvbHV0ZSBwb3NpdGlvbiBkdWUgdG8gdHJhbnNmb3JtIHNjb3BlXG4gICAgICAgIC8vIExpbWl0IHRvIHB1c2ggdHJhbnNpdGlvbiBiZWNhdXNlIHBvc3Rpb246Zml4ZWQgd29ya3Mgd2l0aG91dCBwcm9ibGVtcyBmb3Igb3ZlcmxhcCAobm8gdHJhbnNmb3JtIHNjb3BlKVxuXG4gICAgICAgIGlmICgkZWwuY3NzKCdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgLy8gU2F2ZSBjdXJyZW50IGlubGluZSBzdHlsaW5nIHRvIHJlc3RvcmUgaXQgaWYgdW5kb2luZyB0aGUgYWJzb2x1dGUgZml4aW5nXG4gICAgICAgICAgdmFyIHRvcFZhbCA9IHBhcnNlSW50KCRlbC5jc3MoJ3RvcCcpLCAxMCk7XG4gICAgICAgICAgJGVsLmRhdGEoJ29mZkNhbnZhc1N0aWNreScsIHtcbiAgICAgICAgICAgIHRvcDogdG9wVmFsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGFic29sdXRlVG9wVmFsID0gJChkb2N1bWVudCkuc2Nyb2xsVG9wKCkgKyB0b3BWYWw7XG4gICAgICAgICAgJGVsLmNzcyh7XG4gICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KGFic29sdXRlVG9wVmFsLCBcInB4XCIpLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGZpeGVkIHN0eWxpbmcgb2Ygc3RpY2t5IGVsZW1lbnRzIGFmdGVyIGhhdmluZyBjbG9zZWQgYW4gb2ZmLWNhbnZhcyB0aGF0IGdvdCBwc2V1ZG8gZml4ZWQgYmVmb3JlaGFuZC5cbiAgICAgKiBUaGlzIHJldmVydHMgdGhlIGNoYW5nZXMgb2YgX2ZpeFN0aWNreUVsZW1lbnRzKClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VuZml4U3RpY2t5RWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuZml4U3RpY2t5RWxlbWVudHMoKSB7XG4gICAgICB0aGlzLiRzdGlja3kuZWFjaChmdW5jdGlvbiAoXywgZWwpIHtcbiAgICAgICAgdmFyICRlbCA9ICQoZWwpO1xuICAgICAgICB2YXIgc3RpY2t5RGF0YSA9ICRlbC5kYXRhKCdvZmZDYW52YXNTdGlja3knKTsgLy8gSWYgc3RpY2t5IGVsZW1lbnQgaGFzIGdvdCBkYXRhIG9iamVjdCB3aXRoIHByaW9yIHZhbHVlcyAobWVhbmluZyBpdCB3YXMgb3JpZ2luYWxseSBmaXhlZCkgcmVzdG9yZSB0aGVzZSB2YWx1ZXMgb25jZSBvZmYtY2FudmFzIGlzIGNsb3NlZFxuXG4gICAgICAgIGlmIChfdHlwZW9mKHN0aWNreURhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICRlbC5jc3Moe1xuICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdChzdGlja3lEYXRhLnRvcCwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiAnJyxcbiAgICAgICAgICAgIHRyYW5zaXRpb246ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJGVsLmRhdGEoJ29mZkNhbnZhc1N0aWNreScsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHJldmVhbGluZy9oaWRpbmcgdGhlIG9mZi1jYW52YXMgYXQgYnJlYWtwb2ludHMsIG5vdCB0aGUgc2FtZSBhcyBvcGVuLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSZXZlYWxlZCAtIHRydWUgaWYgZWxlbWVudCBzaG91bGQgYmUgcmV2ZWFsZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXZlYWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZWFsKGlzUmV2ZWFsZWQpIHtcbiAgICAgIGlmIChpc1JldmVhbGVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignb3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLWNsb3NlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignb3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyJykub24oe1xuICAgICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcbiAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWRkQ29udGVudENsYXNzZXMoaXNSZXZlYWxlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHNjcm9sbGluZyBvZiB0aGUgYm9keSB3aGVuIE9mZkNhbnZhcyBpcyBvcGVuIG9uIG1vYmlsZSBTYWZhcmkgYW5kIG90aGVyIHRyb3VibGVzb21lIGJyb3dzZXJzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcFNjcm9sbGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcFNjcm9sbGluZyhldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWcgdGhlIGVsZW1lbnQgZ2l2ZW4gYXMgY29udGV4dCB3aGV0aGVyIGl0IGNhbiBiZSBzY3JvbGxlZCB1cCBhbmQgZG93bi5cbiAgICAgKiBVc2VkIHRvIGFsbG93IG9yIHByZXZlbnQgaXQgdG8gc2Nyb2xsLiBTZWUgYF9zdG9wU2Nyb2xsUHJvcGFnYXRpb25gLlxuICAgICAqXG4gICAgICogVGFrZW4gYW5kIGFkYXB0ZWQgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2ODg5NDQ3L3ByZXZlbnQtZnVsbC1wYWdlLXNjcm9sbGluZy1pb3NcbiAgICAgKiBPbmx5IHJlYWxseSB3b3JrcyBmb3IgeSwgbm90IHN1cmUgaG93IHRvIGV4dGVuZCB0byB4IG9yIGlmIHdlIG5lZWQgdG8uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlY29yZFNjcm9sbGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlY29yZFNjcm9sbGFibGUoZXZlbnQpIHtcbiAgICAgIHZhciBlbGVtID0gdGhpczsgLy8gY2FsbGVkIGZyb20gZXZlbnQgaGFuZGxlciBjb250ZXh0IHdpdGggdGhpcyBhcyBlbGVtXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlIChjb250ZW50IG92ZXJmbG93cyksIHRoZW4uLi5cblxuICAgICAgaWYgKGVsZW0uc2Nyb2xsSGVpZ2h0ICE9PSBlbGVtLmNsaWVudEhlaWdodCkge1xuICAgICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgdG9wLCBzY3JvbGwgZG93biBvbmUgcGl4ZWwgdG8gYWxsb3cgc2Nyb2xsaW5nIHVwXG4gICAgICAgIGlmIChlbGVtLnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgIGVsZW0uc2Nyb2xsVG9wID0gMTtcbiAgICAgICAgfSAvLyBJZiB3ZSdyZSBhdCB0aGUgYm90dG9tLCBzY3JvbGwgdXAgb25lIHBpeGVsIHRvIGFsbG93IHNjcm9sbGluZyBkb3duXG5cblxuICAgICAgICBpZiAoZWxlbS5zY3JvbGxUb3AgPT09IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICBlbGVtLnNjcm9sbFRvcCA9IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW0uYWxsb3dVcCA9IGVsZW0uc2Nyb2xsVG9wID4gMDtcbiAgICAgIGVsZW0uYWxsb3dEb3duID0gZWxlbS5zY3JvbGxUb3AgPCBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0O1xuICAgICAgZWxlbS5sYXN0WSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQucGFnZVk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXZlbnQgdGhlIGdpdmVuIGV2ZW50IHByb3BhZ2F0aW9uIGlmIHRoZSBlbGVtZW50IGdpdmVuIGFzIGNvbnRleHQgY2FuIHNjcm9sbC5cbiAgICAgKiBVc2VkIHRvIHByZXNlcnZlIHRoZSBlbGVtZW50IHNjcm9sbGluZyBvbiBtb2JpbGUgKGB0b3VjaG1vdmVgKSB3aGVuIHRoZSBkb2N1bWVudFxuICAgICAqIHNjcm9sbGluZyBpcyBwcmV2ZW50ZWQuIFNlZSBodHRwczovL2dpdC5pby96Zi05NzA3LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RvcFNjcm9sbFByb3BhZ2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wU2Nyb2xsUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlbGVtID0gdGhpczsgLy8gY2FsbGVkIGZyb20gZXZlbnQgaGFuZGxlciBjb250ZXh0IHdpdGggdGhpcyBhcyBlbGVtXG5cbiAgICAgIHZhciBwYXJlbnQ7IC8vIG9mZi1jYW52YXMgZWxlbSBpZiBjYWxsZWQgZnJvbSBpbm5lciBzY3JvbGxib3hcblxuICAgICAgdmFyIHVwID0gZXZlbnQucGFnZVkgPCBlbGVtLmxhc3RZO1xuICAgICAgdmFyIGRvd24gPSAhdXA7XG4gICAgICBlbGVtLmxhc3RZID0gZXZlbnQucGFnZVk7XG5cbiAgICAgIGlmICh1cCAmJiBlbGVtLmFsbG93VXAgfHwgZG93biAmJiBlbGVtLmFsbG93RG93bikge1xuICAgICAgICAvLyBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gc3RvcCBldmVudCBwcm9wYWdhdGlvbiAodGhlIHVzZXIgY2Fubm90IHdhdGNoIGl0KSxcbiAgICAgICAgLy8gYnV0IGluIHRoaXMgY2FzZSB0aGlzIGlzIHRoZSBvbmx5IHNvbHV0aW9uIHdlIGhhdmUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBJZiBlbGVtIGlzIGlubmVyIHNjcm9sbGJveCB3ZSBhcmUgc2Nyb2xsaW5nIHRoZSBvdXRlciBvZmYtY2FudmFzIGRvd24vdXAgb25jZSB0aGUgYm94IGVuZCBoYXMgYmVlbiByZWFjaGVkXG4gICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgdXNlciBjb250aW51ZSB0byB0b3VjaCBtb3ZlIHRoZSBvZmYtY2FudmFzIHdpdGhvdXQgdGhlIG5lZWQgdG8gcGxhY2UgdGhlIGZpbmdlciBvdXRzaWRlIHRoZSBzY3JvbGxib3hcblxuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoJ2RhdGEtb2ZmLWNhbnZhcy1zY3JvbGxib3gnKSkge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0uY2xvc2VzdCgnW2RhdGEtb2ZmLWNhbnZhc10sIFtkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94LW91dGVyXScpO1xuXG4gICAgICAgICAgaWYgKGVsZW0uc2Nyb2xsVG9wIDw9IDEgJiYgcGFyZW50LnNjcm9sbFRvcCA+IDApIHtcbiAgICAgICAgICAgIHBhcmVudC5zY3JvbGxUb3AtLTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uc2Nyb2xsVG9wID49IGVsZW0uc2Nyb2xsSGVpZ2h0IC0gZWxlbS5jbGllbnRIZWlnaHQgLSAxICYmIHBhcmVudC5zY3JvbGxUb3AgPCBwYXJlbnQuc2Nyb2xsSGVpZ2h0IC0gcGFyZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIG9mZi1jYW52YXMgbWVudS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXG4gICAgICogQGZpcmVzIE9mZkNhbnZhcyNvcGVuZWRcbiAgICAgKiBAdG9kbyBhbHNvIHRyaWdnZXIgJ29wZW4nIGV2ZW50P1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGV2ZW50LCB0cmlnZ2VyKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSB8fCB0aGlzLmlzUmV2ZWFsZWQgfHwgdGhpcy5pc0luQ2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICd0b3AnKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmZvcmNlVG8gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUgJiYgdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gIT09ICdvdmVybGFwJykge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuY3NzKCd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKS5yZW1vdmVDbGFzcygnaXMtY2xvc2VkJyk7XG4gICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgIHRoaXMuJGNvbnRlbnQuYWRkQ2xhc3MoJ2lzLW9wZW4tJyArIHRoaXMucG9zaXRpb24pOyAvLyBJZiBgY29udGVudFNjcm9sbGAgaXMgc2V0IHRvIGZhbHNlLCBhZGQgY2xhc3MgYW5kIGRpc2FibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudFNjcm9sbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNoc3RhcnQnLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbFByb3BhZ2F0aW9uKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2hzdGFydCcsICdbZGF0YS1vZmYtY2FudmFzLXNjcm9sbGJveF0nLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2htb3ZlJywgJ1tkYXRhLW9mZi1jYW52YXMtc2Nyb2xsYm94XScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnaXMtdmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnaXMtY2xvc2FibGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvRm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbmUodHJhbnNpdGlvbmVuZCh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghX3RoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBleGl0IGlmIHByZW1hdHVyZWx5IGNsb3NlZFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjYW52YXNGb2N1cyA9IF90aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWF1dG9mb2N1c10nKTtcblxuICAgICAgICAgIGlmIChjYW52YXNGb2N1cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbnZhc0ZvY3VzLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmZpbmQoJ2EsIGJ1dHRvbicpLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kY29udGVudC5hdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICBLZXlib2FyZC50cmFwRm9jdXModGhpcy4kZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiA9PT0gJ3B1c2gnKSB7XG4gICAgICAgIHRoaXMuX2ZpeFN0aWNreUVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZENvbnRlbnRDbGFzc2VzKCk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAqIEBldmVudCBPZmZDYW52YXMjb3BlbmVkXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW5lZC56Zi5vZmZDYW52YXMnKTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW4gdHJhbnNpdGlvbiBpcyBkb25lLlxuICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNvcGVuZWRFbmRcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZSh0cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC4kZWxlbWVudC50cmlnZ2VyKCdvcGVuZWRFbmQuemYub2ZmQ2FudmFzJyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBvZmYtY2FudmFzIG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYiB0byBmaXJlIGFmdGVyIGNsb3N1cmUuXG4gICAgICogQGZpcmVzIE9mZkNhbnZhcyNjbG9zZVxuICAgICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShjYikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBjbG9zZXMuXG4gICAgICAgKiBAZXZlbnQgT2ZmQ2FudmFzI2Nsb3NlXG4gICAgICAgKi9cblxuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlLnpmLm9mZkNhbnZhcycpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgIHRoaXMuJGNvbnRlbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4tbGVmdCBpcy1vcGVuLXRvcCBpcy1vcGVuLXJpZ2h0IGlzLW9wZW4tYm90dG9tJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcygnaXMtY2xvc2FibGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpOyAvLyBMaXN0ZW4gdG8gdHJhbnNpdGlvbkVuZDogYWRkIGNsYXNzLCByZS1lbmFibGUgc2Nyb2xsaW5nIGFuZCByZWxlYXNlIGZvY3VzIHdoZW4gZG9uZS5cblxuICAgICAgdGhpcy4kZWxlbWVudC5vbmUodHJhbnNpdGlvbmVuZCh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXM1LiRlbGVtZW50LmFkZENsYXNzKCdpcy1jbG9zZWQnKTtcblxuICAgICAgICBfdGhpczUuX3JlbW92ZUNvbnRlbnRDbGFzc2VzKCk7XG5cbiAgICAgICAgaWYgKF90aGlzNS5vcHRpb25zLnRyYW5zaXRpb24gPT09ICdwdXNoJykge1xuICAgICAgICAgIF90aGlzNS5fdW5maXhTdGlja3lFbGVtZW50cygpO1xuICAgICAgICB9IC8vIElmIGBjb250ZW50U2Nyb2xsYCBpcyBzZXQgdG8gZmFsc2UsIHJlbW92ZSBjbGFzcyBhbmQgcmUtZW5hYmxlIHNjcm9sbGluZyBvbiB0b3VjaCBkZXZpY2VzLlxuXG5cbiAgICAgICAgaWYgKF90aGlzNS5vcHRpb25zLmNvbnRlbnRTY3JvbGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vZmYoJ3RvdWNobW92ZScsIF90aGlzNS5fc3RvcFNjcm9sbGluZyk7XG5cbiAgICAgICAgICBfdGhpczUuJGVsZW1lbnQub2ZmKCd0b3VjaHN0YXJ0JywgX3RoaXM1Ll9yZWNvcmRTY3JvbGxhYmxlKTtcblxuICAgICAgICAgIF90aGlzNS4kZWxlbWVudC5vZmYoJ3RvdWNobW92ZScsIF90aGlzNS5fc3RvcFNjcm9sbFByb3BhZ2F0aW9uKTtcblxuICAgICAgICAgIF90aGlzNS4kZWxlbWVudC5vZmYoJ3RvdWNoc3RhcnQnLCAnW2RhdGEtb2ZmLWNhbnZhcy1zY3JvbGxib3hdJywgX3RoaXM1Ll9yZWNvcmRTY3JvbGxhYmxlKTtcblxuICAgICAgICAgIF90aGlzNS4kZWxlbWVudC5vZmYoJ3RvdWNobW92ZScsICdbZGF0YS1vZmYtY2FudmFzLXNjcm9sbGJveF0nLCBfdGhpczUuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM1Lm9wdGlvbnMudHJhcEZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgX3RoaXM1LiRjb250ZW50LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG5cbiAgICAgICAgICBLZXlib2FyZC5yZWxlYXNlRm9jdXMoX3RoaXM1LiRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlIHRyYW5zaXRpb24gaXMgZG9uZS5cbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNjbG9zZWRcbiAgICAgICAgICovXG5cblxuICAgICAgICBfdGhpczUuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLm9mZkNhbnZhcycpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIG9mZi1jYW52YXMgbWVudSBvcGVuIG9yIGNsb3NlZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKGV2ZW50LCB0cmlnZ2VyKSB7XG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoZXZlbnQsIHRyaWdnZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcGVuKGV2ZW50LCB0cmlnZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBrZXlib2FyZCBpbnB1dCB3aGVuIGRldGVjdGVkLiBXaGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsIHRoZSBvZmYtY2FudmFzIG1lbnUgY2xvc2VzLCBhbmQgZm9jdXMgaXMgcmVzdG9yZWQgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcGVuZWQgdGhlIG1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVLZXlib2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5Ym9hcmQoZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnT2ZmQ2FudmFzJywge1xuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgX3RoaXM2LmNsb3NlKCk7XG5cbiAgICAgICAgICBfdGhpczYuJGxhc3RUcmlnZ2VyLmZvY3VzKCk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgT2ZmQ2FudmFzIHBsdWdpbi5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZDYW52YXMnKTtcbiAgICAgIHRoaXMuJG92ZXJsYXkub2ZmKCcuemYub2ZmQ2FudmFzJyk7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT2ZmQ2FudmFzO1xufShQbHVnaW4pO1xuXG5PZmZDYW52YXMuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBBbGxvdyB0aGUgdXNlciB0byBjbGljayBvdXRzaWRlIG9mIHRoZSBtZW51IHRvIGNsb3NlIGl0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjbG9zZU9uQ2xpY2s6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gb3ZlcmxheSBvbiB0b3Agb2YgYFtkYXRhLW9mZi1jYW52YXMtY29udGVudF1gLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjb250ZW50T3ZlcmxheTogdHJ1ZSxcblxuICAvKipcbiAgICogVGFyZ2V0IGFuIG9mZi1jYW52YXMgY29udGVudCBjb250YWluZXIgYnkgSUQgdGhhdCBtYXkgYmUgcGxhY2VkIGFueXdoZXJlLiBJZiBudWxsIHRoZSBjbG9zZXN0IGNvbnRlbnQgY29udGFpbmVyIHdpbGwgYmUgdGFrZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICovXG4gIGNvbnRlbnRJZDogbnVsbCxcblxuICAvKipcbiAgICogRGVmaW5lIHRoZSBvZmYtY2FudmFzIGVsZW1lbnQgaXMgbmVzdGVkIGluIGFuIG9mZi1jYW52YXMgY29udGVudC4gVGhpcyBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIHRoZSBjb250ZW50SWQgb3B0aW9uIGZvciBhIG5lc3RlZCBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBuZXN0ZWQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgbWFpbiBjb250ZW50IHdoZW4gYW4gb2ZmIGNhbnZhcyBwYW5lbCBpcyBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBjb250ZW50U2Nyb2xsOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgdGltZSB0aGUgb3BlbiBhbmQgY2xvc2UgdHJhbnNpdGlvbiByZXF1aXJlcywgaW5jbHVkaW5nIHRoZSBhcHByb3ByaWF0ZSBtaWxsaXNlY29uZHMgKGBtc2ApIG9yIHNlY29uZHMgKGBzYCkgdW5pdCAoZS5nLiBgNTAwbXNgLCBgLjc1c2ApIElmIG5vbmUgc2VsZWN0ZWQsIHB1bGxzIGZyb20gYm9keSBzdHlsZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICB0cmFuc2l0aW9uVGltZTogbnVsbCxcblxuICAvKipcbiAgICogVHlwZSBvZiB0cmFuc2l0aW9uIGZvciB0aGUgT2ZmQ2FudmFzIG1lbnUuIE9wdGlvbnMgYXJlICdwdXNoJywgJ2RldGFjaGVkJyBvciAnc2xpZGUnLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0IHB1c2hcbiAgICovXG4gIHRyYW5zaXRpb246ICdwdXNoJyxcblxuICAvKipcbiAgICogRm9yY2UgdGhlIHBhZ2UgdG8gc2Nyb2xsIHRvIHRvcCBvciBib3R0b20gb24gb3Blbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgZm9yY2VUbzogbnVsbCxcblxuICAvKipcbiAgICogQWxsb3cgdGhlIE9mZkNhbnZhcyB0byByZW1haW4gb3BlbiBmb3IgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlzUmV2ZWFsZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgcmV2ZWFsT246IG51bGwsXG5cbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgYXQgd2hpY2ggdGhlIG9mZi1jYW52YXMgZ2V0cyBtb3ZlZCBpbnRvIGNhbnZhcyBjb250ZW50IGFuZCBhY3RzIGFzIHJlZ3VsYXIgcGFnZSBlbGVtZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbkNhbnZhc09uOiBudWxsLFxuXG4gIC8qKlxuICAgKiBGb3JjZSBmb2N1cyB0byB0aGUgb2ZmY2FudmFzIG9uIG9wZW4uIElmIHRydWUsIHdpbGwgZm9jdXMgdGhlIG9wZW5pbmcgdHJpZ2dlciBvbiBjbG9zZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYXV0b0ZvY3VzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBDbGFzcyB1c2VkIHRvIGZvcmNlIGFuIE9mZkNhbnZhcyB0byByZW1haW4gb3Blbi4gRm91bmRhdGlvbiBkZWZhdWx0cyBmb3IgdGhpcyBhcmUgYHJldmVhbC1mb3ItbGFyZ2VgICYgYHJldmVhbC1mb3ItbWVkaXVtYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZXZlYWwtZm9yLVxuICAgKiBAdG9kbyBpbXByb3ZlIHRoZSByZWdleCB0ZXN0aW5nIGZvciB0aGlzLlxuICAgKi9cbiAgcmV2ZWFsQ2xhc3M6ICdyZXZlYWwtZm9yLScsXG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIG9wdGlvbmFsIGZvY3VzIHRyYXBwaW5nIHdoZW4gb3BlbmluZyBhbiBPZmZDYW52YXMuIFNldHMgdGFiaW5kZXggb2YgW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XSB0byAtMSBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHRyYXBGb2N1czogZmFsc2Vcbn07XG5cbi8qKlxuICogT3JiaXQgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLm9yYml0XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxuICovXG5cbnZhciBPcmJpdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoT3JiaXQsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIE9yYml0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcmJpdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKE9yYml0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhPcmJpdCwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb3JiaXQgY2Fyb3VzZWwuXG4gICAgKiBAY2xhc3NcbiAgICAqIEBuYW1lIE9yYml0XG4gICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIE9yYml0IENhcm91c2VsLlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnT3JiaXQnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgVG91Y2guaW5pdCgkKTsgLy8gVG91Y2ggaW5pdCBpcyBpZGVtcG90ZW50LCB3ZSBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgaW5pdGlhbGllZC5cblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBLZXlib2FyZC5yZWdpc3RlcignT3JiaXQnLCB7XG4gICAgICAgICdsdHInOiB7XG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJ1xuICAgICAgICB9LFxuICAgICAgICAncnRsJzoge1xuICAgICAgICAgICdBUlJPV19MRUZUJzogJ25leHQnLFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdwcmV2aW91cydcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMsIHNldHRpbmcgYXR0cmlidXRlcywgYW5kIHN0YXJ0aW5nIHRoZSBhbmltYXRpb24uXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgLy8gQFRPRE86IGNvbnNpZGVyIGRpc2N1c3Npb24gb24gUFIgIzkyNzggYWJvdXQgRE9NIHBvbGx1dGlvbiBieSBjaGFuZ2VTbGlkZVxuICAgICAgdGhpcy5fcmVzZXQoKTtcblxuICAgICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSk7XG4gICAgICB0aGlzLiRzbGlkZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSk7XG4gICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyksXG4gICAgICAgICAgaW5pdEFjdGl2ZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKSxcbiAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgR2V0WW9EaWdpdHMoNiwgJ29yYml0Jyk7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgJ2lkJzogaWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWluaXRBY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU1VSSkge1xuICAgICAgICB0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoJ25vLW1vdGlvbnVpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICBvbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKTsgLy9oZWhlXG5cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgIHRoaXMuX2xvYWRCdWxsZXRzKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmIHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuZ2VvU3luYygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcbiAgICAgICAgLy8gYWxsb3cgd3JhcHBlciB0byBiZSBmb2N1c2FibGUgdG8gZW5hYmxlIGFycm93IG5hdmlnYXRpb25cbiAgICAgICAgdGhpcy4kd3JhcHBlci5hdHRyKCd0YWJpbmRleCcsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYSBqUXVlcnkgY29sbGVjdGlvbiBvZiBidWxsZXRzLCBpZiB0aGV5IGFyZSBiZWluZyB1c2VkLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZEJ1bGxldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRCdWxsZXRzKCkge1xuICAgICAgdGhpcy4kYnVsbGV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykpLmZpbmQoJ2J1dHRvbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgYSBgdGltZXJgIG9iamVjdCBvbiB0aGUgb3JiaXQsIGFuZCBzdGFydHMgdGhlIGNvdW50ZXIgZm9yIHRoZSBuZXh0IHNsaWRlLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlb1N5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VvU3luYygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMudGltZXIgPSBuZXcgVGltZXIodGhpcy4kZWxlbWVudCwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLnRpbWVyRGVsYXksXG4gICAgICAgIGluZmluaXRlOiBmYWxzZVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNldHMgd3JhcHBlciBhbmQgc2xpZGUgaGVpZ2h0cyBmb3IgdGhlIG9yYml0LlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcHJlcGFyZUZvck9yYml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlRm9yT3JiaXQoKSB7XG5cbiAgICAgIHRoaXMuX3NldFdyYXBwZXJIZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBDYWx1bGF0ZXMgdGhlIGhlaWdodCBvZiBlYWNoIHNsaWRlIGluIHRoZSBjb2xsZWN0aW9uLCBhbmQgdXNlcyB0aGUgdGFsbGVzdCBvbmUgZm9yIHRoZSB3cmFwcGVyIGhlaWdodC5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gYSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIHdoZW4gY29tcGxldGUuXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRXcmFwcGVySGVpZ2h0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRXcmFwcGVySGVpZ2h0KGNiKSB7XG4gICAgICAvL3Jld3JpdGUgdGhpcyB0byBgZm9yYCBsb29wXG4gICAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgICB0ZW1wLFxuICAgICAgICAgIGNvdW50ZXIgPSAwLFxuICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZW1wID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICQodGhpcykuYXR0cignZGF0YS1zbGlkZScsIGNvdW50ZXIpOyAvLyBoaWRlIGFsbCBzbGlkZXMgYnV0IHRoZSBhY3RpdmUgb25lXG5cbiAgICAgICAgaWYgKCEvbXVpL2cudGVzdCgkKHRoaXMpWzBdLmNsYXNzTmFtZSkgJiYgX3RoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKVswXSAhPT0gX3RoaXMuJHNsaWRlcy5lcShjb3VudGVyKVswXSkge1xuICAgICAgICAgICQodGhpcykuY3NzKHtcbiAgICAgICAgICAgICdkaXNwbGF5JzogJ25vbmUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXggPSB0ZW1wID4gbWF4ID8gdGVtcCA6IG1heDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChjb3VudGVyID09PSB0aGlzLiRzbGlkZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHtcbiAgICAgICAgICAnaGVpZ2h0JzogbWF4XG4gICAgICAgIH0pOyAvL29ubHkgY2hhbmdlIHRoZSB3cmFwcGVyIGhlaWdodCBwcm9wZXJ0eSBvbmNlLlxuXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKG1heCk7XG4gICAgICAgIH0gLy9maXJlIGNhbGxiYWNrIHdpdGggbWF4IGhlaWdodCBkaW1lbnNpb24uXG5cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBTZXRzIHRoZSBtYXgtaGVpZ2h0IG9mIGVhY2ggc2xpZGUuXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRTbGlkZUhlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2xpZGVIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykuY3NzKCdtYXgtaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGJhc2ljYWxseSBldmVyeXRoaW5nIHdpdGhpbiB0aGUgZWxlbWVudC5cbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpczsgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgIC8vKipOb3cgdXNpbmcgY3VzdG9tIGV2ZW50IC0gdGhhbmtzIHRvOioqXG4gICAgICAvLyoqICAgICAgWW9oYWkgQXJhcmF0IG9mIFRvcm9udG8gICAgICAqKlxuICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgIC8vXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5yZXNpemVtZS56Zi50cmlnZ2VyJykub24oe1xuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3dpcGUpIHtcbiAgICAgICAgICB0aGlzLiRzbGlkZXMub2ZmKCdzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdCcpLm9uKCdzd2lwZWxlZnQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgICAgICB9KS5vbignc3dpcGVyaWdodC56Zi5vcmJpdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSkge1xuICAgICAgICAgIHRoaXMuJHNsaWRlcy5vbignY2xpY2suemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nLCBfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nKSA/IGZhbHNlIDogdHJ1ZSk7XG5cbiAgICAgICAgICAgIF90aGlzLnRpbWVyW190aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gJ3BhdXNlJyA6ICdzdGFydCddKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMudGltZXIucGF1c2UoKTtcbiAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKSB7XG4gICAgICAgICAgdmFyICRjb250cm9scyA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLm5leHRDbGFzcywgXCIsIC5cIikuY29uY2F0KHRoaXMub3B0aW9ucy5wcmV2Q2xhc3MpKTtcbiAgICAgICAgICAkY29udHJvbHMuYXR0cigndGFiaW5kZXgnLCAwKSAvL2Fsc28gbmVlZCB0byBoYW5kbGUgZW50ZXIvcmV0dXJuIGFuZCBzcGFjZWJhciBrZXkgcHJlc3Nlc1xuICAgICAgICAgIC5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSgkKHRoaXMpLmhhc0NsYXNzKF90aGlzLm9wdGlvbnMubmV4dENsYXNzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgICAgICB0aGlzLiRidWxsZXRzLm9uKCdjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICgvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSAvL2lmIHRoaXMgaXMgYWN0aXZlLCBraWNrIG91dCBvZiBmdW5jdGlvbi5cblxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gJCh0aGlzKS5kYXRhKCdzbGlkZScpLFxuICAgICAgICAgICAgICAgIGx0ciA9IGlkeCA+IF90aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZGF0YSgnc2xpZGUnKSxcbiAgICAgICAgICAgICAgICAkc2xpZGUgPSBfdGhpcy4kc2xpZGVzLmVxKGlkeCk7XG5cbiAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGx0ciwgJHNsaWRlLCBpZHgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlKSB7XG4gICAgICAgICAgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdPcmJpdCcsIHtcbiAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBidWxsZXQgaXMgZm9jdXNlZCwgbWFrZSBzdXJlIGZvY3VzIG1vdmVzXG4gICAgICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBPcmJpdCBzbyBpdCBjYW4gYmUgcmVpbml0aWFsaXplZFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGFyZSBubyBzbGlkZXMgKGZpcnN0IHJ1bilcbiAgICAgIGlmICh0eXBlb2YgdGhpcy4kc2xpZGVzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbGQgZXZlbnRzXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKTsgLy8gUmVzdGFydCB0aW1lciBpZiBhdXRvUGxheSBpcyBlbmFibGVkXG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSkge1xuICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xuICAgICAgICB9IC8vIFJlc2V0IGFsbCBzbGlkZGVzXG5cblxuICAgICAgICB0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAkKGVsKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcbiAgICAgICAgfSk7IC8vIFNob3cgdGhlIGZpcnN0IHNsaWRlXG5cbiAgICAgICAgdGhpcy4kc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnNob3coKTsgLy8gVHJpZ2dlcnMgd2hlbiB0aGUgc2xpZGUgaGFzIGZpbmlzaGVkIGFuaW1hdGluZ1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbdGhpcy4kc2xpZGVzLmZpcnN0KCldKTsgLy8gU2VsZWN0IGZpcnN0IGJ1bGxldCBpZiBidWxsZXRzIGFyZSBwcmVzZW50XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cygwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2xpZGUgdG8gYSBuZXcgb25lLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzTFRSIC0gaWYgdHJ1ZSB0aGUgc2xpZGUgbW92ZXMgZnJvbSByaWdodCB0byBsZWZ0LCBpZiBmYWxzZSB0aGUgc2xpZGUgbW92ZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICogQHBhcmFtIHtqUXVlcnl9IGNob3NlblNsaWRlIC0gdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBzbGlkZSB0byBzaG93IG5leHQsIGlmIG9uZSBpcyBzZWxlY3RlZC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cbiAgICAqIEBmaXJlcyBPcmJpdCNzbGlkZWNoYW5nZVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGFuZ2VTbGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTbGlkZShpc0xUUiwgY2hvc2VuU2xpZGUsIGlkeCkge1xuICAgICAgaWYgKCF0aGlzLiRzbGlkZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEb24ndCBmcmVhayBvdXQgaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBjbGVhbnVwXG5cblxuICAgICAgdmFyICRjdXJTbGlkZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5lcSgwKTtcblxuICAgICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy9pZiB0aGUgc2xpZGUgaXMgY3VycmVudGx5IGFuaW1hdGluZywga2ljayBvdXQgb2YgdGhlIGZ1bmN0aW9uXG5cblxuICAgICAgdmFyICRmaXJzdFNsaWRlID0gdGhpcy4kc2xpZGVzLmZpcnN0KCksXG4gICAgICAgICAgJGxhc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5sYXN0KCksXG4gICAgICAgICAgZGlySW4gPSBpc0xUUiA/ICdSaWdodCcgOiAnTGVmdCcsXG4gICAgICAgICAgZGlyT3V0ID0gaXNMVFIgPyAnTGVmdCcgOiAnUmlnaHQnLFxuICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAkbmV3U2xpZGU7XG5cbiAgICAgIGlmICghY2hvc2VuU2xpZGUpIHtcbiAgICAgICAgLy9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxuICAgICAgICAkbmV3U2xpZGUgPSBpc0xUUiA/IC8vaWYgd3JhcHBpbmcgZW5hYmxlZCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgYG5leHRgIG9yIGBwcmV2YCBzaWJsaW5nLCBpZiBub3QsIHNlbGVjdCB0aGUgZmlyc3Qgb3IgbGFzdCBzbGlkZSB0byBmaWxsIGluLiBpZiB3cmFwcGluZyBub3QgZW5hYmxlZCwgYXR0ZW1wdCB0byBzZWxlY3QgYG5leHRgIG9yIGBwcmV2YCwgaWYgdGhlcmUncyBub3RoaW5nIHRoZXJlLCB0aGUgZnVuY3Rpb24gd2lsbCBraWNrIG91dCBvbiBuZXh0IHN0ZXAuIENSQVpZIE5FU1RFRCBURVJOQVJJRVMhISEhIVxuICAgICAgICB0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLm5leHQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkubGVuZ3RoID8gJGN1clNsaWRlLm5leHQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSkgOiAkZmlyc3RTbGlkZSA6ICRjdXJTbGlkZS5uZXh0KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcbiAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpLmxlbmd0aCA/ICRjdXJTbGlkZS5wcmV2KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpIDogJGxhc3RTbGlkZSA6ICRjdXJTbGlkZS5wcmV2KFwiLlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykpOyAvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJG5ld1NsaWRlID0gY2hvc2VuU2xpZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICgkbmV3U2xpZGUubGVuZ3RoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAqIFRyaWdnZXJzIGJlZm9yZSB0aGUgbmV4dCBzbGlkZSBzdGFydHMgYW5pbWF0aW5nIGluIGFuZCBvbmx5IGlmIGEgbmV4dCBzbGlkZSBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICAgKiBAZXZlbnQgT3JiaXQjYmVmb3Jlc2xpZGVjaGFuZ2VcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdiZWZvcmVzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFskY3VyU2xpZGUsICRuZXdTbGlkZV0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xuICAgICAgICAgIGlkeCA9IGlkeCB8fCB0aGlzLiRzbGlkZXMuaW5kZXgoJG5ld1NsaWRlKTsgLy9ncmFiIGluZGV4IHRvIHVwZGF0ZSBidWxsZXRzXG5cbiAgICAgICAgICB0aGlzLl91cGRhdGVCdWxsZXRzKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZU1VSSAmJiAhdGhpcy4kZWxlbWVudC5pcygnOmhpZGRlbicpKSB7XG4gICAgICAgICAgTW90aW9uLmFuaW1hdGVJbigkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbXCJhbmltSW5Gcm9tXCIuY29uY2F0KGRpckluKV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRuZXdTbGlkZS5jc3Moe1xuICAgICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaydcbiAgICAgICAgICAgIH0pLmF0dHIoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBNb3Rpb24uYW5pbWF0ZU91dCgkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbXCJhbmltT3V0VG9cIi5jb25jYXQoZGlyT3V0KV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVBdHRyKCdhcmlhLWxpdmUnKTtcblxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIV90aGlzLnRpbWVyLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH0gLy9kbyBzdHVmZj9cblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWluJykucmVtb3ZlQXR0cignYXJpYS1saXZlJykuaGlkZSgpO1xuICAgICAgICAgICRuZXdTbGlkZS5hZGRDbGFzcygnaXMtYWN0aXZlIGlzLWluJykuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpLnNob3coKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIXRoaXMudGltZXIuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgKiBUcmlnZ2VycyB3aGVuIHRoZSBzbGlkZSBoYXMgZmluaXNoZWQgYW5pbWF0aW5nIGluLlxuICAgICAgICAqIEBldmVudCBPcmJpdCNzbGlkZWNoYW5nZVxuICAgICAgICAqL1xuXG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFskbmV3U2xpZGVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJ1bGxldHMsIGlmIGRpc3BsYXllZC5cbiAgICAqIE1vdmUgdGhlIGRlc2NyaXB0b3Igb2YgdGhlIGN1cnJlbnQgc2xpZGUgYFtkYXRhLXNsaWRlLWFjdGl2ZS1sYWJlbF1gIHRvIHRoZSBuZXdseSBhY3RpdmUgYnVsbGV0LlxuICAgICogSWYgbm8gYFtkYXRhLXNsaWRlLWFjdGl2ZS1sYWJlbF1gIGlzIHNldCwgd2lsbCBtb3ZlIHRoZSBleGNlZWRpbmcgYHNwYW5gIGVsZW1lbnQuXG4gICAgKlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBzbGlkZS5cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUJ1bGxldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUJ1bGxldHMoaWR4KSB7XG4gICAgICB2YXIgJG9sZEJ1bGxldCA9IHRoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJyk7XG4gICAgICB2YXIgJG90aGVyc0J1bGxldHMgPSB0aGlzLiRidWxsZXRzLm5vdCgnLmlzLWFjdGl2ZScpO1xuICAgICAgdmFyICRuZXdCdWxsZXQgPSB0aGlzLiRidWxsZXRzLmVxKGlkeCk7XG4gICAgICAkb2xkQnVsbGV0LnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5ibHVyKCk7XG4gICAgICAkbmV3QnVsbGV0LmFkZENsYXNzKCdpcy1hY3RpdmUnKTsgLy8gRmluZCB0aGUgZGVzY3JpcHRvciBmb3IgdGhlIGN1cnJlbnQgc2xpZGUgdG8gbW92ZSBpdCB0byB0aGUgbmV3IHNsaWRlIGJ1dHRvblxuXG4gICAgICB2YXIgYWN0aXZlU3RhdGVEZXNjcmlwdG9yID0gJG9sZEJ1bGxldC5jaGlsZHJlbignW2RhdGEtc2xpZGUtYWN0aXZlLWxhYmVsXScpLmxhc3QoKTsgLy8gSWYgbm90IGV4cGxpY2l0ZWx5IGdpdmVuLCBzZWFyY2ggZm9yIHRoZSBsYXN0IFwiZXhjZWVkaW5nXCIgc3BhbiBlbGVtZW50IChjb21wYXJlZCB0byBvdGhlcnMgYnVsbGV0cykuXG5cbiAgICAgIGlmICghYWN0aXZlU3RhdGVEZXNjcmlwdG9yLmxlbmd0aCkge1xuICAgICAgICB2YXIgc3BhbnMgPSAkb2xkQnVsbGV0LmNoaWxkcmVuKCdzcGFuJyk7XG4gICAgICAgIHZhciBzcGFuQ291bnRJbk90aGVyc0J1bGxldHMgPSAkb3RoZXJzQnVsbGV0cy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgcmV0dXJuICQoYikuY2hpbGRyZW4oJ3NwYW4nKS5sZW5ndGg7XG4gICAgICAgIH0pOyAvLyBJZiB0aGVyZSBpcyBhbiBleGNlZWRpbmcgc3BhbiBlbGVtZW50LCB1c2UgaXQgYXMgY3VycmVudCBzbGlkZSBkZXNjcmlwdG9yXG5cbiAgICAgICAgaWYgKHNwYW5Db3VudEluT3RoZXJzQnVsbGV0cy5ldmVyeShmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgICByZXR1cm4gY291bnQgPCBzcGFucy5sZW5ndGg7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgYWN0aXZlU3RhdGVEZXNjcmlwdG9yID0gc3BhbnMubGFzdCgpO1xuICAgICAgICAgIGFjdGl2ZVN0YXRlRGVzY3JpcHRvci5hdHRyKCdkYXRhLXNsaWRlLWFjdGl2ZS1sYWJlbCcsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBNb3ZlIHRoZSBjdXJyZW50IHNsaWRlIGRlc2NyaXB0b3IgdG8gdGhlIG5ldyBzbGlkZSBidXR0b25cblxuXG4gICAgICBpZiAoYWN0aXZlU3RhdGVEZXNjcmlwdG9yLmxlbmd0aCkge1xuICAgICAgICBhY3RpdmVTdGF0ZURlc2NyaXB0b3IuZGV0YWNoKCk7XG4gICAgICAgICRuZXdCdWxsZXQuYXBwZW5kKGFjdGl2ZVN0YXRlRGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogRGVzdHJveXMgdGhlIGNhcm91c2VsIGFuZCBoaWRlcyB0aGUgZWxlbWVudC5cbiAgICAqIEBmdW5jdGlvblxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKS5lbmQoKS5oaWRlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9yYml0O1xufShQbHVnaW4pO1xuXG5PcmJpdC5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICogVGVsbHMgdGhlIEpTIHRvIGxvb2sgZm9yIGFuZCBsb2FkQnVsbGV0cy5cbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAqIEBkZWZhdWx0IHRydWVcbiAgKi9cbiAgYnVsbGV0czogdHJ1ZSxcblxuICAvKipcbiAgKiBUZWxscyB0aGUgSlMgdG8gYXBwbHkgZXZlbnQgbGlzdGVuZXJzIHRvIG5hdiBidXR0b25zXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIG5hdkJ1dHRvbnM6IHRydWUsXG5cbiAgLyoqXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tcmlnaHQnXG4gICovXG4gIGFuaW1JbkZyb21SaWdodDogJ3NsaWRlLWluLXJpZ2h0JyxcblxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdzbGlkZS1vdXQtcmlnaHQnXG4gICovXG4gIGFuaW1PdXRUb1JpZ2h0OiAnc2xpZGUtb3V0LXJpZ2h0JyxcblxuICAvKipcbiAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdzbGlkZS1pbi1sZWZ0J1xuICAqXG4gICovXG4gIGFuaW1JbkZyb21MZWZ0OiAnc2xpZGUtaW4tbGVmdCcsXG5cbiAgLyoqXG4gICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgKiBAZGVmYXVsdCAnc2xpZGUtb3V0LWxlZnQnXG4gICovXG4gIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXG5cbiAgLyoqXG4gICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIGF1dG9QbGF5OiB0cnVlLFxuXG4gIC8qKlxuICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgYmV0d2VlbiBzbGlkZSB0cmFuc2l0aW9uc1xuICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgKiBAZGVmYXVsdCA1MDAwXG4gICovXG4gIHRpbWVyRGVsYXk6IDUwMDAsXG5cbiAgLyoqXG4gICogQWxsb3dzIE9yYml0IHRvIGluZmluaXRlbHkgbG9vcCB0aHJvdWdoIHRoZSBzbGlkZXNcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAqIEBkZWZhdWx0IHRydWVcbiAgKi9cbiAgaW5maW5pdGVXcmFwOiB0cnVlLFxuXG4gIC8qKlxuICAqIEFsbG93cyB0aGUgT3JiaXQgc2xpZGVzIHRvIGJpbmQgdG8gc3dpcGUgZXZlbnRzIGZvciBtb2JpbGUsIHJlcXVpcmVzIGFuIGFkZGl0aW9uYWwgdXRpbCBsaWJyYXJ5XG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCB0cnVlXG4gICovXG4gIHN3aXBlOiB0cnVlLFxuXG4gIC8qKlxuICAqIEFsbG93cyB0aGUgdGltaW5nIGZ1bmN0aW9uIHRvIHBhdXNlIGFuaW1hdGlvbiBvbiBob3Zlci5cbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAqIEBkZWZhdWx0IHRydWVcbiAgKi9cbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuXG4gIC8qKlxuICAqIEFsbG93cyBPcmJpdCB0byBiaW5kIGtleWJvYXJkIGV2ZW50cyB0byB0aGUgc2xpZGVyLCB0byBhbmltYXRlIGZyYW1lcyB3aXRoIGFycm93IGtleXNcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAqIEBkZWZhdWx0IHRydWVcbiAgKi9cbiAgYWNjZXNzaWJsZTogdHJ1ZSxcblxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIgb2YgT3JiaXRcbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgJ29yYml0LWNvbnRhaW5lcidcbiAgKi9cbiAgY29udGFpbmVyQ2xhc3M6ICdvcmJpdC1jb250YWluZXInLFxuXG4gIC8qKlxuICAqIENsYXNzIGFwcGxpZWQgdG8gaW5kaXZpZHVhbCBzbGlkZXMuXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdvcmJpdC1zbGlkZSdcbiAgKi9cbiAgc2xpZGVDbGFzczogJ29yYml0LXNsaWRlJyxcblxuICAvKipcbiAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBidWxsZXQgY29udGFpbmVyLiBZb3UncmUgd2VsY29tZS5cbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgJ29yYml0LWJ1bGxldHMnXG4gICovXG4gIGJveE9mQnVsbGV0czogJ29yYml0LWJ1bGxldHMnLFxuXG4gIC8qKlxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBuZXh0YCBuYXZpZ2F0aW9uIGJ1dHRvbi5cbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICogQGRlZmF1bHQgJ29yYml0LW5leHQnXG4gICovXG4gIG5leHRDbGFzczogJ29yYml0LW5leHQnLFxuXG4gIC8qKlxuICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBwcmV2aW91c2AgbmF2aWdhdGlvbiBidXR0b24uXG4gICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdvcmJpdC1wcmV2aW91cydcbiAgKi9cbiAgcHJldkNsYXNzOiAnb3JiaXQtcHJldmlvdXMnLFxuXG4gIC8qKlxuICAqIEJvb2xlYW4gdG8gZmxhZyB0aGUganMgdG8gdXNlIG1vdGlvbiB1aSBjbGFzc2VzIG9yIG5vdC4gRGVmYXVsdCB0byB0cnVlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAqIEBkZWZhdWx0IHRydWVcbiAgKi9cbiAgdXNlTVVJOiB0cnVlXG59O1xuXG52YXIgTWVudVBsdWdpbnMgPSB7XG4gIGRyb3Bkb3duOiB7XG4gICAgY3NzQ2xhc3M6ICdkcm9wZG93bicsXG4gICAgcGx1Z2luOiBEcm9wZG93bk1lbnVcbiAgfSxcbiAgZHJpbGxkb3duOiB7XG4gICAgY3NzQ2xhc3M6ICdkcmlsbGRvd24nLFxuICAgIHBsdWdpbjogRHJpbGxkb3duXG4gIH0sXG4gIGFjY29yZGlvbjoge1xuICAgIGNzc0NsYXNzOiAnYWNjb3JkaW9uLW1lbnUnLFxuICAgIHBsdWdpbjogQWNjb3JkaW9uTWVudVxuICB9XG59OyAvLyBpbXBvcnQgXCJmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnMuanNcIjtcblxuLyoqXG4gKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbnZhciBSZXNwb25zaXZlTWVudSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoUmVzcG9uc2l2ZU1lbnUsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNpdmVNZW51KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlTWVudSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJlc3BvbnNpdmVNZW51KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlTWVudSwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcmVzcG9uc2l2ZSBtZW51LlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVNZW51XG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVNZW51I2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtbWVudScpO1xuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Jlc3BvbnNpdmVNZW51JzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtUmVzcG9uc2l2ZU1lbnUnIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7IC8vIFRoZSBmaXJzdCB0aW1lIGFuIEludGVyY2hhbmdlIHBsdWdpbiBpcyBpbml0aWFsaXplZCwgdGhpcy5ydWxlcyBpcyBjb252ZXJ0ZWQgZnJvbSBhIHN0cmluZyBvZiBcImNsYXNzZXNcIiB0byBhbiBvYmplY3Qgb2YgcnVsZXNcblxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTsgLy8gUGFyc2UgcnVsZXMgZnJvbSBcImNsYXNzZXNcIiBwdWxsZWQgZnJvbSBkYXRhIGF0dHJpYnV0ZVxuXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTsgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHJ1bGUgZm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xuICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xuICAgICAgICAgIHZhciBydWxlUGx1Z2luID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVsxXSA6IHJ1bGVbMF07XG5cbiAgICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJ1bGVzVHJlZVtydWxlU2l6ZV0gPSBNZW51UGx1Z2luc1tydWxlUGx1Z2luXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXNUcmVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xuICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgfSAvLyBBZGQgZGF0YS1tdXRhdGUgc2luY2UgY2hpbGRyZW4gbWF5IG5lZWQgaXQuXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1tdXRhdGUnKSB8fCBHZXRZb0RpZ2l0cyg2LCAncmVzcG9uc2l2ZS1tZW51JykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgICB9KTsgLy8gJCh3aW5kb3cpLm9uKCdyZXNpemUuemYuUmVzcG9uc2l2ZU1lbnUnLCBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgICAvLyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrTWVkaWFRdWVyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01lZGlhUXVlcmllcygpIHtcbiAgICAgIHZhciBtYXRjaGVkTXEsXG4gICAgICAgICAgX3RoaXMgPSB0aGlzOyAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlIGFuZCBmaW5kIHRoZSBsYXN0IG1hdGNoaW5nIHJ1bGVcblxuXG4gICAgICAkLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoTWVkaWFRdWVyeS5hdExlYXN0KGtleSkpIHtcbiAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBObyBtYXRjaD8gTm8gZGljZVxuXG4gICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuOyAvLyBQbHVnaW4gYWxyZWFkeSBpbml0aWFsaXplZD8gV2UgZ29vZFxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbikgcmV0dXJuOyAvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXG5cbiAgICAgICQuZWFjaChNZW51UGx1Z2lucywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xuICAgICAgfSk7IC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxuXG4gICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7IC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgcGx1Z2luIG9uIHRoaXMgZWxlbWVudCwgYXMgd2VsbCBhcyB0aGUgd2luZG93IHJlc2l6ZSBoYW5kbGVyIHRoYXQgc3dpdGNoZXMgdGhlIHBsdWdpbnMgb3V0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgJCh3aW5kb3cpLm9mZignLnpmLlJlc3BvbnNpdmVNZW51Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNpdmVNZW51O1xufShQbHVnaW4pO1xuXG5SZXNwb25zaXZlTWVudS5kZWZhdWx0cyA9IHt9O1xuXG4vKipcbiAqIFJlc3BvbnNpdmVUb2dnbGUgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGVcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqL1xuXG52YXIgUmVzcG9uc2l2ZVRvZ2dsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoUmVzcG9uc2l2ZVRvZ2dsZSwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2l2ZVRvZ2dsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZVRvZ2dsZSk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFJlc3BvbnNpdmVUb2dnbGUpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmVUb2dnbGUsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFJlc3BvbnNpdmVUb2dnbGVcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCB0YWIgYmFyIGZ1bmN0aW9uYWxpdHkgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmVzcG9uc2l2ZVRvZ2dsZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVzcG9uc2l2ZVRvZ2dsZSc7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFiIGJhciBieSBmaW5kaW5nIHRoZSB0YXJnZXQgZWxlbWVudCwgdG9nZ2xpbmcgZWxlbWVudCwgYW5kIHJ1bm5pbmcgdXBkYXRlKCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB2YXIgdGFyZ2V0SUQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtdG9nZ2xlJyk7XG5cbiAgICAgIGlmICghdGFyZ2V0SUQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignWW91ciB0YWIgYmFyIG5lZWRzIGFuIElEIG9mIGEgTWVudSBhcyB0aGUgdmFsdWUgb2YgZGF0YS10YWItYmFyLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiR0YXJnZXRNZW51ID0gJChcIiNcIi5jb25jYXQodGFyZ2V0SUQpKTtcbiAgICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzKS5kYXRhKCd0b2dnbGUnKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gdGFyZ2V0SUQgfHwgdGFyZ2V0ID09PSBcIlwiO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLiR0YXJnZXRNZW51LmRhdGEoKSk7IC8vIElmIHRoZXkgd2VyZSBzZXQsIHBhcnNlIHRoZSBhbmltYXRpb24gY2xhc3Nlc1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5vcHRpb25zLmFuaW1hdGUuc3BsaXQoJyAnKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbk91dCA9IGlucHV0WzFdIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIgdG8gd29yay5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuXG4gICAgICB0aGlzLl91cGRhdGVNcUhhbmRsZXIgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcbiAgICAgIHRoaXMuJHRvZ2dsZXIub24oJ2NsaWNrLnpmLnJlc3BvbnNpdmVUb2dnbGUnLCB0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XG4gICAgICAvLyBNb2JpbGVcbiAgICAgIGlmICghTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS5oaWRlKCk7XG4gICAgICB9IC8vIERlc2t0b3BcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIuIFRoZSB0b2dnbGUgb25seSBoYXBwZW5zIGlmIHRoZSBzY3JlZW4gaXMgc21hbGwgZW5vdWdoIHRvIGFsbG93IGl0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZU1lbnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlTWVudSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIU1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIgdG9nZ2xlcy5cbiAgICAgICAgICogQGV2ZW50IFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJHRhcmdldE1lbnUuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgTW90aW9uLmFuaW1hdGVJbih0aGlzLiR0YXJnZXRNZW51LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCd0b2dnbGVkLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcblxuICAgICAgICAgICAgICBfdGhpczIuJHRhcmdldE1lbnUuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXJIYW5kbGVyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kdGFyZ2V0TWVudSwgdGhpcy5hbmltYXRpb25PdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApO1xuICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XG4gICAgICB0aGlzLiR0b2dnbGVyLm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICAgICQod2luZG93KS5vZmYoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3VwZGF0ZU1xSGFuZGxlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNpdmVUb2dnbGU7XG59KFBsdWdpbik7XG5cblJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBUaGUgYnJlYWtwb2ludCBhZnRlciB3aGljaCB0aGUgbWVudSBpcyBhbHdheXMgc2hvd24sIGFuZCB0aGUgdGFiIGJhciBpcyBoaWRkZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ21lZGl1bSdcbiAgICovXG4gIGhpZGVGb3I6ICdtZWRpdW0nLFxuXG4gIC8qKlxuICAgKiBUbyBkZWNpZGUgaWYgdGhlIHRvZ2dsZSBzaG91bGQgYmUgYW5pbWF0ZWQgb3Igbm90LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYW5pbWF0ZTogZmFsc2Vcbn07XG5cbi8qKlxuICogUmV2ZWFsIG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXZlYWxcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb24gaWYgdXNpbmcgYW5pbWF0aW9uc1xuICovXG5cbnZhciBSZXZlYWwgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFJldmVhbCwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gUmV2ZWFsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXZlYWwpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihSZXZlYWwpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJldmVhbCwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJldmVhbC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBSZXZlYWxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGZvciB0aGUgbW9kYWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXZlYWwnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5faW5pdCgpOyAvLyBUb3VjaCBhbmQgVHJpZ2dlcnMgaW5pdCBhcmUgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBpbml0aWFsaXplZFxuXG5cbiAgICAgIFRvdWNoLmluaXQoJCk7XG4gICAgICBUcmlnZ2Vycy5pbml0KCQpO1xuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ1JldmVhbCcsIHtcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbW9kYWwgYnkgYWRkaW5nIHRoZSBvdmVybGF5IGFuZCBjbG9zZSBidXR0b25zLCAoaWYgc2VsZWN0ZWQpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7XG5cbiAgICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG4gICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLmNhY2hlZCA9IHtcbiAgICAgICAgbXE6IE1lZGlhUXVlcnkuY3VycmVudFxuICAgICAgfTtcbiAgICAgIHRoaXMuJGFuY2hvciA9ICQoXCJbZGF0YS1vcGVuPVxcXCJcIi5jb25jYXQodGhpcy5pZCwgXCJcXFwiXVwiKSkubGVuZ3RoID8gJChcIltkYXRhLW9wZW49XFxcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIlxcXCJdXCIpKSA6ICQoXCJbZGF0YS10b2dnbGU9XFxcIlwiLmNvbmNhdCh0aGlzLmlkLCBcIlxcXCJdXCIpKTtcbiAgICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiB0aGlzLmlkLFxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICd0YWJpbmRleCc6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZnVsbCcpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm92ZXJsYXkgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5ICYmICF0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgIHRoaXMuJG92ZXJsYXkgPSB0aGlzLl9tYWtlT3ZlcmxheSh0aGlzLmlkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ3JvbGUnOiAnZGlhbG9nJyxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiB0aGlzLmlkLFxuICAgICAgICAnZGF0YS1yZXNpemUnOiB0aGlzLmlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8oJCh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnd2l0aG91dC1vdmVybGF5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSBcIiNcIi5jb25jYXQodGhpcy5pZCkpIHtcbiAgICAgICAgdGhpcy5vbkxvYWRMaXN0ZW5lciA9IG9uTG9hZCgkKHdpbmRvdyksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLm9wZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb3ZlcmxheSBkaXYgdG8gZGlzcGxheSBiZWhpbmQgdGhlIG1vZGFsLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZU92ZXJsYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VPdmVybGF5KCkge1xuICAgICAgdmFyIGFkZGl0aW9uYWxPdmVybGF5Q2xhc3NlcyA9ICcnO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFkZGl0aW9uYWxPdmVybGF5Q2xhc3Nlcykge1xuICAgICAgICBhZGRpdGlvbmFsT3ZlcmxheUNsYXNzZXMgPSAnICcgKyB0aGlzLm9wdGlvbnMuYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncmV2ZWFsLW92ZXJsYXknICsgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzKS5hcHBlbmRUbyh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHBvc2l0aW9uIG9mIG1vZGFsXG4gICAgICogVE9ETzogIEZpZ3VyZSBvdXQgaWYgd2UgYWN0dWFsbHkgbmVlZCB0byBjYWNoZSB0aGVzZSB2YWx1ZXMgb3IgaWYgaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIG91dGVyV2lkdGggPSAkKHdpbmRvdykud2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLiRlbGVtZW50Lm91dGVySGVpZ2h0KCk7XG4gICAgICB2YXIgb3V0ZXJIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICB2YXIgbGVmdCxcbiAgICAgICAgICB0b3AgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhPZmZzZXQgPT09ICdhdXRvJykge1xuICAgICAgICBsZWZ0ID0gcGFyc2VJbnQoKG91dGVyV2lkdGggLSB3aWR0aCkgLyAyLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLmhPZmZzZXQsIDEwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52T2Zmc2V0ID09PSAnYXV0bycpIHtcbiAgICAgICAgaWYgKGhlaWdodCA+IG91dGVySGVpZ2h0KSB7XG4gICAgICAgICAgdG9wID0gcGFyc2VJbnQoTWF0aC5taW4oMTAwLCBvdXRlckhlaWdodCAvIDEwKSwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KChvdXRlckhlaWdodCAtIGhlaWdodCkgLyA0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnZPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgdG9wID0gcGFyc2VJbnQodGhpcy5vcHRpb25zLnZPZmZzZXQsIDEwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICAgdG9wOiB0b3AgKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBvbmx5IHdvcnJ5IGFib3V0IGxlZnQgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBvdmVybGF5IG9yIHdlIGhhdmUgYSBob3Jpem9udGFsIG9mZnNldCxcbiAgICAgIC8vIG90aGVyd2lzZSB3ZSdyZSBwZXJmZWN0bHkgaW4gdGhlIG1pZGRsZVxuXG5cbiAgICAgIGlmICghdGhpcy4kb3ZlcmxheSB8fCB0aGlzLm9wdGlvbnMuaE9mZnNldCAhPT0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICAgICBsZWZ0OiBsZWZ0ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgICAgIG1hcmdpbjogJzBweCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xuICAgICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gY2xvc2VaZlRyaWdnZXIoZXZlbnQsICRlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJChldmVudC50YXJnZXQpLnBhcmVudHMoJ1tkYXRhLWNsb3NhYmxlXScpWzBdID09PSAkZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gb25seSBjbG9zZSByZXZlYWwgd2hlbiBpdCdzIGV4cGxpY2l0bHkgY2FsbGVkXG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmNsb3NlLmFwcGx5KF90aGlzMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IGZ1bmN0aW9uIHJlc2l6ZW1lWmZUcmlnZ2VyKCkge1xuICAgICAgICAgIF90aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYuZHJvcGRvd24gdGFwLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSB8fCAhJC5jb250YWlucyhkb2N1bWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKFwiaGFzaGNoYW5nZS56Zi5yZXZlYWw6XCIuY29uY2F0KHRoaXMuaWQpLCB0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBtb2RhbCBtZXRob2RzIG9uIGJhY2svZm9yd2FyZCBidXR0b24gY2xpY2tzIG9yIGFueSBvdGhlciBldmVudCB0aGF0IHRyaWdnZXJzIGhhc2hjaGFuZ2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3RhdGUoZSkge1xuICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSAnIycgKyB0aGlzLmlkICYmICF0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAqIERpc2FibGVzIHRoZSBzY3JvbGwgd2hlbiBSZXZlYWwgaXMgc2hvd24gdG8gcHJldmVudCB0aGUgYmFja2dyb3VuZCBmcm9tIHNoaWZ0aW5nXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wIC0gU2Nyb2xsIHRvIHZpc3VhbGx5IGFwcGx5LCB3aW5kb3cgY3VycmVudCBzY3JvbGwgYnkgZGVmYXVsdFxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGlzYWJsZVNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzYWJsZVNjcm9sbChzY3JvbGxUb3ApIHtcbiAgICAgIHNjcm9sbFRvcCA9IHNjcm9sbFRvcCB8fCAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG5cbiAgICAgIGlmICgkKGRvY3VtZW50KS5oZWlnaHQoKSA+ICQod2luZG93KS5oZWlnaHQoKSkge1xuICAgICAgICAkKFwiaHRtbFwiKS5jc3MoXCJ0b3BcIiwgLXNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVlbmFibGVzIHRoZSBzY3JvbGwgd2hlbiBSZXZlYWwgY2xvc2VzXG4gICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsVG9wIC0gU2Nyb2xsIHRvIHJlc3RvcmUsIGh0bWwgXCJ0b3BcIiBwcm9wZXJ0eSBieSBkZWZhdWx0IChhcyBzZXQgYnkgYF9kaXNhYmxlU2Nyb2xsYClcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2VuYWJsZVNjcm9sbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5hYmxlU2Nyb2xsKHNjcm9sbFRvcCkge1xuICAgICAgc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIHx8IHBhcnNlSW50KCQoXCJodG1sXCIpLmNzcyhcInRvcFwiKSk7XG5cbiAgICAgIGlmICgkKGRvY3VtZW50KS5oZWlnaHQoKSA+ICQod2luZG93KS5oZWlnaHQoKSkge1xuICAgICAgICAkKFwiaHRtbFwiKS5jc3MoXCJ0b3BcIiwgXCJcIik7XG4gICAgICAgICQod2luZG93KS5zY3JvbGxUb3AoLXNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBtb2RhbCBjb250cm9sbGVkIGJ5IGB0aGlzLiRhbmNob3JgLCBhbmQgY2xvc2VzIGFsbCBvdGhlcnMgYnkgZGVmYXVsdC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgUmV2ZWFsI2Nsb3NlbWVcbiAgICAgKiBAZmlyZXMgUmV2ZWFsI29wZW5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAvLyBlaXRoZXIgdXBkYXRlIG9yIHJlcGxhY2UgYnJvd3NlciBoaXN0b3J5XG4gICAgICB2YXIgaGFzaCA9IFwiI1wiLmNvbmNhdCh0aGlzLmlkKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCAhPT0gaGFzaCkge1xuICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCBoYXNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgaGFzaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1lbWJlciBhbmNob3IgdGhhdCBvcGVuZWQgaXQgdG8gc2V0IGZvY3VzIGJhY2sgbGF0ZXIsIGhhdmUgZ2VuZXJhbCBhbmNob3JzIGFzIGZhbGxiYWNrXG5cblxuICAgICAgdGhpcy4kYWN0aXZlQW5jaG9yID0gJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyh0aGlzLiRhbmNob3IpID8gJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA6IHRoaXMuJGFuY2hvcjtcbiAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlOyAvLyBNYWtlIGVsZW1lbnRzIGludmlzaWJsZSwgYnV0IHJlbW92ZSBkaXNwbGF5OiBub25lIHNvIHdlIGNhbiBnZXQgc2l6ZSBhbmQgcG9zaXRpb25pbmdcblxuICAgICAgdGhpcy4kZWxlbWVudC5jc3Moe1xuICAgICAgICAndmlzaWJpbGl0eSc6ICdoaWRkZW4nXG4gICAgICB9KS5zaG93KCkuc2Nyb2xsVG9wKDApO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3Moe1xuICAgICAgICAgICd2aXNpYmlsaXR5JzogJ2hpZGRlbidcbiAgICAgICAgfSkuc2hvdygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5jc3Moe1xuICAgICAgICAndmlzaWJpbGl0eSc6ICcnXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kb3ZlcmxheS5jc3Moe1xuICAgICAgICAgICd2aXNpYmlsaXR5JzogJydcbiAgICAgICAgfSkuaGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYXN0JykpIHtcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmFkZENsYXNzKCdmYXN0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnc2xvdycpKSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnc2xvdycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG1vZGFsIG9wZW5zLlxuICAgICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxuICAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5yZXZlYWwnLCB0aGlzLmlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCQoJy5yZXZlYWw6dmlzaWJsZScpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlU2Nyb2xsKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgcmV2ZWFsXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25Jbikge1xuICAgICAgICB2YXIgYWZ0ZXJBbmltYXRpb24gPSBmdW5jdGlvbiBhZnRlckFuaW1hdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogLTFcbiAgICAgICAgICB9KS5mb2N1cygpO1xuXG4gICAgICAgICAgX3RoaXMuX2FkZEdsb2JhbENsYXNzZXMoKTtcblxuICAgICAgICAgIEtleWJvYXJkLnRyYXBGb2N1cyhfdGhpcy4kZWxlbWVudCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgTW90aW9uLmFuaW1hdGVJbih0aGlzLiRvdmVybGF5LCAnZmFkZS1pbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXM0LiRlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3Qgb2JqZWN0IGhhdmluZyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIF90aGlzNC5mb2N1c2FibGVFbGVtZW50cyA9IEtleWJvYXJkLmZpbmRGb2N1c2FibGUoX3RoaXM0LiRlbGVtZW50KTtcbiAgICAgICAgICAgIGFmdGVyQW5pbWF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8galF1ZXJ5IG1ldGhvZCBvZiByZXZlYWxcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5zaG93KDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuc2hvdyh0aGlzLm9wdGlvbnMuc2hvd0RlbGF5KTtcbiAgICAgICAgfSAvLyBoYW5kbGUgYWNjZXNzaWJpbGl0eVxuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxuICAgICAgICAndGFiaW5kZXgnOiAtMVxuICAgICAgfSkuZm9jdXMoKTtcbiAgICAgIEtleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcblxuICAgICAgdGhpcy5fYWRkR2xvYmFsQ2xhc3NlcygpO1xuXG4gICAgICB0aGlzLl9hZGRHbG9iYWxMaXN0ZW5lcnMoKTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgbW9kYWwgaGFzIHN1Y2Nlc3NmdWxseSBvcGVuZWQuXG4gICAgICAgKiBAZXZlbnQgUmV2ZWFsI29wZW5cbiAgICAgICAqL1xuXG5cbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5yZXZlYWwnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjbGFzc2VzIGFuZCBsaXN0ZW5lcnMgb24gZG9jdW1lbnQgcmVxdWlyZWQgYnkgb3BlbiBtb2RhbHMuXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGNsYXNzZXMgYXJlIGFkZGVkIGFuZCB1cGRhdGVkOlxuICAgICAqIC0gYC5pcy1yZXZlYWwtb3BlbmAgLSBQcmV2ZW50cyB0aGUgc2Nyb2xsIG9uIGRvY3VtZW50XG4gICAgICogLSBgLnpmLWhhcy1zY3JvbGxgICAtIERpc3BsYXlzIGEgZGlzYWJsZWQgc2Nyb2xsYmFyIG9uIGRvY3VtZW50IGlmIHJlcXVpcmVkIGxpa2UgaWYgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbCB3YXMgbm90IGRpc2FibGVkLiBUaGlzIHByZXZlbnQgYSBcInNoaWZ0XCIgb2YgdGhlIHBhZ2UgY29udGVudCBkdWVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNjcm9sbGJhciBkaXNhcHBlYXJpbmcgd2hlbiB0aGUgbW9kYWwgb3BlbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEdsb2JhbENsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEdsb2JhbENsYXNzZXMoKSB7XG4gICAgICB2YXIgdXBkYXRlU2Nyb2xsYmFyQ2xhc3MgPSBmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJDbGFzcygpIHtcbiAgICAgICAgJCgnaHRtbCcpLnRvZ2dsZUNsYXNzKCd6Zi1oYXMtc2Nyb2xsJywgISEoJChkb2N1bWVudCkuaGVpZ2h0KCkgPiAkKHdpbmRvdykuaGVpZ2h0KCkpKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXIucmV2ZWFsU2Nyb2xsYmFyTGlzdGVuZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTY3JvbGxiYXJDbGFzcygpO1xuICAgICAgfSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJDbGFzcygpO1xuICAgICAgJCgnaHRtbCcpLmFkZENsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGNsYXNzZXMgYW5kIGxpc3RlbmVycyBvbiBkb2N1bWVudCB0aGF0IHdlcmUgcmVxdWlyZWQgYnkgb3BlbiBtb2RhbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVHbG9iYWxDbGFzc2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVHbG9iYWxDbGFzc2VzKCkge1xuICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXIucmV2ZWFsU2Nyb2xsYmFyTGlzdGVuZXInKTtcbiAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcbiAgICAgICQoJ2h0bWwnKS5yZW1vdmVDbGFzcygnemYtaGFzLXNjcm9sbCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV4dHJhIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgYm9keSBhbmQgd2luZG93IGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZEdsb2JhbExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkR2xvYmFsTGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLiRlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBjbGVhbnVwLCBkb24ndCBmcmVhayBvdXRcblxuXG4gICAgICB0aGlzLmZvY3VzYWJsZUVsZW1lbnRzID0gS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmICF0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbikge1xuICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrLnpmLmRyb3Bkb3duIHRhcC56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLCBlLnRhcmdldCkgfHwgISQuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdSZXZlYWwnLCB7XG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG1vZGFsLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7IC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgaGlkaW5nXG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRpb25PdXQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSwgJ2ZhZGUtb3V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBNb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0LCBmaW5pc2hVcCk7XG4gICAgICB9IC8vIGpRdWVyeSBtZXRob2Qgb2YgaGlkaW5nXG4gICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUodGhpcy5vcHRpb25zLmhpZGVEZWxheSk7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgwLCBmaW5pc2hVcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaFVwKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbmRpdGlvbmFscyB0byByZW1vdmUgZXh0cmEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIG9uIG9wZW5cblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4gICAgICAgICQoJ2JvZHknKS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duIHRhcC56Zi5kcm9wZG93bicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTtcblxuICAgICAgZnVuY3Rpb24gZmluaXNoVXAoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0b3AgYmVmb3JlIHRoZSBtb2RhbCBpcyBjbG9zZWQgYW5kIHJlc3RvcmUgdGhlIHNjcm9sbCBhZnRlci5cbiAgICAgICAgLy8gVE9ETzogdXNlIGNvbXBvbmVudCBwcm9wZXJ0aWVzIGluc3RlYWQgb2YgSFRNTCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZm91bmRhdGlvbi9mb3VuZGF0aW9uLXNpdGVzL3B1bGwvMTA3ODZcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHBhcnNlSW50KCQoXCJodG1sXCIpLmNzcyhcInRvcFwiKSk7XG5cbiAgICAgICAgaWYgKCQoJy5yZXZlYWw6dmlzaWJsZScpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF90aGlzLl9yZW1vdmVHbG9iYWxDbGFzc2VzKCk7IC8vIGFsc28gcmVtb3ZlIC5pcy1yZXZlYWwtb3BlbiBmcm9tIHRoZSBodG1sIGVsZW1lbnQgd2hlbiB0aGVyZSBpcyBubyBvcGVuZWQgcmV2ZWFsXG5cbiAgICAgICAgfVxuXG4gICAgICAgIEtleWJvYXJkLnJlbGVhc2VGb2N1cyhfdGhpcy4kZWxlbWVudCk7XG5cbiAgICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICBpZiAoJCgnLnJldmVhbDp2aXNpYmxlJykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgX3RoaXMuX2VuYWJsZVNjcm9sbChzY3JvbGxUb3ApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cbiAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlZFxuICAgICAgICAqL1xuXG5cbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIFJlc2V0cyB0aGUgbW9kYWwgY29udGVudFxuICAgICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAqL1xuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVzZXRPbkNsb3NlKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTsgLy8gSWYgZGVlcExpbmsgYW5kIHdlIGRpZCBub3Qgc3dpdGNoZWQgdG8gYW4gb3RoZXIgbW9kYWwuLi5cblxuICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVlcExpbmsgJiYgd2luZG93LmxvY2F0aW9uLmhhc2ggPT09IFwiI1wiLmNvbmNhdCh0aGlzLmlkKSkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGhpc3RvcnkgaGFzaFxuICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKSB7XG4gICAgICAgICAgdmFyIHVybFdpdGhvdXRIYXNoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBkYXRlSGlzdG9yeSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywgdXJsV2l0aG91dEhhc2gpOyAvLyByZW1vdmUgdGhlIGhhc2hcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCBkb2N1bWVudC50aXRsZSwgdXJsV2l0aG91dEhhc2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJGFjdGl2ZUFuY2hvci5mb2N1cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlZCBzdGF0ZSBvZiBhIG1vZGFsLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmRUbygkKHRoaXMub3B0aW9ucy5hcHBlbmRUbykpOyAvLyBtb3ZlICRlbGVtZW50IG91dHNpZGUgb2YgJG92ZXJsYXkgdG8gcHJldmVudCBlcnJvciB1bnJlZ2lzdGVyUGx1Z2luKClcblxuICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoKS5vZmYoKS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKCkub2ZmKCk7XG4gICAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYnKTtcbiAgICAgICQod2luZG93KS5vZmYoXCIuemYucmV2ZWFsOlwiLmNvbmNhdCh0aGlzLmlkKSk7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcblxuICAgICAgaWYgKCQoJy5yZXZlYWw6dmlzaWJsZScpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVHbG9iYWxDbGFzc2VzKCk7IC8vIGFsc28gcmVtb3ZlIC5pcy1yZXZlYWwtb3BlbiBmcm9tIHRoZSBodG1sIGVsZW1lbnQgd2hlbiB0aGVyZSBpcyBubyBvcGVuZWQgcmV2ZWFsXG5cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmV2ZWFsO1xufShQbHVnaW4pO1xuXG5SZXZlYWwuZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICBhbmltYXRpb25JbjogJycsXG5cbiAgLyoqXG4gICAqIE1vdGlvbi1VSSBjbGFzcyB0byB1c2UgZm9yIGFuaW1hdGVkIGVsZW1lbnRzLiBJZiBub25lIHVzZWQsIGRlZmF1bHRzIHRvIHNpbXBsZSBzaG93L2hpZGUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGFuaW1hdGlvbk91dDogJycsXG5cbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgb3BlbmluZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgc2hvd0RlbGF5OiAwLFxuXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGhpZGVEZWxheTogMCxcblxuICAvKipcbiAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkvb3ZlcmxheSB0byBjbG9zZSB0aGUgbW9kYWwuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNsb3NlT25DbGljazogdHJ1ZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBjbG9zZSBpZiB0aGUgdXNlciBwcmVzc2VzIHRoZSBgRVNDQVBFYCBrZXkuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNsb3NlT25Fc2M6IHRydWUsXG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGFsbG93cyBtdWx0aXBsZSBtb2RhbHMgdG8gYmUgZGlzcGxheWVkIGF0IG9uY2UuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBtdWx0aXBsZU9wZW5lZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSBtb2RhbCBzaG91bGQgcHVzaCBkb3duIGZyb20gdGhlIHRvcCBvZiB0aGUgc2NyZWVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxuICAgKiBAZGVmYXVsdCBhdXRvXG4gICAqL1xuICB2T2Zmc2V0OiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSBtb2RhbCBzaG91bGQgcHVzaCBpbiBmcm9tIHRoZSBzaWRlIG9mIHRoZSBzY3JlZW4uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XG4gICAqIEBkZWZhdWx0IGF1dG9cbiAgICovXG4gIGhPZmZzZXQ6ICdhdXRvJyxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBiZSBmdWxsc2NyZWVuLCBjb21wbGV0ZWx5IGJsb2NraW5nIG91dCB0aGUgcmVzdCBvZiB0aGUgdmlldy4gSlMgY2hlY2tzIGZvciB0aGlzIGFzIHdlbGwuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmdWxsU2NyZWVuOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBnZW5lcmF0ZSBhbiBvdmVybGF5IGRpdiwgd2hpY2ggd2lsbCBjb3ZlciB0aGUgdmlldyB3aGVuIG1vZGFsIG9wZW5zLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBvdmVybGF5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIHJlbW92ZSBhbmQgcmVpbmplY3QgbWFya3VwIG9uIGNsb3NlLiBTaG91bGQgYmUgdHJ1ZSBpZiB1c2luZyB2aWRlbyBlbGVtZW50cyB3L28gdXNpbmcgcHJvdmlkZXIncyBhcGksIG90aGVyd2lzZSwgdmlkZW9zIHdpbGwgY29udGludWUgdG8gcGxheSBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlc2V0T25DbG9zZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIG1vZGFsLlxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIGhhc2ggd2hlbiB0aGUgbW9kYWwgaXMgb3BlbmVkL2Nsb3NlZCwgYW5kIG9wZW4vY2xvc2UgdGhlIG1vZGFsIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkZWVwTGluazogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGBkZWVwTGlua2AgaXMgZW5hYmxlZCwgdXBkYXRlIHRoZSBicm93c2VyIGhpc3Rvcnkgd2l0aCB0aGUgb3BlbiBtb2RhbFxuICAgKiBAb3B0aW9uXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB1cGRhdGVIaXN0b3J5OiBmYWxzZSxcblxuICAvKipcbiAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGFwcGVuZCB0byBjdXN0b20gZGl2LlxuICAqIEBvcHRpb25cbiAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0IFwiYm9keVwiXG4gICovXG4gIGFwcGVuZFRvOiBcImJvZHlcIixcblxuICAvKipcbiAgICogQWxsb3dzIGFkZGluZyBhZGRpdGlvbmFsIGNsYXNzIG5hbWVzIHRvIHRoZSByZXZlYWwgb3ZlcmxheS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgYWRkaXRpb25hbE92ZXJsYXlDbGFzc2VzOiAnJ1xufTtcblxuLyoqXG4gKiBTbGlkZXIgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcbiAqL1xuXG52YXIgU2xpZGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luKSB7XG4gIF9pbmhlcml0cyhTbGlkZXIsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFNsaWRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU2xpZGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbGlkZXIsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHNsaWRlciBjb250cm9sLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFNsaWRlclxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBzbGlkZXIgY29udHJvbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTbGlkZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1NsaWRlcic7IC8vIGllOSBiYWNrIGNvbXBhdFxuICAgICAgLy8gVG91Y2ggYW5kIFRyaWdnZXJzIGluaXRzIGFyZSBpZGVtcG90ZW50LCB3ZSBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0J3MgaW5pdGlhbGllZC5cblxuICAgICAgVG91Y2guaW5pdCgkKTtcbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ1NsaWRlcicsIHtcbiAgICAgICAgJ2x0cic6IHtcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnaW5jcmVhc2UnLFxuICAgICAgICAgICdBUlJPV19VUCc6ICdpbmNyZWFzZScsXG4gICAgICAgICAgJ0FSUk9XX0RPV04nOiAnZGVjcmVhc2UnLFxuICAgICAgICAgICdBUlJPV19MRUZUJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfUklHSFQnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1VQJzogJ2luY3JlYXNlX2Zhc3QnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19ET1dOJzogJ2RlY3JlYXNlX2Zhc3QnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19MRUZUJzogJ2RlY3JlYXNlX2Zhc3QnLFxuICAgICAgICAgICdIT01FJzogJ21pbicsXG4gICAgICAgICAgJ0VORCc6ICdtYXgnXG4gICAgICAgIH0sXG4gICAgICAgICdydGwnOiB7XG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnaW5jcmVhc2UnLFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdkZWNyZWFzZScsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0xFRlQnOiAnaW5jcmVhc2VfZmFzdCcsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlX2Zhc3QnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWxpemVzIHRoZSBwbHVnaW4gYnkgcmVhZGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMsIGNyZWF0aW5nIGNvbGxlY3Rpb25zIGFuZCBzZXR0aW5nIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUocykuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICB0aGlzLmhhbmRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJyk7XG4gICAgICB0aGlzLiRoYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoMCk7XG4gICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuaW5wdXRzLmxlbmd0aCA/IHRoaXMuaW5wdXRzLmVxKDApIDogJChcIiNcIi5jb25jYXQodGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkpO1xuICAgICAgdGhpcy4kZmlsbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWZpbGxdJykuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJywgMCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZWQgfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gJCgpLmFkZCh0aGlzLiRpbnB1dCk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5iaW5kaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMCk7XG5cbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kaGFuZGxlMiA9IHRoaXMuaGFuZGxlcy5lcSgxKTtcbiAgICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID4gMSA/IHRoaXMuaW5wdXRzLmVxKDEpIDogJChcIiNcIi5jb25jYXQodGhpcy4kaGFuZGxlMi5hdHRyKCdhcmlhLWNvbnRyb2xzJykpKTtcblxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRzWzFdKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLmlucHV0cy5hZGQodGhpcy4kaW5wdXQyKTtcbiAgICAgICAgfSAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xuXG5cbiAgICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMSk7XG4gICAgICB9IC8vIFNldCBoYW5kbGUgcG9zaXRpb25zXG5cblxuICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIYW5kbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhhbmRsZXMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLmlucHV0cy5lcSgwKS52YWwoKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fc2V0SGFuZGxlUG9zKF90aGlzMi4kaGFuZGxlMiwgX3RoaXMyLmlucHV0cy5lcSgxKS52YWwoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5pbnB1dHMuZXEoMCkudmFsKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVmbG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICB0aGlzLnNldEhhbmRsZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBAZnVuY3Rpb25cbiAgICAqIEBwcml2YXRlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBmbG9hdGluZyBwb2ludCAodGhlIHZhbHVlKSB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0byBhIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgKHRoZSBpbnZlcnNlIG9mIF92YWx1ZSlcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BjdE9mQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wY3RPZkJhcih2YWx1ZSkge1xuICAgICAgdmFyIHBjdE9mQmFyID0gcGVyY2VudCh2YWx1ZSAtIHRoaXMub3B0aW9ucy5zdGFydCwgdGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCk7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xuICAgICAgICBjYXNlIFwicG93XCI6XG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX3Bvd1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwY3RPZkJhci50b0ZpeGVkKDIpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBwY3RPZkJhciAtIGZsb2F0aW5nIHBvaW50LCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHNsaWRlciAodHlwaWNhbGx5IGJldHdlZW4gMC0xKSB0byBiZSB0cmFuc2Zvcm1lZCB0byBhIHZhbHVlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl92YWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsdWUocGN0T2ZCYXIpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLnBvc2l0aW9uVmFsdWVGdW5jdGlvbikge1xuICAgICAgICBjYXNlIFwicG93XCI6XG4gICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX2xvZ1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCkge1xuICAgICAgICAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aGljaCBpcyB3b3JraW5nIHdpdGggbmVnYXRpdmUgdmFsdWVzIGZvciBzdGFydFxuICAgICAgICAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vYS8xMDE5MDg0XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh0aGlzLm9wdGlvbnMuZW5kKSArIHBjdE9mQmFyICogKHRoaXMub3B0aW9ucy5zdGFydCAtIHRoaXMub3B0aW9ucy5lbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgKiBwY3RPZkJhciArIHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBsb2cgZnVuY3Rpb25cbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2xvZ1RyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nVHJhbnNmb3JtKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUxvZyh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSwgdmFsdWUgKiAodGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UgLSAxKSArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIEBmdW5jdGlvblxuICAgICogQHByaXZhdGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBwb3dlciBmdW5jdGlvblxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcG93VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3dUcmFuc2Zvcm0odmFsdWUpIHtcbiAgICAgIHJldHVybiAoTWF0aC5wb3codGhpcy5vcHRpb25zLm5vbkxpbmVhckJhc2UsIHZhbHVlKSAtIDEpIC8gKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsb2NhdGlvbiAtIGZsb2F0aW5nIHBvaW50IGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIG9mIHRoZSBzbGlkZXIgYmFyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBvbiBjb21wbGV0aW9uLlxuICAgICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICAgKiBAZmlyZXMgU2xpZGVyI2NoYW5nZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRIYW5kbGVQb3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEhhbmRsZVBvcygkaG5kbCwgbG9jYXRpb24sIGNiKSB7XG4gICAgICAvLyBkb24ndCBtb3ZlIGlmIHRoZSBzbGlkZXIgaGFzIGJlZW4gZGlzYWJsZWQgc2luY2UgaXRzIGluaXRpYWxpemF0aW9uXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXG5cblxuICAgICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsgLy9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxuICAgICAgLy8gcHJldmVudCBzbGlkZXIgZnJvbSBydW5uaW5nIG91dCBvZiBib3VuZHMsIGlmIHZhbHVlIGV4Y2VlZHMgdGhlIGxpbWl0cyBzZXQgdGhyb3VnaCBvcHRpb25zLCBvdmVycmlkZSB0aGUgdmFsdWUgdG8gbWluL21heFxuXG4gICAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuc3RhcnQ7XG4gICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID4gdGhpcy5vcHRpb25zLmVuZCkge1xuICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0RibCA9IHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZDtcblxuICAgICAgaWYgKGlzRGJsKSB7XG4gICAgICAgIC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxuICAgICAgICBpZiAodGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCkge1xuICAgICAgICAgIHZhciBoMlZhbCA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMi5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xuICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGgxVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgdmVydCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcbiAgICAgICAgICBoT3JXID0gdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgICBsT3JUID0gdmVydCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgIGhhbmRsZURpbSA9ICRobmRsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxuICAgICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxuICAgICAgICAgIC8vcGVyY2VudGFnZSBvZiBiYXIgbWluL21heCB2YWx1ZSBiYXNlZCBvbiBjbGljayBvciBkcmFnIHBvaW50XG4gICAgICBwY3RPZkJhciA9IHRoaXMuX3BjdE9mQmFyKGxvY2F0aW9uKSxcbiAgICAgICAgICAvL251bWJlciBvZiBhY3R1YWwgcGl4ZWxzIHRvIHNoaWZ0IHRoZSBoYW5kbGUsIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9idGFpbmVkIGFib3ZlXG4gICAgICBweFRvTW92ZSA9IChlbGVtRGltIC0gaGFuZGxlRGltKSAqIHBjdE9mQmFyLFxuICAgICAgICAgIC8vcGVyY2VudGFnZSBvZiBiYXIgdG8gc2hpZnQgdGhlIGhhbmRsZVxuICAgICAgbW92ZW1lbnQgPSAocGVyY2VudChweFRvTW92ZSwgZWxlbURpbSkgKiAxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpOyAvL2ZpeGluZyB0aGUgZGVjaW1hbCB2YWx1ZSBmb3IgdGhlIGxvY2F0aW9uIG51bWJlciwgaXMgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMgYXMgYSBmaXhlZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxuXG5cbiAgICAgIGxvY2F0aW9uID0gcGFyc2VGbG9hdChsb2NhdGlvbi50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKSk7IC8vIGRlY2xhcmUgZW1wdHkgb2JqZWN0IGZvciBjc3MgYWRqdXN0bWVudHMsIG9ubHkgdXNlZCB3aXRoIDIgaGFuZGxlZC1zbGlkZXJzXG5cbiAgICAgIHZhciBjc3MgPSB7fTtcblxuICAgICAgdGhpcy5fc2V0VmFsdWVzKCRobmRsLCBsb2NhdGlvbik7IC8vIFRPRE8gdXBkYXRlIHRvIGNhbGN1bGF0ZSBiYXNlZCBvbiB2YWx1ZXMgc2V0IHRvIHJlc3BlY3RpdmUgaW5wdXRzPz9cblxuXG4gICAgICBpZiAoaXNEYmwpIHtcbiAgICAgICAgdmFyIGlzTGVmdEhuZGwgPSB0aGlzLmhhbmRsZXMuaW5kZXgoJGhuZGwpID09PSAwLFxuICAgICAgICAgICAgLy9lbXB0eSB2YXJpYWJsZSwgd2lsbCBiZSB1c2VkIGZvciBtaW4taGVpZ2h0L3dpZHRoIGZvciBmaWxsIGJhclxuICAgICAgICBkaW0sXG4gICAgICAgICAgICAvL3BlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgY29tcGFyZWQgdG8gdGhlIHNsaWRlciBiYXJcbiAgICAgICAgaGFuZGxlUGN0ID0gfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTsgLy9pZiBsZWZ0IGhhbmRsZSwgdGhlIG1hdGggaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gaWYgaXQncyB0aGUgcmlnaHQgaGFuZGxlLCBhbmQgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNoYW5nZWQgZm9yIHRoZSBmaWxsIGJhclxuXG4gICAgICAgIGlmIChpc0xlZnRIbmRsKSB7XG4gICAgICAgICAgLy9sZWZ0IG9yIHRvcCBwZXJjZW50YWdlIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSBmaWxsIGJhci5cbiAgICAgICAgICBjc3NbbE9yVF0gPSBcIlwiLmNvbmNhdChtb3ZlbWVudCwgXCIlXCIpOyAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cblxuICAgICAgICAgIGRpbSA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMlswXS5zdHlsZVtsT3JUXSkgLSBtb3ZlbWVudCArIGhhbmRsZVBjdDsgLy90aGlzIGNhbGxiYWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IGVycm9ycyBhbmQgYWxsb3cgdGhlIHByb3BlciBwbGFjZW1lbnQgYW5kIGluaXRpYWxpemF0aW9uIG9mIGEgMi1oYW5kbGVkIHNsaWRlclxuICAgICAgICAgIC8vcGx1cywgaXQgbWVhbnMgd2UgZG9uJ3QgY2FyZSBpZiAnZGltJyBpc05hTiBvbiBpbml0LCBpdCB3b24ndCBiZSBpbiB0aGUgZnV0dXJlLlxuXG4gICAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9IC8vdGhpcyBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGluaXRpYWxpemF0aW9uIG9mIDIgaGFuZGxlZCBzbGlkZXJzXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2p1c3QgY2FjaGluZyB0aGUgdmFsdWUgb2YgdGhlIGxlZnQvYm90dG9tIGhhbmRsZSdzIGxlZnQvdG9wIHByb3BlcnR5XG4gICAgICAgICAgdmFyIGhhbmRsZVBvcyA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlWzBdLnN0eWxlW2xPclRdKTsgLy9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuIFVzZSBpc05hTiB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyBmb3IgbnVtYmVycyA8PSAwXG4gICAgICAgICAgLy9iYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBvZiBtb3ZlbWVudCBvZiB0aGUgaGFuZGxlIGJlaW5nIG1hbmlwdWxhdGVkLCBsZXNzIHRoZSBvcHBvc2luZyBoYW5kbGUncyBsZWZ0L3RvcCBwb3NpdGlvbiwgcGx1cyB0aGUgcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBpdHNlbGZcblxuICAgICAgICAgIGRpbSA9IG1vdmVtZW50IC0gKGlzTmFOKGhhbmRsZVBvcykgPyAodGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCAtIHRoaXMub3B0aW9ucy5zdGFydCkgLyAoKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpIC8gMTAwKSA6IGhhbmRsZVBvcykgKyBoYW5kbGVQY3Q7XG4gICAgICAgIH0gLy8gYXNzaWduIHRoZSBtaW4taGVpZ2h0L3dpZHRoIHRvIG91ciBjc3Mgb2JqZWN0XG5cblxuICAgICAgICBjc3NbXCJtaW4tXCIuY29uY2F0KGhPclcpXSA9IFwiXCIuY29uY2F0KGRpbSwgXCIlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhhbmRsZSBpcyBkb25lIG1vdmluZy5cbiAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignbW92ZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XG4gICAgICB9KTsgLy9iZWNhdXNlIHdlIGRvbid0IGtub3cgZXhhY3RseSBob3cgdGhlIGhhbmRsZSB3aWxsIGJlIG1vdmVkLCBjaGVjayB0aGUgYW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gbW92ZS5cblxuICAgICAgdmFyIG1vdmVUaW1lID0gdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpID8gMTAwMCAvIDYwIDogdGhpcy5vcHRpb25zLm1vdmVUaW1lO1xuICAgICAgTW92ZShtb3ZlVGltZSwgJGhuZGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gYWRqdXN0aW5nIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlLCBiYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBjYWxjdWxhdGVkIGFib3ZlXG4gICAgICAgIC8vIGlmIG1vdmVtZW50IGlzTmFOLCB0aGF0IGlzIGJlY2F1c2UgdGhlIHNsaWRlciBpcyBoaWRkZW4gYW5kIHdlIGNhbm5vdCBkZXRlcm1pbmUgaGFuZGxlIHdpZHRoLFxuICAgICAgICAvLyBmYWxsIGJhY2sgdG8gbmV4dCBiZXN0IGd1ZXNzLlxuICAgICAgICBpZiAoaXNOYU4obW92ZW1lbnQpKSB7XG4gICAgICAgICAgJGhuZGwuY3NzKGxPclQsIFwiXCIuY29uY2F0KHBjdE9mQmFyICogMTAwLCBcIiVcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRobmRsLmNzcyhsT3JULCBcIlwiLmNvbmNhdChtb3ZlbWVudCwgXCIlXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xuICAgICAgICAgIC8vaWYgc2luZ2xlLWhhbmRsZWQsIGEgc2ltcGxlIG1ldGhvZCB0byBleHBhbmQgdGhlIGZpbGwgYmFyXG4gICAgICAgICAgX3RoaXMuJGZpbGwuY3NzKGhPclcsIFwiXCIuY29uY2F0KHBjdE9mQmFyICogMTAwLCBcIiVcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlLCB1c2UgdGhlIGNzcyBvYmplY3Qgd2UgY3JlYXRlZCBhYm92ZVxuICAgICAgICAgIF90aGlzLiRmaWxsLmNzcyhjc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgdmFsdWUgaGFzIG5vdCBiZWVuIGNoYW5nZSBmb3IgYSBnaXZlbiB0aW1lLlxuICAgICAgICogQGV2ZW50IFNsaWRlciNjaGFuZ2VkXG4gICAgICAgKi9cblxuICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xuICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2VkLnpmLnNsaWRlcicsIFskaG5kbF0pO1xuICAgICAgfSwgX3RoaXMub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBpbml0aWFsIGF0dHJpYnV0ZSBmb3IgdGhlIHNsaWRlciBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSBjdXJyZW50IGhhbmRsZS9pbnB1dCB0byB1c2UuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0SW5pdEF0dHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEluaXRBdHRyKGlkeCkge1xuICAgICAgdmFyIGluaXRWYWwgPSBpZHggPT09IDAgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IDogdGhpcy5vcHRpb25zLmluaXRpYWxFbmQ7XG4gICAgICB2YXIgaWQgPSB0aGlzLmlucHV0cy5lcShpZHgpLmF0dHIoJ2lkJykgfHwgR2V0WW9EaWdpdHMoNiwgJ3NsaWRlcicpO1xuICAgICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICdtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxuICAgICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgICAnc3RlcCc6IHRoaXMub3B0aW9ucy5zdGVwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKGluaXRWYWwpO1xuICAgICAgdGhpcy5oYW5kbGVzLmVxKGlkeCkuYXR0cih7XG4gICAgICAgICdyb2xlJzogJ3NsaWRlcicsXG4gICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXG4gICAgICAgICdhcmlhLXZhbHVlbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiB0aGlzLm9wdGlvbnMuc3RhcnQsXG4gICAgICAgICdhcmlhLXZhbHVlbm93JzogaW5pdFZhbCxcbiAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiB0aGlzLm9wdGlvbnMudmVydGljYWwgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnLFxuICAgICAgICAndGFiaW5kZXgnOiAwXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW5wdXQgYW5kIGBhcmlhLXZhbHVlbm93YCB2YWx1ZXMgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBoYW5kbGUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG9mIHRoZSBuZXcgdmFsdWUuXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VmFsdWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZXMoJGhhbmRsZSwgdmFsKSB7XG4gICAgICB2YXIgaWR4ID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KCRoYW5kbGUpIDogMDtcbiAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKHZhbCk7XG4gICAgICAkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnLCB2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGV2ZW50cyBvbiB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhhbmRsZS5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gY2FsY3VsYXRlIGZvciwgaWYgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG51bWJlciBmb3IgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxuICAgICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUV2ZW50KGUsICRoYW5kbGUsIHZhbCkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICAvL2NsaWNrIG9yIGRyYWcgZXZlbnRzXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgdmVydGljYWwgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gdmVydGljYWwgPyBlLnBhZ2VZIDogZS5wYWdlWCxcbiAgICAgICAgICAgIGJhckRpbSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLFxuICAgICAgICAgICAgd2luZG93U2Nyb2xsID0gdmVydGljYWwgPyAkKHdpbmRvdykuc2Nyb2xsVG9wKCkgOiAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xuXG4gICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dOyAvLyB0b3VjaCBldmVudHMgZW11bGF0ZWQgYnkgdGhlIHRvdWNoIHV0aWwgZ2l2ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JlZW4sIGFkZCB3aW5kb3cuc2Nyb2xsIHRvIGV2ZW50IGNvb3JkaW5hdGVzLi4uXG4gICAgICAgIC8vIGJlc3Qgd2F5IHRvIGd1ZXNzIHRoaXMgaXMgc2ltdWxhdGVkIGlzIGlmIGNsaWVudFkgPT0gcGFnZVlcblxuICAgICAgICBpZiAoZS5jbGllbnRZID09PSBlLnBhZ2VZKSB7XG4gICAgICAgICAgZXZlbnRPZmZzZXQgPSBldmVudE9mZnNldCArIHdpbmRvd1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBldmVudEZyb21CYXIgPSBldmVudE9mZnNldCAtIGVsZW1PZmZzZXQ7XG4gICAgICAgIHZhciBiYXJYWTtcblxuICAgICAgICBpZiAoZXZlbnRGcm9tQmFyIDwgMCkge1xuICAgICAgICAgIGJhclhZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudEZyb21CYXIgPiBiYXJEaW0pIHtcbiAgICAgICAgICBiYXJYWSA9IGJhckRpbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiYXJYWSA9IGV2ZW50RnJvbUJhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXRQY3QgPSBwZXJjZW50KGJhclhZLCBiYXJEaW0pO1xuICAgICAgICB2YWx1ZSA9IHRoaXMuX3ZhbHVlKG9mZnNldFBjdCk7IC8vIHR1cm4gZXZlcnl0aGluZyBhcm91bmQgZm9yIFJUTCwgeWF5IG1hdGghXG5cbiAgICAgICAgaWYgKHJ0bCgpICYmICF0aGlzLm9wdGlvbnMudmVydGljYWwpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5lbmQgLSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gX3RoaXMuX2FkanVzdFZhbHVlKG51bGwsIHZhbHVlKTsgLy9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xuXG4gICAgICAgIGlmICghJGhhbmRsZSkge1xuICAgICAgICAgIC8vZmlndXJlIG91dCB3aGljaCBoYW5kbGUgaXQgaXMsIHBhc3MgaXQgdG8gdGhlIG5leHQgZnVuY3Rpb24uXG4gICAgICAgICAgdmFyIGZpcnN0SG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZSwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pLFxuICAgICAgICAgICAgICBzZWNuZEhuZGxQb3MgPSBhYnNQb3NpdGlvbih0aGlzLiRoYW5kbGUyLCBkaXJlY3Rpb24sIGJhclhZLCBwYXJhbSk7XG4gICAgICAgICAgJGhhbmRsZSA9IGZpcnN0SG5kbFBvcyA8PSBzZWNuZEhuZGxQb3MgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2NoYW5nZSBldmVudCBvbiBpbnB1dFxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKG51bGwsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldEhhbmRsZVBvcygkaGFuZGxlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkanVzdGVzIHZhbHVlIGZvciBoYW5kbGUgaW4gcmVnYXJkIHRvIHN0ZXAgdmFsdWUuIHJldHVybnMgYWRqdXN0ZWQgdmFsdWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIHNlbGVjdGVkIGhhbmRsZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBhZGp1c3QuIHVzZWQgaWYgJGhhbmRsZSBpcyBmYWxzeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkanVzdFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGp1c3RWYWx1ZSgkaGFuZGxlLCB2YWx1ZSkge1xuICAgICAgdmFyIHZhbCxcbiAgICAgICAgICBzdGVwID0gdGhpcy5vcHRpb25zLnN0ZXAsXG4gICAgICAgICAgZGl2ID0gcGFyc2VGbG9hdChzdGVwIC8gMiksXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBwcmV2X3ZhbCxcbiAgICAgICAgICBuZXh0X3ZhbDtcblxuICAgICAgaWYgKCEhJGhhbmRsZSkge1xuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KCRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsID49IDApIHtcbiAgICAgICAgbGVmdCA9IHZhbCAlIHN0ZXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gc3RlcCArIHZhbCAlIHN0ZXA7XG4gICAgICB9XG5cbiAgICAgIHByZXZfdmFsID0gdmFsIC0gbGVmdDtcbiAgICAgIG5leHRfdmFsID0gcHJldl92YWwgKyBzdGVwO1xuXG4gICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuXG4gICAgICB2YWwgPSB2YWwgPj0gcHJldl92YWwgKyBkaXYgPyBuZXh0X3ZhbCA6IHByZXZfdmFsO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNsaWRlciBlbGVtZW50cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZSk7XG5cbiAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzRm9ySGFuZGxlKHRoaXMuJGhhbmRsZTIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyBhIHBhcnRpY3VsYXIgaGFuZGxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50IGhhbmRsZSB0byBhcHBseSBsaXN0ZW5lcnMgdG8uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzRm9ySGFuZGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHNGb3JIYW5kbGUoJGhhbmRsZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBjdXJIYW5kbGU7XG5cbiAgICAgIHZhciBoYW5kbGVDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZUV2ZW50KGUpIHtcbiAgICAgICAgdmFyIGlkeCA9IF90aGlzLmlucHV0cy5pbmRleCgkKHRoaXMpKTtcblxuICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuaGFuZGxlcy5lcShpZHgpLCAkKHRoaXMpLnZhbCgpKTtcbiAgICAgIH07IC8vIElFIG9ubHkgdHJpZ2dlcnMgdGhlIGNoYW5nZSBldmVudCB3aGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1cyB3aGljaCBzdHJpY3RseSBmb2xsb3dzIHRoZSBIVE1MIHNwZWNpZmljYXRpb25cbiAgICAgIC8vIGxpc3RlbiBmb3IgdGhlIGVudGVyIGtleSBhbmQgdHJpZ2dlciBhIGNoYW5nZVxuICAgICAgLy8gQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnB1dC5odG1sI2NvbW1vbi1pbnB1dC1lbGVtZW50LWV2ZW50c1xuXG5cbiAgICAgIHRoaXMuaW5wdXRzLm9mZigna2V5dXAuemYuc2xpZGVyJykub24oJ2tleXVwLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpIGhhbmRsZUNoYW5nZUV2ZW50LmNhbGwodGhpcywgZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5wdXRzLm9mZignY2hhbmdlLnpmLnNsaWRlcicpLm9uKCdjaGFuZ2UuemYuc2xpZGVyJywgaGFuZGxlQ2hhbmdlRXZlbnQpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghJChlLnRhcmdldCkuaXMoJ1tkYXRhLXNsaWRlci1oYW5kbGVdJykpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy4kaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xuICAgICAgICB0aGlzLmhhbmRsZXMuYWRkVG91Y2goKTtcbiAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICAkaGFuZGxlLm9mZignbW91c2Vkb3duLnpmLnNsaWRlcicpLm9uKCdtb3VzZWRvd24uemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAkaGFuZGxlLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpO1xuXG4gICAgICAgICAgX3RoaXMuJGZpbGwuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7IC8vXG5cblxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJywgdHJ1ZSk7XG5cbiAgICAgICAgICBjdXJIYW5kbGUgPSAkKGUuY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgJGJvZHkub24oJ21vdXNlbW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgY3VySGFuZGxlKTtcbiAgICAgICAgICB9KS5vbignbW91c2V1cC56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XG5cbiAgICAgICAgICAgICRoYW5kbGUucmVtb3ZlQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XG5cbiAgICAgICAgICAgIF90aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xuXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIGZhbHNlKTtcblxuICAgICAgICAgICAgJGJvZHkub2ZmKCdtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pIC8vIHByZXZlbnQgZXZlbnRzIHRyaWdnZXJlZCBieSB0b3VjaFxuICAgICAgICAub24oJ3NlbGVjdHN0YXJ0LnpmLnNsaWRlciB0b3VjaG1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkaGFuZGxlLm9mZigna2V5ZG93bi56Zi5zbGlkZXInKS5vbigna2V5ZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgXyRoYW5kbGUgPSAkKHRoaXMpLFxuICAgICAgICAgICAgaWR4ID0gX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IF90aGlzLmhhbmRsZXMuaW5kZXgoXyRoYW5kbGUpIDogMCxcbiAgICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXG4gICAgICAgICAgICBuZXdWYWx1ZTsgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuXG5cbiAgICAgICAgS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdTbGlkZXInLCB7XG4gICAgICAgICAgZGVjcmVhc2U6IGZ1bmN0aW9uIGRlY3JlYXNlKCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSAtIF90aGlzLm9wdGlvbnMuc3RlcDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluY3JlYXNlOiBmdW5jdGlvbiBpbmNyZWFzZSgpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWNyZWFzZV9mYXN0OiBmdW5jdGlvbiBkZWNyZWFzZV9mYXN0KCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBvbGRWYWx1ZSAtIF90aGlzLm9wdGlvbnMuc3RlcCAqIDEwO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5jcmVhc2VfZmFzdDogZnVuY3Rpb24gaW5jcmVhc2VfZmFzdCgpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXAgKiAxMDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pbjogZnVuY3Rpb24gbWluKCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfdGhpcy5vcHRpb25zLnN0YXJ0O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF4OiBmdW5jdGlvbiBtYXgoKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF90aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgc2V0IGhhbmRsZSBwb3Mgd2hlbiBldmVudCB3YXMgaGFuZGxlZCBzcGVjaWFsbHlcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8qaWYgKG5ld1ZhbHVlKSB7IC8vIGlmIHByZXNzZWQga2V5IGhhcyBzcGVjaWFsIGZ1bmN0aW9uLCB1cGRhdGUgdmFsdWVcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xuICAgICAgICB9Ki9cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgc2xpZGVyIHBsdWdpbi5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5oYW5kbGVzLm9mZignLnpmLnNsaWRlcicpO1xuICAgICAgdGhpcy5pbnB1dHMub2ZmKCcuemYuc2xpZGVyJyk7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnNsaWRlcicpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0oUGx1Z2luKTtcblxuU2xpZGVyLmRlZmF1bHRzID0ge1xuICAvKipcbiAgICogTWluaW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBzdGFydDogMCxcblxuICAvKipcbiAgICogTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIGVuZDogMTAwLFxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICovXG4gIHN0ZXA6IDEsXG5cbiAgLyoqXG4gICAqIFZhbHVlIGF0IHdoaWNoIHRoZSBoYW5kbGUvaW5wdXQgKihsZWZ0IGhhbmRsZS9maXJzdCBpbnB1dCkqIHNob3VsZCBiZSBzZXQgdG8gb24gaW5pdGlhbGl6YXRpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgaW5pdGlhbFN0YXJ0OiAwLFxuXG4gIC8qKlxuICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgcmlnaHQgaGFuZGxlL3NlY29uZCBpbnB1dCBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDEwMFxuICAgKi9cbiAgaW5pdGlhbEVuZDogMTAwLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBiaW5kaW5nOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGNsaWNrL3RhcCBvbiB0aGUgc2xpZGVyIGJhciB0byBzZWxlY3QgYSB2YWx1ZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2xpY2tTZWxlY3Q6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGFuZCB1c2UgdGhlIGB2ZXJ0aWNhbGAgY2xhc3MgdG8gY2hhbmdlIGFsaWdubWVudCB0byB2ZXJ0aWNhbC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHZlcnRpY2FsOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGRyYWdnYWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogRGlzYWJsZXMgdGhlIHNsaWRlciBhbmQgcHJldmVudHMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYmVpbmcgYXBwbGllZC4gRG91YmxlIGNoZWNrZWQgYnkgSlMgd2l0aCBgZGlzYWJsZWRDbGFzc2AuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkaXNhYmxlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdXNlIG9mIHR3byBoYW5kbGVzLiBEb3VibGUgY2hlY2tlZCBieSB0aGUgSlMuIENoYW5nZXMgc29tZSBsb2dpYyBoYW5kbGluZy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRvdWJsZVNpZGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxuICAgKi9cbiAgLy8gc3RlcHM6IDEwMCxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoZSBwbHVnaW4gc2hvdWxkIGdvIHRvIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMlxuICAgKi9cbiAgZGVjaW1hbDogMixcblxuICAvKipcbiAgICogVGltZSBkZWxheSBmb3IgZHJhZ2dlZCBlbGVtZW50cy5cbiAgICovXG4gIC8vIGRyYWdEZWxheTogMCxcblxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgbW92ZVRpbWU6IDIwMCxcbiAgLy91cGRhdGUgdGhpcyBpZiBjaGFuZ2luZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBzYXNzXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gZGlzYWJsZWQgc2xpZGVycy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnZGlzYWJsZWQnXG4gICAqL1xuICBkaXNhYmxlZENsYXNzOiAnZGlzYWJsZWQnLFxuXG4gIC8qKlxuICAgKiBXaWxsIGludmVydCB0aGUgZGVmYXVsdCBsYXlvdXQgZm9yIGEgdmVydGljYWw8c3BhbiBkYXRhLXRvb2x0aXAgdGl0bGU9XCJ3aG8gd291bGQgZG8gdGhpcz8/P1wiPiA8L3NwYW4+c2xpZGVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaW52ZXJ0VmVydGljYWw6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBgY2hhbmdlZC56Zi1zbGlkZXJgIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB2YWx1ZSBjaGFuZ2UuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgNTAwXG4gICAqL1xuICBjaGFuZ2VkRGVsYXk6IDUwMCxcblxuICAvKipcbiAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVyc1xuICAqIEBvcHRpb25cbiAgKiBAdHlwZSB7bnVtYmVyfVxuICAqIEBkZWZhdWx0IDVcbiAgKi9cbiAgbm9uTGluZWFyQmFzZTogNSxcblxuICAvKipcbiAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVycywgcG9zc2libGUgdmFsdWVzIGFyZTogYCdsaW5lYXInYCwgYCdwb3cnYCAmIGAnbG9nJ2AuIFBvdyBhbmQgTG9nIHVzZSB0aGUgbm9uTGluZWFyQmFzZSBzZXR0aW5nLlxuICAqIEBvcHRpb25cbiAgKiBAdHlwZSB7c3RyaW5nfVxuICAqIEBkZWZhdWx0ICdsaW5lYXInXG4gICovXG4gIHBvc2l0aW9uVmFsdWVGdW5jdGlvbjogJ2xpbmVhcidcbn07XG5cbmZ1bmN0aW9uIHBlcmNlbnQoZnJhYywgbnVtKSB7XG4gIHJldHVybiBmcmFjIC8gbnVtO1xufVxuXG5mdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSkge1xuICByZXR1cm4gTWF0aC5hYnMoJGhhbmRsZS5wb3NpdGlvbigpW2Rpcl0gKyAkaGFuZGxlW3BhcmFtXSgpIC8gMiAtIGNsaWNrUG9zKTtcbn1cblxuZnVuY3Rpb24gYmFzZUxvZyhiYXNlLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coYmFzZSk7XG59XG5cbi8qKlxuICogU3RpY2t5IG1vZHVsZS5cbiAqIEBtb2R1bGUgZm91bmRhdGlvbi5zdGlja3lcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICovXG5cbnZhciBTdGlja3kgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFN0aWNreSwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gU3RpY2t5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGlja3kpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTdGlja3kpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0aWNreSwgW3tcbiAgICBrZXk6IFwiX3NldHVwXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc3RpY2t5IHRoaW5nLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFN0aWNreVxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIHN0aWNreS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTdGlja3kuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1N0aWNreSc7IC8vIGllOSBiYWNrIGNvbXBhdFxuICAgICAgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBlbGVtZW50IGJ5IGFkZGluZyBjbGFzc2VzLCBnZXR0aW5nL3NldHRpbmcgZGltZW5zaW9ucywgYnJlYWtwb2ludHMgYW5kIGF0dHJpYnV0ZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7XG5cbiAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN0aWNreS1jb250YWluZXJdJyksXG4gICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEdldFlvRGlnaXRzKDYsICdzdGlja3knKSxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICgkcGFyZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkcGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC53cmFwKHRoaXMub3B0aW9ucy5jb250YWluZXIpO1xuICAgICAgICB0aGlzLiRjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHtcbiAgICAgICAgJ2RhdGEtcmVzaXplJzogaWQsXG4gICAgICAgICdkYXRhLW11dGF0ZSc6IGlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmNob3IgIT09ICcnKSB7XG4gICAgICAgICQoJyMnICsgX3RoaXMub3B0aW9ucy5hbmNob3IpLmF0dHIoe1xuICAgICAgICAgICdkYXRhLW11dGF0ZSc6IGlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcbiAgICAgIHRoaXMub25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vV2UgY2FsY3VsYXRlIHRoZSBjb250YWluZXIgaGVpZ2h0IHRvIGhhdmUgY29ycmVjdCB2YWx1ZXMgZm9yIGFuY2hvciBwb2ludHMgb2Zmc2V0IGNhbGN1bGF0aW9uLlxuICAgICAgICBfdGhpcy5jb250YWluZXJIZWlnaHQgPSBfdGhpcy4kZWxlbWVudC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiID8gMCA6IF90aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgICBfdGhpcy4kY29udGFpbmVyLmNzcygnaGVpZ2h0JywgX3RoaXMuY29udGFpbmVySGVpZ2h0KTtcblxuICAgICAgICBfdGhpcy5lbGVtSGVpZ2h0ID0gX3RoaXMuY29udGFpbmVySGVpZ2h0O1xuXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpIHtcbiAgICAgICAgICBfdGhpcy4kYW5jaG9yID0gJCgnIycgKyBfdGhpcy5vcHRpb25zLmFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX3BhcnNlUG9pbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG5cbiAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgc2Nyb2xsKTsgLy9VbnN0aWNrIHRoZSBlbGVtZW50IHdpbGwgZW5zdXJlIHRoYXQgcHJvcGVyIGNsYXNzZXMgYXJlIHNldC5cblxuXG4gICAgICAgICAgaWYgKCFfdGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlU3RpY2t5KHNjcm9sbCA+PSBfdGhpcy50b3BQb2ludCA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpcy5fZXZlbnRzKGlkLnNwbGl0KCctJykucmV2ZXJzZSgpLmpvaW4oJy0nKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdXNpbmcgbXVsdGlwbGUgZWxlbWVudHMgYXMgYW5jaG9ycywgY2FsY3VsYXRlcyB0aGUgdG9wIGFuZCBib3R0b20gcGl4ZWwgdmFsdWVzIHRoZSBzdGlja3kgdGhpbmcgc2hvdWxkIHN0aWNrIGFuZCB1bnN0aWNrIG9uLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUG9pbnRzKCkge1xuICAgICAgdmFyIHRvcCA9IHRoaXMub3B0aW9ucy50b3BBbmNob3IgPT0gXCJcIiA/IDEgOiB0aGlzLm9wdGlvbnMudG9wQW5jaG9yLFxuICAgICAgICAgIGJ0bSA9IHRoaXMub3B0aW9ucy5idG1BbmNob3IgPT0gXCJcIiA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiB0aGlzLm9wdGlvbnMuYnRtQW5jaG9yLFxuICAgICAgICAgIHB0cyA9IFt0b3AsIGJ0bV0sXG4gICAgICAgICAgYnJlYWtzID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwdHMubGVuZ3RoOyBpIDwgbGVuICYmIHB0c1tpXTsgaSsrKSB7XG4gICAgICAgIHZhciBwdDtcblxuICAgICAgICBpZiAodHlwZW9mIHB0c1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwdCA9IHB0c1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcGxhY2UgPSBwdHNbaV0uc3BsaXQoJzonKSxcbiAgICAgICAgICAgICAgYW5jaG9yID0gJChcIiNcIi5jb25jYXQocGxhY2VbMF0pKTtcbiAgICAgICAgICBwdCA9IGFuY2hvci5vZmZzZXQoKS50b3A7XG5cbiAgICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHB0ICs9IGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtzW2ldID0gcHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9pbnRzID0gYnJlYWtzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc2V1ZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKGlkKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgIHNjcm9sbExpc3RlbmVyID0gdGhpcy5zY3JvbGxMaXN0ZW5lciA9IFwic2Nyb2xsLnpmLlwiLmNvbmNhdChpZCk7XG5cbiAgICAgIGlmICh0aGlzLmlzT24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW5TdGljaykge1xuICAgICAgICB0aGlzLmlzT24gPSB0cnVlO1xuICAgICAgICAkKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKS5vbihzY3JvbGxMaXN0ZW5lciwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50ID0gX3RoaXMub3B0aW9ucy5jaGVja0V2ZXJ5O1xuXG4gICAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zY3JvbGxDb3VudC0tO1xuXG4gICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XG4gICAgICAgIF90aGlzLl9ldmVudHNIYW5kbGVyKGlkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kZWxlbWVudC5vbignbXV0YXRlbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xuICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuJGFuY2hvcikge1xuICAgICAgICB0aGlzLiRhbmNob3Iub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSwgZWwpIHtcbiAgICAgICAgICBfdGhpcy5fZXZlbnRzSGFuZGxlcihpZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBldmVudHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc2V1ZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c0hhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50c0hhbmRsZXIoaWQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgc2Nyb2xsTGlzdGVuZXIgPSB0aGlzLnNjcm9sbExpc3RlbmVyID0gXCJzY3JvbGwuemYuXCIuY29uY2F0KGlkKTtcblxuICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xuXG4gICAgICAgIGlmIChfdGhpcy5jYW5TdGljaykge1xuICAgICAgICAgIGlmICghX3RoaXMuaXNPbikge1xuICAgICAgICAgICAgX3RoaXMuX2V2ZW50cyhpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmlzT24pIHtcbiAgICAgICAgICBfdGhpcy5fcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBoYW5kbGVycyBmb3Igc2Nyb2xsIGFuZCBjaGFuZ2UgZXZlbnRzIG9uIGFuY2hvci5cbiAgICAgKiBAZmlyZXMgU3RpY2t5I3BhdXNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNjcm9sbExpc3RlbmVyIC0gdW5pcXVlLCBuYW1lc3BhY2VkIHNjcm9sbCBsaXN0ZW5lciBhdHRhY2hlZCB0byBgd2luZG93YFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhdXNlTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcikge1xuICAgICAgdGhpcy5pc09uID0gZmFsc2U7XG4gICAgICAkKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGlzIHBhdXNlZCBkdWUgdG8gcmVzaXplIGV2ZW50IHNocmlua2luZyB0aGUgdmlldy5cbiAgICAgICAqIEBldmVudCBTdGlja3kjcGF1c2VcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwYXVzZS56Zi5zdGlja3knKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGV2ZXJ5IGBzY3JvbGxgIGV2ZW50IGFuZCBvbiBgX2luaXRgXG4gICAgICogZmlyZXMgZnVuY3Rpb25zIGJhc2VkIG9uIGJvb2xlYW5zIGFuZCBjYWNoZWQgdmFsdWVzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja1NpemVzIC0gdHJ1ZSBpZiBwbHVnaW4gc2hvdWxkIHJlY2FsY3VsYXRlIHNpemVzIGFuZCBicmVha3BvaW50cy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsIC0gY3VycmVudCBzY3JvbGwgcG9zaXRpb24gcGFzc2VkIGZyb20gc2Nyb2xsIGV2ZW50IGNiIGZ1bmN0aW9uLiBJZiBub3QgcGFzc2VkLCBkZWZhdWx0cyB0byBgd2luZG93LnBhZ2VZT2Zmc2V0YC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjKGNoZWNrU2l6ZXMsIHNjcm9sbCkge1xuICAgICAgaWYgKGNoZWNrU2l6ZXMpIHtcbiAgICAgICAgdGhpcy5fc2V0U2l6ZXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbCA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbCA+PSB0aGlzLnRvcFBvaW50KSB7XG4gICAgICAgIGlmIChzY3JvbGwgPD0gdGhpcy5ib3R0b21Qb2ludCkge1xuICAgICAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGlja3koKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgc3R1Y2suXG4gICAgICogQWRkcyBgcG9zaXRpb246IGZpeGVkO2AsIGFuZCBoZWxwZXIgY2xhc3Nlcy5cbiAgICAgKiBAZmlyZXMgU3RpY2t5I3N0dWNrdG9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFN0aWNreVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U3RpY2t5KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXG4gICAgICAgICAgbXJnbiA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ21hcmdpblRvcCcgOiAnbWFyZ2luQm90dG9tJyxcbiAgICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUbyA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnLFxuICAgICAgICAgIGNzcyA9IHt9O1xuXG4gICAgICBjc3NbbXJnbl0gPSBcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnNbbXJnbl0sIFwiZW1cIik7XG4gICAgICBjc3Nbc3RpY2tUb10gPSAwO1xuICAgICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xuICAgICAgdGhpcy5pc1N0dWNrID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJpcy1hbmNob3JlZCBpcy1hdC1cIi5jb25jYXQobm90U3R1Y2tUbykpLmFkZENsYXNzKFwiaXMtc3R1Y2sgaXMtYXQtXCIuY29uY2F0KHN0aWNrVG8pKS5jc3MoY3NzKVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxuICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnN0dWNrdG86dG9wYFxuICAgICAgICogQGV2ZW50IFN0aWNreSNzdHVja3RvXG4gICAgICAgKi9cbiAgICAgIC50cmlnZ2VyKFwic3RpY2t5LnpmLnN0dWNrdG86XCIuY29uY2F0KHN0aWNrVG8pKTtcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3NldFNpemVzKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgdW5zdHVjay5cbiAgICAgKiBSZW1vdmVzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxuICAgICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBpc1RvcCAtIHRlbGxzIHRoZSBmdW5jdGlvbiBpZiB0aGUgJGVsZW1lbnQgc2hvdWxkIGFuY2hvciB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiBpdHMgJGFuY2hvciBlbGVtZW50LlxuICAgICAqIEBmaXJlcyBTdGlja3kjdW5zdHVja2Zyb21cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVN0aWNreVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlU3RpY2t5KGlzVG9wKSB7XG4gICAgICB2YXIgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxuICAgICAgICAgIHN0aWNrVG9Ub3AgPSBzdGlja1RvID09PSAndG9wJyxcbiAgICAgICAgICBjc3MgPSB7fSxcbiAgICAgICAgICBhbmNob3JQdCA9ICh0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIC0gdGhpcy5wb2ludHNbMF0gOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQsXG4gICAgICAgICAgbXJnbiA9IHN0aWNrVG9Ub3AgPyAnbWFyZ2luVG9wJyA6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICAgIHRvcE9yQm90dG9tID0gaXNUb3AgPyAndG9wJyA6ICdib3R0b20nO1xuICAgICAgY3NzW21yZ25dID0gMDtcbiAgICAgIGNzc1snYm90dG9tJ10gPSAnYXV0byc7XG5cbiAgICAgIGlmIChpc1RvcCkge1xuICAgICAgICBjc3NbJ3RvcCddID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNzc1sndG9wJ10gPSBhbmNob3JQdDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiaXMtc3R1Y2sgaXMtYXQtXCIuY29uY2F0KHN0aWNrVG8pKS5hZGRDbGFzcyhcImlzLWFuY2hvcmVkIGlzLWF0LVwiLmNvbmNhdCh0b3BPckJvdHRvbSkpLmNzcyhjc3MpXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYW5jaG9yZWQuXG4gICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYudW5zdHVja2Zyb206Ym90dG9tYFxuICAgICAgICogQGV2ZW50IFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICovXG4gICAgICAudHJpZ2dlcihcInN0aWNreS56Zi51bnN0dWNrZnJvbTpcIi5jb25jYXQodG9wT3JCb3R0b20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgJGVsZW1lbnQgYW5kICRjb250YWluZXIgc2l6ZXMgZm9yIHBsdWdpbi5cbiAgICAgKiBDYWxscyBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTaXplcyhjYikge1xuICAgICAgdGhpcy5jYW5TdGljayA9IE1lZGlhUXVlcnkuaXModGhpcy5vcHRpb25zLnN0aWNreU9uKTtcblxuICAgICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XG4gICAgICAgIGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdFbGVtV2lkdGggPSB0aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXG4gICAgICAgICAgY29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXG4gICAgICAgICAgcGRuZ2wgPSBwYXJzZUludChjb21wWydwYWRkaW5nLWxlZnQnXSwgMTApLFxuICAgICAgICAgIHBkbmdyID0gcGFyc2VJbnQoY29tcFsncGFkZGluZy1yaWdodCddLCAxMCk7XG5cbiAgICAgIGlmICh0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFuY2hvckhlaWdodCA9IHRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZVBvaW50cygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XG4gICAgICAgICdtYXgtd2lkdGgnOiBcIlwiLmNvbmNhdChuZXdFbGVtV2lkdGggLSBwZG5nbCAtIHBkbmdyLCBcInB4XCIpXG4gICAgICB9KTsgLy8gUmVjYWxjdWxhdGUgdGhlIGhlaWdodCBvbmx5IGlmIGl0IGlzIFwiZHluYW1pY1wiXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHluYW1pY0hlaWdodCB8fCAhdGhpcy5jb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBzdGlja2VkIGVsZW1lbnQgaGVpZ2h0IGFuZCBhcHBseSBpdCB0byB0aGUgY29udGFpbmVyIHRvIFwiaG9sZCB0aGUgcGxhY2VcIlxuICAgICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XG4gICAgICAgIG5ld0NvbnRhaW5lckhlaWdodCA9IHRoaXMuJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIiA/IDAgOiBuZXdDb250YWluZXJIZWlnaHQ7XG4gICAgICAgIHRoaXMuJGNvbnRhaW5lci5jc3MoJ2hlaWdodCcsIG5ld0NvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1IZWlnaHQgPSB0aGlzLmNvbnRhaW5lckhlaWdodDtcblxuICAgICAgaWYgKCF0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLWF0LWJvdHRvbScpKSB7XG4gICAgICAgICAgdmFyIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0O1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKCd0b3AnLCBhbmNob3JQdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0QnJlYWtQb2ludHModGhpcy5jb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVsZW1IZWlnaHQgLSBweCB2YWx1ZSBmb3Igc3RpY2t5LiRlbGVtZW50IGhlaWdodCwgY2FsY3VsYXRlZCBieSBgX3NldFNpemVzYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QnJlYWtQb2ludHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsIGNiKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxuICAgICAgICAgIG1CdG0gPSBlbUNhbGModGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksXG4gICAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcbiAgICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxuICAgICAgICAgIC8vIHRvcFBvaW50ID0gdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCB8fCB0aGlzLnBvaW50c1swXSxcbiAgICAgIC8vIGJvdHRvbVBvaW50ID0gdG9wUG9pbnQgKyB0aGlzLmFuY2hvckhlaWdodCB8fCB0aGlzLnBvaW50c1sxXSxcbiAgICAgIHdpbkhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xuICAgICAgICB0b3BQb2ludCAtPSBtVG9wO1xuICAgICAgICBib3R0b21Qb2ludCAtPSBlbGVtSGVpZ2h0ICsgbVRvcDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHRvcFBvaW50IC09IHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSk7XG4gICAgICAgIGJvdHRvbVBvaW50IC09IHdpbkhlaWdodCAtIG1CdG07XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9wUG9pbnQgPSB0b3BQb2ludDtcbiAgICAgIHRoaXMuYm90dG9tUG9pbnQgPSBib3R0b21Qb2ludDtcblxuICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgY3VycmVudCBzdGlja3kgZWxlbWVudC5cbiAgICAgKiBSZXNldHMgdGhlIGVsZW1lbnQgdG8gdGhlIHRvcCBwb3NpdGlvbiBmaXJzdC5cbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcblxuICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcIlwiLmNvbmNhdCh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MsIFwiIGlzLWFuY2hvcmVkIGlzLWF0LXRvcFwiKSkuY3NzKHtcbiAgICAgICAgaGVpZ2h0OiAnJyxcbiAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgYm90dG9tOiAnJyxcbiAgICAgICAgJ21heC13aWR0aCc6ICcnXG4gICAgICB9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vZmYoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcblxuICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2Nyb2xsTGlzdGVuZXIpICQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lcik7XG4gICAgICBpZiAodGhpcy5vbkxvYWRMaXN0ZW5lcikgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcblxuICAgICAgaWYgKHRoaXMud2FzV3JhcHBlZCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtcbiAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGlja3k7XG59KFBsdWdpbik7XG5cblN0aWNreS5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIEN1c3RvbWl6YWJsZSBjb250YWluZXIgdGVtcGxhdGUuIEFkZCB5b3VyIG93biBjbGFzc2VzIGZvciBzdHlsaW5nIGFuZCBzaXppbmcuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJyZsdDtkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyJmd0OyZsdDsvZGl2Jmd0OydcbiAgICovXG4gIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXG5cbiAgLyoqXG4gICAqIExvY2F0aW9uIGluIHRoZSB2aWV3IHRoZSBlbGVtZW50IHN0aWNrcyB0by4gQ2FuIGJlIGAndG9wJ2Agb3IgYCdib3R0b20nYC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndG9wJ1xuICAgKi9cbiAgc3RpY2tUbzogJ3RvcCcsXG5cbiAgLyoqXG4gICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIHRvcEFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIGJvdHRvbSBhbmNob3IuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJydcbiAgICovXG4gIGJ0bUFuY2hvcjogJycsXG5cbiAgLyoqXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSB0b3Agb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBtYXJnaW5Ub3A6IDEsXG5cbiAgLyoqXG4gICAqIE1hcmdpbiwgaW4gYGVtYCdzIHRvIGFwcGx5IHRvIHRoZSBib3R0b20gb2YgdGhlIGVsZW1lbnQgd2hlbiBpdCBiZWNvbWVzIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBtYXJnaW5Cb3R0b206IDEsXG5cbiAgLyoqXG4gICAqIEJyZWFrcG9pbnQgc3RyaW5nIHRoYXQgaXMgdGhlIG1pbmltdW0gc2NyZWVuIHNpemUgYW4gZWxlbWVudCBzaG91bGQgYmVjb21lIHN0aWNreS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnbWVkaXVtJ1xuICAgKi9cbiAgc3RpY2t5T246ICdtZWRpdW0nLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBlbGVtZW50LCBhbmQgcmVtb3ZlZCBvbiBkZXN0cnVjdGlvbi4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5YC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnc3RpY2t5J1xuICAgKi9cbiAgc3RpY2t5Q2xhc3M6ICdzdGlja3knLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHN0aWNreSBjb250YWluZXIuIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreS1jb250YWluZXJgLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdzdGlja3ktY29udGFpbmVyJ1xuICAgKi9cbiAgY29udGFpbmVyQ2xhc3M6ICdzdGlja3ktY29udGFpbmVyJyxcblxuICAvKipcbiAgICogSWYgdHJ1ZSAoYnkgZGVmYXVsdCksIGtlZXAgdGhlIHN0aWNreSBjb250YWluZXIgdGhlIHNhbWUgaGVpZ2h0IGFzIHRoZSBlbGVtZW50LiBPdGhlcndpc2UsIHRoZSBjb250YWluZXIgaGVpZ2h0IGlzIHNldCBvbmNlIGFuZCBkb2VzIG5vdCBjaGFuZ2UuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGR5bmFtaWNIZWlnaHQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBzY3JvbGwgZXZlbnRzIGJldHdlZW4gdGhlIHBsdWdpbidzIHJlY2FsY3VsYXRpbmcgc3RpY2t5IHBvaW50cy4gU2V0dGluZyBpdCB0byBgMGAgd2lsbCBjYXVzZSBpdCB0byByZWNhbGMgZXZlcnkgc2Nyb2xsIGV2ZW50LCBzZXR0aW5nIGl0IHRvIGAtMWAgd2lsbCBwcmV2ZW50IHJlY2FsYyBvbiBzY3JvbGwuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgLTFcbiAgICovXG4gIGNoZWNrRXZlcnk6IC0xXG59O1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xuICogQHBhcmFtIE51bWJlciB7ZW19IC0gbnVtYmVyIG9mIGVtJ3MgdG8gY2FsY3VsYXRlIGludG8gcGl4ZWxzXG4gKi9cblxuZnVuY3Rpb24gZW1DYWxjKGVtKSB7XG4gIHJldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LCBudWxsKS5mb250U2l6ZSwgMTApICogZW07XG59XG5cbi8qKlxuICogVGFicyBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udGFic1xuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5pbWFnZUxvYWRlciBpZiB0YWJzIGNvbnRhaW4gaW1hZ2VzXG4gKi9cblxudmFyIFRhYnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFRhYnMsIF9QbHVnaW4pO1xuXG4gIGZ1bmN0aW9uIFRhYnMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYnMpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUYWJzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUYWJzLCBbe1xuICAgIGtleTogXCJfc2V0dXBcIixcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGFicy5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAbmFtZSBUYWJzXG4gICAgICogQGZpcmVzIFRhYnMjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gdGFicy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUYWJzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdUYWJzJzsgLy8gaWU5IGJhY2sgY29tcGF0XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgS2V5Ym9hcmQucmVnaXN0ZXIoJ1RhYnMnLCB7XG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19VUCc6ICdwcmV2aW91cycsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycgLy8gJ1RBQic6ICduZXh0JyxcbiAgICAgICAgLy8gJ1NISUZUX1RBQic6ICdwcmV2aW91cydcblxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0YWJzIGJ5IHNob3dpbmcgYW5kIGZvY3VzaW5nIChpZiBhdXRvRm9jdXM9dHJ1ZSkgdGhlIHByZXNldCBhY3RpdmUgdGFiLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IHRydWU7XG4gICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0YWJsaXN0J1xuICAgICAgfSk7XG4gICAgICB0aGlzLiR0YWJUaXRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpKTtcbiAgICAgIHRoaXMuJHRhYkNvbnRlbnQgPSAkKFwiW2RhdGEtdGFicy1jb250ZW50PVxcXCJcIi5jb25jYXQodGhpcy4kZWxlbWVudFswXS5pZCwgXCJcXFwiXVwiKSk7XG4gICAgICB0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICAkbGluayA9ICRlbGVtLmZpbmQoJ2EnKSxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gJGVsZW0uaGFzQ2xhc3MoXCJcIi5jb25jYXQoX3RoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKSxcbiAgICAgICAgICAgIGhhc2ggPSAkbGluay5hdHRyKCdkYXRhLXRhYnMtdGFyZ2V0JykgfHwgJGxpbmtbMF0uaGFzaC5zbGljZSgxKSxcbiAgICAgICAgICAgIGxpbmtJZCA9ICRsaW5rWzBdLmlkID8gJGxpbmtbMF0uaWQgOiBcIlwiLmNvbmNhdChoYXNoLCBcIi1sYWJlbFwiKSxcbiAgICAgICAgICAgICR0YWJDb250ZW50ID0gJChcIiNcIi5jb25jYXQoaGFzaCkpO1xuICAgICAgICAkZWxlbS5hdHRyKHtcbiAgICAgICAgICAncm9sZSc6ICdwcmVzZW50YXRpb24nXG4gICAgICAgIH0pO1xuICAgICAgICAkbGluay5hdHRyKHtcbiAgICAgICAgICAncm9sZSc6ICd0YWInLFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaGFzaCxcbiAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzQWN0aXZlLFxuICAgICAgICAgICdpZCc6IGxpbmtJZCxcbiAgICAgICAgICAndGFiaW5kZXgnOiBpc0FjdGl2ZSA/ICcwJyA6ICctMSdcbiAgICAgICAgfSk7XG4gICAgICAgICR0YWJDb250ZW50LmF0dHIoe1xuICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkXG4gICAgICAgIH0pOyAvLyBTYXZlIHVwIHRoZSBpbml0aWFsIGhhc2ggdG8gcmV0dXJuIHRvIGl0IGxhdGVyIHdoZW4gZ29pbmcgYmFjayBpbiBoaXN0b3J5XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgX3RoaXMuX2luaXRpYWxBbmNob3IgPSBcIiNcIi5jb25jYXQoaGFzaCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgJHRhYkNvbnRlbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlICYmIF90aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgX3RoaXMub25Mb2FkTGlzdGVuZXIgPSBvbkxvYWQoJCh3aW5kb3cpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogJGVsZW0ub2Zmc2V0KCkudG9wXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmRlZXBMaW5rU211ZGdlRGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJGxpbmsuZm9jdXMoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xuICAgICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZCgnaW1nJyk7XG5cbiAgICAgICAgaWYgKCRpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgb25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEN1cnJlbnQgY29udGV4dC1ib3VuZCBmdW5jdGlvbiB0byBvcGVuIHRhYnMgb24gcGFnZSBsb2FkIG9yIGhpc3RvcnkgaGFzaGNoYW5nZVxuXG5cbiAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcblxuICAgICAgICBpZiAoIWFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgc3RpbGwgaW5pdGlhbGl6aW5nIGFuZCB0aGVyZSBpcyBubyBhbmNob3IsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkb1xuICAgICAgICAgIGlmIChfdGhpczIuX2lzSW5pdGlhbGl6aW5nKSByZXR1cm47IC8vIE90aGVyd2lzZSwgbW92ZSB0byB0aGUgaW5pdGlhbCBhbmNob3JcblxuICAgICAgICAgIGlmIChfdGhpczIuX2luaXRpYWxBbmNob3IpIGFuY2hvciA9IF90aGlzMi5faW5pdGlhbEFuY2hvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmNob3JOb0hhc2ggPSBhbmNob3IuaW5kZXhPZignIycpID49IDAgPyBhbmNob3Iuc2xpY2UoMSkgOiBhbmNob3I7XG4gICAgICAgIHZhciAkYW5jaG9yID0gYW5jaG9yTm9IYXNoICYmICQoXCIjXCIuY29uY2F0KGFuY2hvck5vSGFzaCkpO1xuXG4gICAgICAgIHZhciAkbGluayA9IGFuY2hvciAmJiBfdGhpczIuJGVsZW1lbnQuZmluZChcIltocmVmJD1cXFwiXCIuY29uY2F0KGFuY2hvciwgXCJcXFwiXSxbZGF0YS10YWJzLXRhcmdldD1cXFwiXCIpLmNvbmNhdChhbmNob3JOb0hhc2gsIFwiXFxcIl1cIikpLmZpcnN0KCk7IC8vIFdoZXRoZXIgdGhlIGFuY2hvciBlbGVtZW50IHRoYXQgaGFzIGJlZW4gZm91bmQgaXMgcGFydCBvZiB0aGlzIGVsZW1lbnRcblxuXG4gICAgICAgIHZhciBpc093bkFuY2hvciA9ICEhKCRhbmNob3IubGVuZ3RoICYmICRsaW5rLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGlzT3duQW5jaG9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gYW5jaG9yIGZvciB0aGUgaGFzaCwgc2VsZWN0IGl0XG4gICAgICAgICAgaWYgKCRhbmNob3IgJiYgJGFuY2hvci5sZW5ndGggJiYgJGxpbmsgJiYgJGxpbmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBfdGhpczIuc2VsZWN0VGFiKCRhbmNob3IsIHRydWUpO1xuICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlLCBjb2xsYXBzZSBldmVyeXRoaW5nXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzMi5fY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH0gLy8gUm9sbCB1cCBhIGxpdHRsZSB0byBzaG93IHRoZSB0aXRsZXNcblxuXG4gICAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xuXG4gICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHNjcm9sbFRvcDogb2Zmc2V0LnRvcFxuICAgICAgICAgICAgfSwgX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgZGVlcGxpbmtlZCBhdCBwYWdlbG9hZFxuICAgICAgICAgICAqIEBldmVudCBUYWJzI2RlZXBsaW5rXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi50YWJzJywgWyRsaW5rLCAkYW5jaG9yXSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vdXNlIGJyb3dzZXIgdG8gb3BlbiBhIHRhYiwgaWYgaXQgZXhpc3RzIGluIHRoaXMgdGFic2V0XG5cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICB0aGlzLl9jaGVja0RlZXBMaW5rKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICB0aGlzLl9pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHRoaXMuX2FkZEtleUhhbmRsZXIoKTtcblxuICAgICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XG5cbiAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyID0gdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcyk7XG4gICAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjbGljayBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2xpY2tIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDbGlja0hhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignY2xpY2suemYudGFicycpLm9uKCdjbGljay56Zi50YWJzJywgXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkKHRoaXMpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9hZGRLZXlIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRLZXlIYW5kbGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy4kdGFiVGl0bGVzLm9mZigna2V5ZG93bi56Zi50YWJzJykub24oJ2tleWRvd24uemYudGFicycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSA5KSByZXR1cm47XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyksXG4gICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgICAkcHJldkVsZW1lbnQsXG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQ7XG4gICAgICAgICRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy53cmFwT25LZXlzKSB7XG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9IGkgPT09IDAgPyAkZWxlbWVudHMubGFzdCgpIDogJGVsZW1lbnRzLmVxKGkgLSAxKTtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gaSA9PT0gJGVsZW1lbnRzLmxlbmd0aCAtIDEgPyAkZWxlbWVudHMuZmlyc3QoKSA6ICRlbGVtZW50cy5lcShpICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuXG4gICAgICAgIEtleWJvYXJkLmhhbmRsZUtleShlLCAnVGFicycsIHtcbiAgICAgICAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRlbGVtZW50KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHByZXZFbGVtZW50KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAkbmV4dEVsZW1lbnQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5mb2N1cygpO1xuXG4gICAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRuZXh0RWxlbWVudCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRhYiBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLiBDb2xsYXBzZXMgYWN0aXZlIHRhYi5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBvcGVuLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlzdG9yeUhhbmRsZWQgLSBicm93c2VyIGhhcyBhbHJlYWR5IGhhbmRsZWQgYSBoaXN0b3J5IHVwZGF0ZVxuICAgICAqIEBmaXJlcyBUYWJzI2NoYW5nZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVRhYkNoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVGFiQ2hhbmdlKCR0YXJnZXQsIGhpc3RvcnlIYW5kbGVkKSB7XG4gICAgICAvLyBXaXRoIGBhY3RpdmVDb2xsYXBzZWAsIGlmIHRoZSB0YXJnZXQgaXMgdGhlIGFjdGl2ZSBUYWIsIGNvbGxhcHNlIGl0LlxuICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlQ29sbGFwc2UpIHtcbiAgICAgICAgICB0aGlzLl9jb2xsYXBzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgJG9sZFRhYiA9IHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcywgXCIuXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSksXG4gICAgICAgICAgJHRhYkxpbmsgPSAkdGFyZ2V0LmZpbmQoJ1tyb2xlPVwidGFiXCJdJyksXG4gICAgICAgICAgdGFyZ2V0ID0gJHRhYkxpbmsuYXR0cignZGF0YS10YWJzLXRhcmdldCcpLFxuICAgICAgICAgIGFuY2hvciA9IHRhcmdldCAmJiB0YXJnZXQubGVuZ3RoID8gXCIjXCIuY29uY2F0KHRhcmdldCkgOiAkdGFiTGlua1swXS5oYXNoLFxuICAgICAgICAgICR0YXJnZXRDb250ZW50ID0gdGhpcy4kdGFiQ29udGVudC5maW5kKGFuY2hvcik7IC8vY2xvc2Ugb2xkIHRhYlxuXG4gICAgICB0aGlzLl9jb2xsYXBzZVRhYigkb2xkVGFiKTsgLy9vcGVuIG5ldyB0YWJcblxuXG4gICAgICB0aGlzLl9vcGVuVGFiKCR0YXJnZXQpOyAvL2VpdGhlciByZXBsYWNlIG9yIHVwZGF0ZSBicm93c2VyIGhpc3RvcnlcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmICFoaXN0b3J5SGFuZGxlZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZUhpc3RvcnkpIHtcbiAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sICcnLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNoYW5nZWQgdGFicy5cbiAgICAgICAqIEBldmVudCBUYWJzI2NoYW5nZVxuICAgICAgICovXG5cblxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UuemYudGFicycsIFskdGFyZ2V0LCAkdGFyZ2V0Q29udGVudF0pOyAvL2ZpcmUgdG8gY2hpbGRyZW4gYSBtdXRhdGlvbiBldmVudFxuXG4gICAgICAkdGFyZ2V0Q29udGVudC5maW5kKFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRhYiBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIG9wZW4uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfb3BlblRhYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XG4gICAgICB2YXIgJHRhYkxpbmsgPSAkdGFyZ2V0LmZpbmQoJ1tyb2xlPVwidGFiXCJdJyksXG4gICAgICAgICAgaGFzaCA9ICR0YWJMaW5rLmF0dHIoJ2RhdGEtdGFicy10YXJnZXQnKSB8fCAkdGFiTGlua1swXS5oYXNoLnNsaWNlKDEpLFxuICAgICAgICAgICR0YXJnZXRDb250ZW50ID0gdGhpcy4kdGFiQ29udGVudC5maW5kKFwiI1wiLmNvbmNhdChoYXNoKSk7XG4gICAgICAkdGFyZ2V0LmFkZENsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpKTtcbiAgICAgICR0YWJMaW5rLmF0dHIoe1xuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyxcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnXG4gICAgICB9KTtcbiAgICAgICR0YXJnZXRDb250ZW50LmFkZENsYXNzKFwiXCIuY29uY2F0KHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKSkucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gY29sbGFwc2UuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29sbGFwc2VUYWJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbGxhcHNlVGFiKCR0YXJnZXQpIHtcbiAgICAgIHZhciAkdGFyZ2V0X2FuY2hvciA9ICR0YXJnZXQucmVtb3ZlQ2xhc3MoXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpLmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuYXR0cih7XG4gICAgICAgICdhcmlhLXNlbGVjdGVkJzogJ2ZhbHNlJyxcbiAgICAgICAgJ3RhYmluZGV4JzogLTFcbiAgICAgIH0pO1xuICAgICAgJChcIiNcIi5jb25jYXQoJHRhcmdldF9hbmNob3IuYXR0cignYXJpYS1jb250cm9scycpKSkucmVtb3ZlQ2xhc3MoXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MpKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBhY3RpdmUgVGFiLlxuICAgICAqIEBmaXJlcyBUYWJzI2NvbGxhcHNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY29sbGFwc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbGxhcHNlKCkge1xuICAgICAgdmFyICRhY3RpdmVUYWIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXCIuXCIuY29uY2F0KHRoaXMub3B0aW9ucy5saW5rQ2xhc3MsIFwiLlwiKS5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykpO1xuXG4gICAgICBpZiAoJGFjdGl2ZVRhYi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fY29sbGFwc2VUYWIoJGFjdGl2ZVRhYik7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNvbGxhcHNlZCB0YWJzLlxuICAgICAgICAqIEBldmVudCBUYWJzI2NvbGxhcHNlXG4gICAgICAgICovXG5cblxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NvbGxhcHNlLnpmLnRhYnMnLCBbJGFjdGl2ZVRhYl0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cbiAgICAgKiBAcGFyYW0ge2pRdWVyeSB8IFN0cmluZ30gZWxlbSAtIGpRdWVyeSBvYmplY3Qgb3Igc3RyaW5nIG9mIHRoZSBpZCBvZiB0aGUgcGFuZSB0byBkaXNwbGF5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlzdG9yeUhhbmRsZWQgLSBicm93c2VyIGhhcyBhbHJlYWR5IGhhbmRsZWQgYSBoaXN0b3J5IHVwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0VGFiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFRhYihlbGVtLCBoaXN0b3J5SGFuZGxlZCkge1xuICAgICAgdmFyIGlkU3RyLCBoYXNoSWRTdHI7XG5cbiAgICAgIGlmIChfdHlwZW9mKGVsZW0pID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZFN0ciA9IGVsZW1bMF0uaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZFN0ciA9IGVsZW07XG4gICAgICB9XG5cbiAgICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XG4gICAgICAgIGhhc2hJZFN0ciA9IFwiI1wiLmNvbmNhdChpZFN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoSWRTdHIgPSBpZFN0cjtcbiAgICAgICAgaWRTdHIgPSBpZFN0ci5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgdmFyICR0YXJnZXQgPSB0aGlzLiR0YWJUaXRsZXMuaGFzKFwiW2hyZWYkPVxcXCJcIi5jb25jYXQoaGFzaElkU3RyLCBcIlxcXCJdLFtkYXRhLXRhYnMtdGFyZ2V0PVxcXCJcIikuY29uY2F0KGlkU3RyLCBcIlxcXCJdXCIpKS5maXJzdCgpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCwgaGlzdG9yeUhhbmRsZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0SGVpZ2h0XCIsXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxuICAgICAqIElmIGVuYWJsZWQgaW4gb3B0aW9ucywgZ2V0cyBjYWxsZWQgb24gbWVkaWEgcXVlcnkgY2hhbmdlLlxuICAgICAqIElmIGxvYWRpbmcgY29udGVudCB2aWEgZXh0ZXJuYWwgc291cmNlLCBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5IG9yIHdpdGggX3JlZmxvdy5cbiAgICAgKiBJZiBlbmFibGVkIHdpdGggYGRhdGEtbWF0Y2gtaGVpZ2h0PVwidHJ1ZVwiYCwgdGFicyBzZXRzIHRvIGVxdWFsIGhlaWdodFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIZWlnaHQoKSB7XG4gICAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7IC8vIExvY2sgZG93biB0aGUgYHRoaXNgIHZhbHVlIGZvciB0aGUgcm9vdCB0YWJzIG9iamVjdFxuXG5cbiAgICAgIHRoaXMuJHRhYkNvbnRlbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpKS5jc3MoJ2hlaWdodCcsICcnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmVsID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGlzQWN0aXZlID0gcGFuZWwuaGFzQ2xhc3MoXCJcIi5jb25jYXQoX3RoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKSk7IC8vIGdldCB0aGUgb3B0aW9ucyBmcm9tIHRoZSBwYXJlbnQgaW5zdGVhZCBvZiB0cnlpbmcgdG8gZ2V0IHRoZW0gZnJvbSB0aGUgY2hpbGRcblxuICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgcGFuZWwuY3NzKHtcbiAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAnZGlzcGxheSc6ICdibG9jaydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICAgIHBhbmVsLmNzcyh7XG4gICAgICAgICAgICAndmlzaWJpbGl0eSc6ICcnLFxuICAgICAgICAgICAgJ2Rpc3BsYXknOiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XG4gICAgICB9KS5jc3MoJ2hlaWdodCcsIFwiXCIuY29uY2F0KG1heCwgXCJweFwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIHRhYnMuXG4gICAgICogQGZpcmVzIFRhYnMjZGVzdHJveWVkXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLmxpbmtDbGFzcykpLm9mZignLnpmLnRhYnMnKS5oaWRlKCkuZW5kKCkuZmluZChcIi5cIi5jb25jYXQodGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpKS5oaWRlKCk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgJCh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub25Mb2FkTGlzdGVuZXIpIHtcbiAgICAgICAgJCh3aW5kb3cpLm9mZih0aGlzLm9uTG9hZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGFicztcbn0oUGx1Z2luKTtcblxuVGFicy5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIExpbmsgdGhlIGxvY2F0aW9uIGhhc2ggdG8gdGhlIGFjdGl2ZSBwYW5lLlxuICAgKiBTZXQgdGhlIGxvY2F0aW9uIGhhc2ggd2hlbiB0aGUgYWN0aXZlIHBhbmUgY2hhbmdlcywgYW5kIG9wZW4gdGhlIGNvcnJlc3BvbmRpbmcgcGFuZSB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVlcExpbms6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBJZiBgZGVlcExpbmtgIGlzIGVuYWJsZWQsIGFkanVzdCB0aGUgZGVlcCBsaW5rIHNjcm9sbCB0byBtYWtlIHN1cmUgdGhlIHRvcCBvZiB0aGUgdGFiIHBhbmVsIGlzIHZpc2libGVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rU211ZGdlYCBpcyBlbmFibGVkLCBhbmltYXRpb24gdGltZSAobXMpIGZvciB0aGUgZGVlcCBsaW5rIGFkanVzdG1lbnRcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAzMDBcbiAgICovXG4gIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcblxuICAvKipcbiAgICogSWYgYGRlZXBMaW5rYCBpcyBlbmFibGVkLCB1cGRhdGUgdGhlIGJyb3dzZXIgaGlzdG9yeSB3aXRoIHRoZSBvcGVuIHRhYlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIGFjdGl2ZSBwYW5lIG9uIGxvYWQuXG4gICAqIE5vdCByZWNvbW1lbmRlZCBpZiBtb3JlIHRoYW4gb25lIHRhYiBwYW5lbCBwZXIgcGFnZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGF1dG9Gb2N1czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEFsbG93cyBrZXlib2FyZCBpbnB1dCB0byAnd3JhcCcgYXJvdW5kIHRoZSB0YWIgbGlua3MuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHdyYXBPbktleXM6IHRydWUsXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgdGFiIGNvbnRlbnQgcGFuZXMgdG8gbWF0Y2ggaGVpZ2h0cyBpZiBzZXQgdG8gdHJ1ZS5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG1hdGNoSGVpZ2h0OiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3dzIGFjdGl2ZSB0YWJzIHRvIGNvbGxhcHNlIHdoZW4gY2xpY2tlZC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFjdGl2ZUNvbGxhcHNlOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2xhc3MgYXBwbGllZCB0byBgbGlgJ3MgaW4gdGFiIGxpbmsgbGlzdC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAndGFicy10aXRsZSdcbiAgICovXG4gIGxpbmtDbGFzczogJ3RhYnMtdGl0bGUnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBhY3RpdmUgYGxpYCBpbiB0YWIgbGluayBsaXN0LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXG4gICAqL1xuICBsaW5rQWN0aXZlQ2xhc3M6ICdpcy1hY3RpdmUnLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250ZW50IGNvbnRhaW5lcnMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ3RhYnMtcGFuZWwnXG4gICAqL1xuICBwYW5lbENsYXNzOiAndGFicy1wYW5lbCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBjb250ZW50IGNvbnRhaW5lci5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnaXMtYWN0aXZlJ1xuICAgKi9cbiAgcGFuZWxBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZSdcbn07XG5cbi8qKlxuICogVG9nZ2xlciBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxuICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqL1xuXG52YXIgVG9nZ2xlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1BsdWdpbikge1xuICBfaW5oZXJpdHMoVG9nZ2xlciwgX1BsdWdpbik7XG5cbiAgZnVuY3Rpb24gVG9nZ2xlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9nZ2xlcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRvZ2dsZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvZ2dsZXIsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUb2dnbGVyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBuYW1lIFRvZ2dsZXJcbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUb2dnbGVyLmRlZmF1bHRzLCBlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnVG9nZ2xlcic7IC8vIGllOSBiYWNrIGNvbXBhdFxuICAgICAgLy8gVHJpZ2dlcnMgaW5pdCBpcyBpZGVtcG90ZW50LCBqdXN0IG5lZWQgdG8gbWFrZSBzdXJlIGl0IGlzIGluaXRpYWxpemVkXG5cbiAgICAgIFRyaWdnZXJzLmluaXQoJCk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBUb2dnbGVyIHBsdWdpbiBieSBwYXJzaW5nIHRoZSB0b2dnbGUgY2xhc3MgZnJvbSBkYXRhLXRvZ2dsZXIsIG9yIGFuaW1hdGlvbiBjbGFzc2VzIGZyb20gZGF0YS1hbmltYXRlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgIC8vIENvbGxlY3QgdHJpZ2dlcnMgdG8gc2V0IEFSSUEgYXR0cmlidXRlcyB0b1xuICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCxcbiAgICAgICAgICAkdHJpZ2dlcnMgPSAkKFwiW2RhdGEtb3Blbn49XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXSwgW2RhdGEtY2xvc2V+PVxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJdLCBbZGF0YS10b2dnbGV+PVxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJdXCIpKTtcbiAgICAgIHZhciBpbnB1dDsgLy8gUGFyc2UgYW5pbWF0aW9uIGNsYXNzZXMgaWYgdGhleSB3ZXJlIHNldFxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgaW5wdXQgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdCgnICcpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkluID0gaW5wdXRbMF07XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uT3V0ID0gaW5wdXRbMV0gfHwgbnVsbDsgLy8gLSBhcmlhLWV4cGFuZGVkOiBhY2NvcmRpbmcgdG8gdGhlIGVsZW1lbnQgdmlzaWJpbGl0eS5cblxuICAgICAgICAkdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICF0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpO1xuICAgICAgfSAvLyBPdGhlcndpc2UsIHBhcnNlIHRvZ2dsZSBjbGFzc1xuICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSB0aGlzLm9wdGlvbnMudG9nZ2xlcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnIHx8ICFpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAndG9vZ2xlcicgb3B0aW9uIGNvbnRhaW5pbmcgdGhlIHRhcmdldCBjbGFzcyBpcyByZXF1aXJlZCwgZ290IFxcXCJcIi5jb25jYXQoaW5wdXQsIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfSAvLyBBbGxvdyBmb3IgYSAuIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZ1xuXG5cbiAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGlucHV0WzBdID09PSAnLicgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0OyAvLyAtIGFyaWEtZXhwYW5kZWQ6IGFjY29yZGluZyB0byB0aGUgZWxlbWVudHMgY2xhc3Mgc2V0LlxuXG4gICAgICAgICAgJHRyaWdnZXJzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMuY2xhc3NOYW1lKSk7XG4gICAgICAgIH0gLy8gLSBhcmlhLWNvbnRyb2xzOiBhZGRpbmcgdGhlIGVsZW1lbnQgaWQgdG8gaXQgaWYgbm90IGFscmVhZHkgaW4gaXQuXG5cblxuICAgICAgJHRyaWdnZXJzLmVhY2goZnVuY3Rpb24gKGluZGV4LCB0cmlnZ2VyKSB7XG4gICAgICAgIHZhciAkdHJpZ2dlciA9ICQodHJpZ2dlcik7XG4gICAgICAgIHZhciBjb250cm9scyA9ICR0cmlnZ2VyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSB8fCAnJztcbiAgICAgICAgdmFyIGNvbnRhaW5zSWQgPSBuZXcgUmVnRXhwKFwiXFxcXGJcIi5jb25jYXQoUmVnRXhwRXNjYXBlKGlkKSwgXCJcXFxcYlwiKSkudGVzdChjb250cm9scyk7XG4gICAgICAgIGlmICghY29udGFpbnNJZCkgJHRyaWdnZXIuYXR0cignYXJpYS1jb250cm9scycsIGNvbnRyb2xzID8gXCJcIi5jb25jYXQoY29udHJvbHMsIFwiIFwiKS5jb25jYXQoaWQpIDogaWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG9nZ2xlLnpmLnRyaWdnZXInKS5vbigndG9nZ2xlLnpmLnRyaWdnZXInLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXCJvblwiIG9yIFwib2ZmXCIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFRvZ2dsZXIjb25cbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNvZmZcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInRvZ2dsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICB0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlID8gJ190b2dnbGVBbmltYXRlJyA6ICdfdG9nZ2xlQ2xhc3MnXSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdG9nZ2xlQ2xhc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKCkge1xuICAgICAgdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XG4gICAgICB2YXIgaXNPbiA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xuXG4gICAgICBpZiAoaXNPbikge1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGhhcyB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXG4gICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVBUklBKGlzT24pO1xuXG4gICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b2dnbGVBbmltYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICBNb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTtcblxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xuICAgICAgICAgIHRoaXMuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbk91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl91cGRhdGVBUklBKGZhbHNlKTtcblxuICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICAgICAgICB0aGlzLmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlQVJJQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQVJJQShpc09uKSB7XG4gICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkO1xuICAgICAgJChcIltkYXRhLW9wZW49XFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXSwgW2RhdGEtY2xvc2U9XFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXVwiKSkuYXR0cih7XG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogaXNPbiA/IHRydWUgOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRvZ2dsZXInKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9nZ2xlcjtcbn0oUGx1Z2luKTtcblxuVG9nZ2xlci5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIENsYXNzIG9mIHRoZSBlbGVtZW50IHRvIHRvZ2dsZS4gSXQgY2FuIGJlIHByb3ZpZGVkIHdpdGggb3Igd2l0aG91dCBcIi5cIlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0b2dnbGVyOiB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIFRlbGxzIHRoZSBwbHVnaW4gaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGVkIHdoZW4gdG9nZ2xlZC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFuaW1hdGU6IGZhbHNlXG59O1xuXG4vKipcbiAqIFRvb2x0aXAgbW9kdWxlLlxuICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvb2x0aXBcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAqL1xuXG52YXIgVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1Bvc2l0aW9uYWJsZSkge1xuICBfaW5oZXJpdHMoVG9vbHRpcCwgX1Bvc2l0aW9uYWJsZSk7XG5cbiAgZnVuY3Rpb24gVG9vbHRpcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFRvb2x0aXApLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIFRvb2x0aXAuXG4gICAgICogQGNsYXNzXG4gICAgICogQG5hbWUgVG9vbHRpcFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIGEgdG9vbHRpcCB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB0byBleHRlbmQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1Rvb2x0aXAnOyAvLyBpZTkgYmFjayBjb21wYXRcblxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0NsaWNrID0gZmFsc2U7IC8vIFRyaWdnZXJzIGluaXQgaXMgaWRlbXBvdGVudCwganVzdCBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBpcyBpbml0aWFsaXplZFxuXG4gICAgICBUcmlnZ2Vycy5pbml0KCQpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwIGJ5IHNldHRpbmcgdGhlIGNyZWF0aW5nIHRoZSB0aXAgZWxlbWVudCwgYWRkaW5nIGl0J3MgdGV4dCwgc2V0dGluZyBwcml2YXRlIHZhcmlhYmxlcyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSBhbmNob3IuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9pbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgTWVkaWFRdWVyeS5faW5pdCgpO1xuXG4gICAgICB2YXIgZWxlbUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JykgfHwgR2V0WW9EaWdpdHMoNiwgJ3Rvb2x0aXAnKTtcbiAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA/ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0h0bWwpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS5odG1sKHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgJ3RpdGxlJzogJycsXG4gICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZWxlbUlkLFxuICAgICAgICAnZGF0YS15ZXRpLWJveCc6IGVsZW1JZCxcbiAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxuICAgICAgICAnZGF0YS1yZXNpemUnOiBlbGVtSWRcbiAgICAgIH0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihUb29sdGlwLnByb3RvdHlwZSksIFwiX2luaXRcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXREZWZhdWx0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRQb3NpdGlvbigpIHtcbiAgICAgIC8vIGhhbmRsZSBsZWdhY3kgY2xhc3NuYW1lc1xuICAgICAgdmFyIGVsZW1lbnRDbGFzc05hbWUgPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZTtcblxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnRDbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLmJhc2VWYWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGVsZW1lbnRDbGFzc05hbWUubWF0Y2goL1xcYih0b3B8bGVmdHxyaWdodHxib3R0b20pXFxiL2cpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gcG9zaXRpb25bMF0gOiAndG9wJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERlZmF1bHRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERlZmF1bHRBbGlnbm1lbnQoKSB7XG4gICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRIT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JyB8fCB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaE9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWT2Zmc2V0KCkge1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMucG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudk9mZnNldCArIHRoaXMub3B0aW9ucy50b29sdGlwSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBidWlsZHMgdGhlIHRvb2x0aXAgZWxlbWVudCwgYWRkcyBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyB0aGUgdGVtcGxhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9idWlsZFRlbXBsYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFRlbXBsYXRlKGlkKSB7XG4gICAgICB2YXIgdGVtcGxhdGVDbGFzc2VzID0gXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcywgXCIgXCIpLmNvbmNhdCh0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCk7XG4gICAgICB2YXIgJHRlbXBsYXRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoe1xuICAgICAgICAncm9sZSc6ICd0b29sdGlwJyxcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2UsXG4gICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXG4gICAgICAgICdpZCc6IGlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkdGVtcGxhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIHBvc2l0aW9uIGNsYXNzIG9mIGFuIGVsZW1lbnQgYW5kIHJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiB1bnRpbCB0aGVyZSBhcmUgbm8gbW9yZSBwb3NzaWJsZSBwb3NpdGlvbnMgdG8gYXR0ZW1wdCwgb3IgdGhlIHRvb2x0aXAgZWxlbWVudCBpcyBubyBsb25nZXIgY29sbGlkaW5nLlxuICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoVG9vbHRpcC5wcm90b3R5cGUpLCBcIl9zZXRQb3NpdGlvblwiLCB0aGlzKS5jYWxsKHRoaXMsIHRoaXMuJGVsZW1lbnQsIHRoaXMudGVtcGxhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgKiBAZmlyZXMgVG9vbHRpcCNjbG9zZW1lXG4gICAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93T24gIT09ICdhbGwnICYmICFNZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zaG93T24pKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RoZSBzY3JlZW4gaXMgdG9vIHNtYWxsIHRvIGRpc3BsYXkgdGhpcyB0b29sdGlwJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy50ZW1wbGF0ZS5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuc2hvdygpO1xuXG4gICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKCd0b3AgYm90dG9tIGxlZnQgcmlnaHQnKS5hZGRDbGFzcyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MoJ2FsaWduLXRvcCBhbGlnbi1ib3R0b20gYWxpZ24tbGVmdCBhbGlnbi1yaWdodCBhbGlnbi1jZW50ZXInKS5hZGRDbGFzcygnYWxpZ24tJyArIHRoaXMuYWxpZ25tZW50KTtcbiAgICAgIC8qKlxuICAgICAgICogRmlyZXMgdG8gY2xvc2UgYWxsIG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYudG9vbHRpcCcsIHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7XG4gICAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xuICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxuICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7IC8vIGNvbnNvbGUubG9nKHRoaXMudGVtcGxhdGUpO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5oaWRlKCkuY3NzKCd2aXNpYmlsaXR5JywgJycpLmZhZGVJbih0aGlzLm9wdGlvbnMuZmFkZUluRHVyYXRpb24sIGZ1bmN0aW9uICgpIHsvL21heWJlIGRvIHN0dWZmP1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd25cbiAgICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgY3VycmVudCB0b29sdGlwLCBhbmQgcmVzZXRzIHRoZSBwb3NpdGlvbmluZyBjbGFzcyBpZiBpdCB3YXMgY2hhbmdlZCBkdWUgdG8gY29sbGlzaW9uXG4gICAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLnRlbXBsYXRlLnN0b3AoKS5hdHRyKHtcbiAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2VcbiAgICAgIH0pLmZhZGVPdXQodGhpcy5vcHRpb25zLmZhZGVPdXREdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIC8qKlxuICAgICAgICogZmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW5cbiAgICAgICAqIEBldmVudCBUb29sdGlwI2hpZGVcbiAgICAgICAqL1xuXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYudG9vbHRpcCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRzIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIHRvb2x0aXAgYW5kIGl0cyBhbmNob3JcbiAgICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJztcbiAgICAgIHZhciAkdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgdmFyIGlzRm9jdXMgPSBmYWxzZTsgLy8gYGRpc2FibGVGb3JUb3VjaDogRnVsbHkgZGlzYWJsZSB0aGUgdG9vbHRpcCBvbiB0b3VjaCBkZXZpY2VzXG5cbiAgICAgIGlmIChoYXNUb3VjaCAmJiB0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNoKSByZXR1cm47XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWVudGVyLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICghX3RoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLnRvb2x0aXAnLCBpZ25vcmVNb3VzZWRpc2FwcGVhcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcblxuICAgICAgICAgIGlmICghaXNGb2N1cyB8fCBfdGhpcy5pc0NsaWNrICYmICFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzVG91Y2gpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPyBfdGhpcy5oaWRlKCkgOiBfdGhpcy5zaG93KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWRvd24uemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIDsgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKChfdGhpcy5vcHRpb25zLmRpc2FibGVIb3ZlciB8fCAhX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkgJiYgIV90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgIC8vICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAgIC8vICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcbiAgICAgICAgJ2Nsb3NlLnpmLnRyaWdnZXInOiB0aGlzLmhpZGUuYmluZCh0aGlzKVxuICAgICAgfSk7XG4gICAgICB0aGlzLiRlbGVtZW50Lm9uKCdmb2N1cy56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaXNGb2N1cyA9IHRydWU7XG5cbiAgICAgICAgaWYgKF90aGlzLmlzQ2xpY2spIHtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgc2hvd2luZyBvcGVuIG9uIGNsaWNrcywgd2UgbmVlZCB0byBwcmV0ZW5kIGEgY2xpY2stbGF1bmNoZWQgZm9jdXMgaXNuJ3RcbiAgICAgICAgICAvLyBhIHJlYWwgZm9jdXMsIG90aGVyd2lzZSBvbiBob3ZlciBhbmQgY29tZSBiYWNrIHdlIGdldCBiYWQgYmVoYXZpb3JcbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XG4gICAgICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSkub24oJ2ZvY3Vzb3V0LnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICB9KS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBhZGRzIGEgdG9nZ2xlIG1ldGhvZCwgaW4gYWRkaXRpb24gdG8gdGhlIHN0YXRpYyBzaG93KCkgJiBoaWRlKCkgZnVuY3Rpb25zXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgdG9vbHRpcCwgcmVtb3ZlcyB0ZW1wbGF0ZSBlbGVtZW50IGZyb20gdGhlIHZpZXcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKCcuemYudHJpZ2dlciAuemYudG9vbHRpcCcpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpLnJlbW92ZUNsYXNzKCd0b3AgcmlnaHQgbGVmdCBib3R0b20nKS5yZW1vdmVBdHRyKCdhcmlhLWRlc2NyaWJlZGJ5IGRhdGEtZGlzYWJsZS1ob3ZlciBkYXRhLXJlc2l6ZSBkYXRhLXRvZ2dsZSBkYXRhLXRvb2x0aXAgZGF0YS15ZXRpLWJveCcpO1xuICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oUG9zaXRpb25hYmxlKTtcblxuVG9vbHRpcC5kZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFRpbWUsIGluIG1zLCBiZWZvcmUgYSB0b29sdGlwIHNob3VsZCBvcGVuIG9uIGhvdmVyLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDIwMFxuICAgKi9cbiAgaG92ZXJEZWxheTogMjAwLFxuXG4gIC8qKlxuICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDE1MFxuICAgKi9cbiAgZmFkZUluRHVyYXRpb246IDE1MCxcblxuICAvKipcbiAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDE1MFxuICAgKi9cbiAgZmFkZU91dER1cmF0aW9uOiAxNTAsXG5cbiAgLyoqXG4gICAqIERpc2FibGVzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgdGhlIHRvb2x0aXAgaWYgc2V0IHRvIHRydWVcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVIb3ZlcjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERpc2FibGUgdGhlIHRvb2x0aXAgZm9yIHRvdWNoIGRldmljZXMuXG4gICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtYWtlIGVsZW1lbnRzIHdpdGggYSB0b29sdGlwIG9uIGl0IHRyaWdnZXIgdGhlaXJcbiAgICogYWN0aW9uIG9uIHRoZSBmaXJzdCB0YXAgaW5zdGVhZCBvZiBkaXNwbGF5aW5nIHRoZSB0b29sdGlwLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29lbGFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGlzYWJsZUZvclRvdWNoOiBmYWxzZSxcblxuICAvKipcbiAgICogT3B0aW9uYWwgYWRkdGlvbmFsIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gaW5pdC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgdGVtcGxhdGVDbGFzc2VzOiAnJyxcblxuICAvKipcbiAgICogTm9uLW9wdGlvbmFsIGNsYXNzIGFkZGVkIHRvIHRvb2x0aXAgdGVtcGxhdGVzLiBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgJ3Rvb2x0aXAnLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICd0b29sdGlwJ1xuICAgKi9cbiAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXG5cbiAgLyoqXG4gICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIHRvb2x0aXAgYW5jaG9yIGVsZW1lbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2hhcy10aXAnXG4gICAqL1xuICB0cmlnZ2VyQ2xhc3M6ICdoYXMtdGlwJyxcblxuICAvKipcbiAgICogTWluaW11bSBicmVha3BvaW50IHNpemUgYXQgd2hpY2ggdG8gb3BlbiB0aGUgdG9vbHRpcC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnc21hbGwnXG4gICAqL1xuICBzaG93T246ICdzbWFsbCcsXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB0ZW1wbGF0ZSB0byBiZSB1c2VkIHRvIGdlbmVyYXRlIG1hcmt1cCBmb3IgdG9vbHRpcC5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnJ1xuICAgKi9cbiAgdGVtcGxhdGU6ICcnLFxuXG4gIC8qKlxuICAgKiBUZXh0IGRpc3BsYXllZCBpbiB0aGUgdG9vbHRpcCB0ZW1wbGF0ZSBvbiBvcGVuLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICcnXG4gICAqL1xuICB0aXBUZXh0OiAnJyxcbiAgdG91Y2hDbG9zZVRleHQ6ICdUYXAgdG8gY2xvc2UuJyxcblxuICAvKipcbiAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNsaWNrT3BlbjogdHJ1ZSxcblxuICAvKipcbiAgICogUG9zaXRpb24gb2YgdG9vbHRpcC4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgb3IgYXV0by5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnYXV0bydcbiAgICovXG4gIHBvc2l0aW9uOiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsaWdubWVudCBvZiB0b29sdGlwIHJlbGF0aXZlIHRvIGFuY2hvci4gQ2FuIGJlIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgY2VudGVyLCBvciBhdXRvLlxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdhdXRvJ1xuICAgKi9cbiAgYWxpZ25tZW50OiAnYXV0bycsXG5cbiAgLyoqXG4gICAqIEFsbG93IG92ZXJsYXAgb2YgY29udGFpbmVyL3dpbmRvdy4gSWYgZmFsc2UsIHRvb2x0aXAgd2lsbCBmaXJzdCB0cnkgdG9cbiAgICogcG9zaXRpb24gYXMgZGVmaW5lZCBieSBkYXRhLXBvc2l0aW9uIGFuZCBkYXRhLWFsaWdubWVudCwgYnV0IHJlcG9zaXRpb24gaWZcbiAgICogaXQgd291bGQgY2F1c2UgYW4gb3ZlcmZsb3cuICBAb3B0aW9uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYWxsb3dPdmVybGFwOiBmYWxzZSxcblxuICAvKipcbiAgICogQWxsb3cgb3ZlcmxhcCBvZiBvbmx5IHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lci4gVGhpcyBpcyB0aGUgbW9zdCBjb21tb25cbiAgICogYmVoYXZpb3IgZm9yIGRyb3Bkb3ducywgYWxsb3dpbmcgdGhlIGRyb3Bkb3duIHRvIGV4dGVuZCB0aGUgYm90dG9tIG9mIHRoZVxuICAgKiBzY3JlZW4gYnV0IG5vdCBvdGhlcndpc2UgaW5mbHVlbmNlIG9yIGJyZWFrIG91dCBvZiB0aGUgY29udGFpbmVyLlxuICAgKiBMZXNzIGNvbW1vbiBmb3IgdG9vbHRpcHMuXG4gICAqIEBvcHRpb25cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0JvdHRvbU92ZXJsYXA6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFkgYXhpcy5cbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICB2T2Zmc2V0OiAwLFxuXG4gIC8qKlxuICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFggYXhpc1xuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIGhPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzcGFjaW5nIGF1dG8tYWRqdXN0IGZvciBhIHZlcnRpY2FsIHRvb2x0aXBcbiAgICogQG9wdGlvblxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxNFxuICAgKi9cbiAgdG9vbHRpcEhlaWdodDogMTQsXG5cbiAgLyoqXG4gICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzcGFjaW5nIGF1dG8tYWRqdXN0IGZvciBhIGhvcml6b250YWwgdG9vbHRpcFxuICAgKiBAb3B0aW9uXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDEyXG4gICAqL1xuICB0b29sdGlwV2lkdGg6IDEyLFxuXG4gIC8qKlxuICAqIEFsbG93IEhUTUwgaW4gdG9vbHRpcC4gV2FybmluZzogSWYgeW91IGFyZSBsb2FkaW5nIHVzZXItZ2VuZXJhdGVkIGNvbnRlbnQgaW50byB0b29sdGlwcyxcbiAgKiBhbGxvd2luZyBIVE1MIG1heSBvcGVuIHlvdXJzZWxmIHVwIHRvIFhTUyBhdHRhY2tzLlxuICAqIEBvcHRpb25cbiAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKiBAZGVmYXVsdCBmYWxzZVxuICAqL1xuICBhbGxvd0h0bWw6IGZhbHNlXG59O1xuXG52YXIgTWVudVBsdWdpbnMkMSA9IHtcbiAgdGFiczoge1xuICAgIGNzc0NsYXNzOiAndGFicycsXG4gICAgcGx1Z2luOiBUYWJzLFxuICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4ocGx1Z2luLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBwbHVnaW4uc2VsZWN0VGFiKHRhcmdldCk7XG4gICAgfSxcbiAgICBjbG9zZTogbnVsbFxuICAgIC8qIG5vdCBzdXBwb3J0ZWQgKi9cbiAgICAsXG4gICAgdG9nZ2xlOiBudWxsXG4gICAgLyogbm90IHN1cHBvcnRlZCAqL1xuXG4gIH0sXG4gIGFjY29yZGlvbjoge1xuICAgIGNzc0NsYXNzOiAnYWNjb3JkaW9uJyxcbiAgICBwbHVnaW46IEFjY29yZGlvbixcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKHBsdWdpbiwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gcGx1Z2luLmRvd24oJCh0YXJnZXQpKTtcbiAgICB9LFxuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZShwbHVnaW4sIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHBsdWdpbi51cCgkKHRhcmdldCkpO1xuICAgIH0sXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUocGx1Z2luLCB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBwbHVnaW4udG9nZ2xlKCQodGFyZ2V0KSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyBtb2R1bGUuXG4gKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZUFjY29yZGlvblRhYnNcbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gKiBAcmVxdWlyZXMgZm91bmRhdGlvbi5hY2NvcmRpb25cbiAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnRhYnNcbiAqL1xuXG52YXIgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW4pIHtcbiAgX2luaGVyaXRzKFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLCBfUGx1Z2luKTtcblxuICBmdW5jdGlvbiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyhlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyk7XG5cbiAgICBfdGhpczIgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMpLmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucykpO1xuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpczIsIF90aGlzMi5vcHRpb25zLnJlZmxvdyAmJiBfdGhpczIuc3RvcmV6ZkRhdGEgfHwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgYWNjb3JkaW9uIHRhYnMuXG4gICAqIEBjbGFzc1xuICAgKiBAbmFtZSBSZXNwb25zaXZlQWNjb3JkaW9uVGFic1xuICAgKiBAZmlyZXMgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMjaW5pdFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIFJlc3BvbnNpdmUgQWNjb3JkaW9uIFRhYnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMsIFt7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICB0aGlzLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luQmFzZScsIHRoaXMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKCdyZXNwb25zaXZlLWFjY29yZGlvbi10YWJzJyk7XG4gICAgICB0aGlzLmN1cnJlbnRNcSA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRSdWxlID0gbnVsbDtcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicyc7IC8vIGllOSBiYWNrIGNvbXBhdFxuXG4gICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJywgR2V0WW9EaWdpdHMoNiwgJ3Jlc3BvbnNpdmVhY2NvcmRpb250YWJzJykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWVudSBieSBwYXJzaW5nIHRoZSBjbGFzc2VzIGZyb20gdGhlICdkYXRhLXJlc3BvbnNpdmUtYWNjb3JkaW9uLXRhYnMnIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICBNZWRpYVF1ZXJ5Ll9pbml0KCk7IC8vIFRoZSBmaXJzdCB0aW1lIGFuIEludGVyY2hhbmdlIHBsdWdpbiBpcyBpbml0aWFsaXplZCwgdGhpcy5ydWxlcyBpcyBjb252ZXJ0ZWQgZnJvbSBhIHN0cmluZyBvZiBcImNsYXNzZXNcIiB0byBhbiBvYmplY3Qgb2YgcnVsZXNcblxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTsgLy8gUGFyc2UgcnVsZXMgZnJvbSBcImNsYXNzZXNcIiBwdWxsZWQgZnJvbSBkYXRhIGF0dHJpYnV0ZVxuXG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTsgLy8gSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IHJ1bGUgZm91bmRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xuICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xuICAgICAgICAgIHZhciBydWxlUGx1Z2luID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVsxXSA6IHJ1bGVbMF07XG5cbiAgICAgICAgICBpZiAoTWVudVBsdWdpbnMkMVtydWxlUGx1Z2luXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zJDFbcnVsZVBsdWdpbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzVHJlZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZ2V0QWxsT3B0aW9ucygpO1xuXG4gICAgICBpZiAoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xuICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWxsT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsT3B0aW9ucygpIHtcbiAgICAgIC8vZ2V0IGFsbCBkZWZhdWx0cyBhbmQgb3B0aW9uc1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgX3RoaXMuYWxsT3B0aW9ucyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gTWVudVBsdWdpbnMkMSkge1xuICAgICAgICBpZiAoTWVudVBsdWdpbnMkMS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IE1lbnVQbHVnaW5zJDFba2V5XTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZHVtbXlQbHVnaW4gPSAkKCc8dWw+PC91bD4nKTtcbiAgICAgICAgICAgIHZhciB0bXBQbHVnaW4gPSBuZXcgb2JqLnBsdWdpbihkdW1teVBsdWdpbiwgX3RoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGtleUtleSBpbiB0bXBQbHVnaW4ub3B0aW9ucykge1xuICAgICAgICAgICAgICBpZiAodG1wUGx1Z2luLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5S2V5KSAmJiBrZXlLZXkgIT09ICd6ZlBsdWdpbicpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqT2JqID0gdG1wUGx1Z2luLm9wdGlvbnNba2V5S2V5XTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hbGxPcHRpb25zW2tleUtleV0gPSBvYmpPYmo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG1wUGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIE1lbnUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9ldmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRaZk1lZGlhUXVlcnlIYW5kbGVyID0gdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMuYmluZCh0aGlzKTtcbiAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fY2hhbmdlZFpmTWVkaWFRdWVyeUhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgc2NyZWVuIHdpZHRoIGFnYWluc3QgYXZhaWxhYmxlIG1lZGlhIHF1ZXJpZXMuIElmIHRoZSBtZWRpYSBxdWVyeSBoYXMgY2hhbmdlZCwgYW5kIHRoZSBwbHVnaW4gbmVlZGVkIGhhcyBjaGFuZ2VkLCB0aGUgcGx1Z2lucyB3aWxsIHN3YXAgb3V0LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfY2hlY2tNZWRpYVF1ZXJpZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NoZWNrTWVkaWFRdWVyaWVzKCkge1xuICAgICAgdmFyIG1hdGNoZWRNcSxcbiAgICAgICAgICBfdGhpcyA9IHRoaXM7IC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIGZpbmQgdGhlIGxhc3QgbWF0Y2hpbmcgcnVsZVxuXG5cbiAgICAgICQuZWFjaCh0aGlzLnJ1bGVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChNZWRpYVF1ZXJ5LmF0TGVhc3Qoa2V5KSkge1xuICAgICAgICAgIG1hdGNoZWRNcSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIE5vIG1hdGNoPyBObyBkaWNlXG5cbiAgICAgIGlmICghbWF0Y2hlZE1xKSByZXR1cm47IC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47IC8vIFJlbW92ZSBleGlzdGluZyBwbHVnaW4tc3BlY2lmaWMgQ1NTIGNsYXNzZXNcblxuICAgICAgJC5lYWNoKE1lbnVQbHVnaW5zJDEsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHZhbHVlLmNzc0NsYXNzKTtcbiAgICAgIH0pOyAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cblxuICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpOyAvLyBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhlIG5ldyBwbHVnaW5cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBsdWdpbikge1xuICAgICAgICAvL2Rvbid0IGtub3cgd2h5IGJ1dCBvbiBuZXN0ZWQgZWxlbWVudHMgZGF0YSB6ZlBsdWdpbiBnZXQncyBsb3N0XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykgJiYgdGhpcy5zdG9yZXpmRGF0YSkgdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgdGhpcy5zdG9yZXpmRGF0YSk7XG4gICAgICAgIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hhbmRsZU1hcmt1cCh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpO1xuXG4gICAgICB0aGlzLmN1cnJlbnRSdWxlID0gdGhpcy5ydWxlc1ttYXRjaGVkTXFdO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMuY3VycmVudFJ1bGUucGx1Z2luKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLnN0b3JlemZEYXRhID0gdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVNYXJrdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1hcmt1cCh0b1NldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICBmcm9tU3RyaW5nID0gJ2FjY29yZGlvbic7XG5cbiAgICAgIHZhciAkcGFuZWxzID0gJCgnW2RhdGEtdGFicy1jb250ZW50PScgKyB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXScpO1xuICAgICAgaWYgKCRwYW5lbHMubGVuZ3RoKSBmcm9tU3RyaW5nID0gJ3RhYnMnO1xuXG4gICAgICBpZiAoZnJvbVN0cmluZyA9PT0gdG9TZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFic1RpdGxlID0gX3RoaXMuYWxsT3B0aW9ucy5saW5rQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLmxpbmtDbGFzcyA6ICd0YWJzLXRpdGxlJztcbiAgICAgIHZhciB0YWJzUGFuZWwgPSBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgOiAndGFicy1wYW5lbCc7XG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUF0dHIoJ3JvbGUnKTtcbiAgICAgIHZhciAkbGlIZWFkcyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy4nICsgdGFic1RpdGxlICsgJyxbZGF0YS1hY2NvcmRpb24taXRlbV0nKS5yZW1vdmVDbGFzcyh0YWJzVGl0bGUpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24taXRlbScpLnJlbW92ZUF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nKTtcbiAgICAgIHZhciAkbGlIZWFkc0EgPSAkbGlIZWFkcy5jaGlsZHJlbignYScpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24tdGl0bGUnKTtcblxuICAgICAgaWYgKGZyb21TdHJpbmcgPT09ICd0YWJzJykge1xuICAgICAgICAkcGFuZWxzID0gJHBhbmVscy5jaGlsZHJlbignLicgKyB0YWJzUGFuZWwpLnJlbW92ZUNsYXNzKHRhYnNQYW5lbCkucmVtb3ZlQXR0cigncm9sZScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgICAgICRwYW5lbHMuY2hpbGRyZW4oJ2EnKS5yZW1vdmVBdHRyKCdyb2xlJykucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRwYW5lbHMgPSAkbGlIZWFkcy5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50Jyk7XG4gICAgICB9XG5cbiAgICAgICRwYW5lbHMuY3NzKHtcbiAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgIHZpc2liaWxpdHk6ICcnXG4gICAgICB9KTtcbiAgICAgICRsaUhlYWRzLmNzcyh7XG4gICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICB2aXNpYmlsaXR5OiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0b1NldCA9PT0gJ2FjY29yZGlvbicpIHtcbiAgICAgICAgJHBhbmVscy5lYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgJCh2YWx1ZSkuYXBwZW5kVG8oJGxpSGVhZHMuZ2V0KGtleSkpLmFkZENsYXNzKCdhY2NvcmRpb24tY29udGVudCcpLmF0dHIoJ2RhdGEtdGFiLWNvbnRlbnQnLCAnJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmNzcyh7XG4gICAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJCgnW2RhdGEtdGFicy1jb250ZW50PScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKS5hZnRlcignPGRpdiBpZD1cInRhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXCI+PC9kaXY+JykuZGV0YWNoKCk7XG4gICAgICAgICAgJGxpSGVhZHMuYWRkQ2xhc3MoJ2FjY29yZGlvbi1pdGVtJykuYXR0cignZGF0YS1hY2NvcmRpb24taXRlbScsICcnKTtcbiAgICAgICAgICAkbGlIZWFkc0EuYWRkQ2xhc3MoJ2FjY29yZGlvbi10aXRsZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodG9TZXQgPT09ICd0YWJzJykge1xuICAgICAgICB2YXIgJHRhYnNDb250ZW50ID0gJCgnW2RhdGEtdGFicy1jb250ZW50PScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKTtcbiAgICAgICAgdmFyICRwbGFjZWhvbGRlciA9ICQoJyN0YWJzLXBsYWNlaG9sZGVyLScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcblxuICAgICAgICBpZiAoJHBsYWNlaG9sZGVyLmxlbmd0aCkge1xuICAgICAgICAgICR0YWJzQ29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJ0YWJzLWNvbnRlbnRcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcigkcGxhY2Vob2xkZXIpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG4gICAgICAgICAgJHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICR0YWJzQ29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJ0YWJzLWNvbnRlbnRcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcihfdGhpcy4kZWxlbWVudCkuYXR0cignZGF0YS10YWJzLWNvbnRlbnQnLCBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRwYW5lbHMuZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciB0ZW1wVmFsdWUgPSAkKHZhbHVlKS5hcHBlbmRUbygkdGFic0NvbnRlbnQpLmFkZENsYXNzKHRhYnNQYW5lbCk7XG4gICAgICAgICAgdmFyIGhhc2ggPSAkbGlIZWFkc0EuZ2V0KGtleSkuaGFzaC5zbGljZSgxKTtcbiAgICAgICAgICB2YXIgaWQgPSAkKHZhbHVlKS5hdHRyKCdpZCcpIHx8IEdldFlvRGlnaXRzKDYsICdhY2NvcmRpb24nKTtcblxuICAgICAgICAgIGlmIChoYXNoICE9PSBpZCkge1xuICAgICAgICAgICAgaWYgKGhhc2ggIT09ICcnKSB7XG4gICAgICAgICAgICAgICQodmFsdWUpLmF0dHIoJ2lkJywgaGFzaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYXNoID0gaWQ7XG4gICAgICAgICAgICAgICQodmFsdWUpLmF0dHIoJ2lkJywgaGFzaCk7XG4gICAgICAgICAgICAgICQoJGxpSGVhZHNBLmdldChrZXkpKS5hdHRyKCdocmVmJywgJCgkbGlIZWFkc0EuZ2V0KGtleSkpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCcjJywgJycpICsgJyMnICsgaGFzaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gJCgkbGlIZWFkcy5nZXQoa2V5KSkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICB0ZW1wVmFsdWUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRsaUhlYWRzLmFkZENsYXNzKHRhYnNUaXRsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBwbHVnaW4gcGFuZSBkZWZpbmVkIGJ5IGB0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IHwgU3RyaW5nfSB0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gb3Blbi5cbiAgICAgKiBAc2VlIEFjY29yZGlvbi5kb3duXG4gICAgICogQHNlZSBUYWJzLnNlbGVjdFRhYlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKF90YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSdWxlICYmIHR5cGVvZiB0aGlzLmN1cnJlbnRSdWxlLm9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRSdWxlO1xuXG4gICAgICAgIHJldHVybiAoX3RoaXMkY3VycmVudFJ1bGUgPSB0aGlzLmN1cnJlbnRSdWxlKS5vcGVuLmFwcGx5KF90aGlzJGN1cnJlbnRSdWxlLCBbdGhpcy5jdXJyZW50UGx1Z2luXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHBsdWdpbiBwYW5lIGRlZmluZWQgYnkgYHRhcmdldGAuIE5vdCBhdmFpbGFpYmxlIGZvciBUYWJzLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IHwgU3RyaW5nfSB0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gY2xvc2UuXG4gICAgICogQHNlZSBBY2NvcmRpb24udXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKF90YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSdWxlICYmIHR5cGVvZiB0aGlzLmN1cnJlbnRSdWxlLmNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfdGhpcyRjdXJyZW50UnVsZTI7XG5cbiAgICAgICAgcmV0dXJuIChfdGhpcyRjdXJyZW50UnVsZTIgPSB0aGlzLmN1cnJlbnRSdWxlKS5jbG9zZS5hcHBseShfdGhpcyRjdXJyZW50UnVsZTIsIFt0aGlzLmN1cnJlbnRQbHVnaW5dLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHBsdWdpbiBwYW5lIGRlZmluZWQgYnkgYHRhcmdldGAuIE5vdCBhdmFpbGFpYmxlIGZvciBUYWJzLlxuICAgICAqIEBwYXJhbSB7alF1ZXJ5IHwgU3RyaW5nfSB0YXJnZXQgLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gdG9nZ2xlLlxuICAgICAqIEBzZWUgQWNjb3JkaW9uLnRvZ2dsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShfdGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50UnVsZSAmJiB0eXBlb2YgdGhpcy5jdXJyZW50UnVsZS50b2dnbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF90aGlzJGN1cnJlbnRSdWxlMztcblxuICAgICAgICByZXR1cm4gKF90aGlzJGN1cnJlbnRSdWxlMyA9IHRoaXMuY3VycmVudFJ1bGUpLnRvZ2dsZS5hcHBseShfdGhpcyRjdXJyZW50UnVsZTMsIFt0aGlzLmN1cnJlbnRQbHVnaW5dLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiB0aGUgY3VycmVudCBwbHVnaW4gb24gdGhpcyBlbGVtZW50LCBhcyB3ZWxsIGFzIHRoZSB3aW5kb3cgcmVzaXplIGhhbmRsZXIgdGhhdCBzd2l0Y2hlcyB0aGUgcGx1Z2lucyBvdXQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4pIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCk7XG4gICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGFuZ2VkWmZNZWRpYVF1ZXJ5SGFuZGxlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzO1xufShQbHVnaW4pO1xuXG5SZXNwb25zaXZlQWNjb3JkaW9uVGFicy5kZWZhdWx0cyA9IHt9O1xuXG5Gb3VuZGF0aW9uLmFkZFRvSnF1ZXJ5KCQpOyAvLyBBZGQgRm91bmRhdGlvbiBVdGlscyB0byBGb3VuZGF0aW9uIGdsb2JhbCBuYW1lc3BhY2UgZm9yIGJhY2t3YXJkc1xuLy8gY29tcGF0aWJpbGl0eS5cblxuRm91bmRhdGlvbi5ydGwgPSBydGw7XG5Gb3VuZGF0aW9uLkdldFlvRGlnaXRzID0gR2V0WW9EaWdpdHM7XG5Gb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQgPSB0cmFuc2l0aW9uZW5kO1xuRm91bmRhdGlvbi5SZWdFeHBFc2NhcGUgPSBSZWdFeHBFc2NhcGU7XG5Gb3VuZGF0aW9uLm9uTG9hZCA9IG9uTG9hZDtcbkZvdW5kYXRpb24uQm94ID0gQm94O1xuRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCA9IG9uSW1hZ2VzTG9hZGVkO1xuRm91bmRhdGlvbi5LZXlib2FyZCA9IEtleWJvYXJkO1xuRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcbkZvdW5kYXRpb24uTW90aW9uID0gTW90aW9uO1xuRm91bmRhdGlvbi5Nb3ZlID0gTW92ZTtcbkZvdW5kYXRpb24uTmVzdCA9IE5lc3Q7XG5Gb3VuZGF0aW9uLlRpbWVyID0gVGltZXI7IC8vIFRvdWNoIGFuZCBUcmlnZ2VycyBwcmV2aW91c2x5IHdlcmUgYWxtb3N0IHB1cmVseSBzZWRlIGVmZmVjdCBkcml2ZW4sXG4vLyBzbyBubyBuZWVkIHRvIGFkZCBpdCB0byBGb3VuZGF0aW9uLCBqdXN0IGluaXQgdGhlbS5cblxuVG91Y2guaW5pdCgkKTtcblRyaWdnZXJzLmluaXQoJCwgRm91bmRhdGlvbik7XG5cbk1lZGlhUXVlcnkuX2luaXQoKTtcblxuRm91bmRhdGlvbi5wbHVnaW4oQWJpZGUsICdBYmlkZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uLCAnQWNjb3JkaW9uJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb25NZW51LCAnQWNjb3JkaW9uTWVudScpO1xuRm91bmRhdGlvbi5wbHVnaW4oRHJpbGxkb3duLCAnRHJpbGxkb3duJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93biwgJ0Ryb3Bkb3duJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93bk1lbnUsICdEcm9wZG93bk1lbnUnKTtcbkZvdW5kYXRpb24ucGx1Z2luKEVxdWFsaXplciwgJ0VxdWFsaXplcicpO1xuRm91bmRhdGlvbi5wbHVnaW4oSW50ZXJjaGFuZ2UsICdJbnRlcmNoYW5nZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oTWFnZWxsYW4sICdNYWdlbGxhbicpO1xuRm91bmRhdGlvbi5wbHVnaW4oT2ZmQ2FudmFzLCAnT2ZmQ2FudmFzJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihPcmJpdCwgJ09yYml0Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlTWVudSwgJ1Jlc3BvbnNpdmVNZW51Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlVG9nZ2xlLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xuRm91bmRhdGlvbi5wbHVnaW4oUmV2ZWFsLCAnUmV2ZWFsJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihTbGlkZXIsICdTbGlkZXInKTtcbkZvdW5kYXRpb24ucGx1Z2luKFNtb290aFNjcm9sbCwgJ1Ntb290aFNjcm9sbCcpO1xuRm91bmRhdGlvbi5wbHVnaW4oU3RpY2t5LCAnU3RpY2t5Jyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihUYWJzLCAnVGFicycpO1xuRm91bmRhdGlvbi5wbHVnaW4oVG9nZ2xlciwgJ1RvZ2dsZXInKTtcbkZvdW5kYXRpb24ucGx1Z2luKFRvb2x0aXAsICdUb29sdGlwJyk7XG5Gb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgJ1Jlc3BvbnNpdmVBY2NvcmRpb25UYWJzJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEZvdW5kYXRpb247XG5leHBvcnQgeyBBYmlkZSwgQWNjb3JkaW9uLCBBY2NvcmRpb25NZW51LCBCb3gsIEZvdW5kYXRpb24gYXMgQ29yZSwgZm91bmRhdGlvbl9jb3JlX3V0aWxzIGFzIENvcmVVdGlscywgRHJpbGxkb3duLCBEcm9wZG93biwgRHJvcGRvd25NZW51LCBFcXVhbGl6ZXIsIEZvdW5kYXRpb24sIEludGVyY2hhbmdlLCBLZXlib2FyZCwgTWFnZWxsYW4sIE1lZGlhUXVlcnksIE1vdGlvbiwgTW92ZSwgTmVzdCwgT2ZmQ2FudmFzLCBPcmJpdCwgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMsIFJlc3BvbnNpdmVNZW51LCBSZXNwb25zaXZlVG9nZ2xlLCBSZXZlYWwsIFNsaWRlciwgU21vb3RoU2Nyb2xsLCBTdGlja3ksIFRhYnMsIFRpbWVyLCBUb2dnbGVyLCBUb29sdGlwLCBUb3VjaCwgVHJpZ2dlcnMsIG9uSW1hZ2VzTG9hZGVkIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3VuZGF0aW9uLmVzbS5qcy5tYXBcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvZm91bmRhdGlvbi5lc20uanMiLCIvLyBTbGljayBTbGlkZXIgZm9yIE1vZHVsZXMgXHJcbmZ1bmN0aW9uIG1vZHVsZVNsaWRlcihtb2R1bGVOYW1lKSB7XHJcblx0Ly8gYWxlcnQobW9kdWxlTkFtZSk7XHJcblx0dmFyICRzbGlkZXIgPSAnLicgKyBtb2R1bGVOYW1lO1xyXG5cdFx0XHJcblx0JCgkc2xpZGVyKS5zbGljayh7XHJcblx0ICAgICBzbGlkZXNUb1Nob3c6IDEsXHJcblx0ICAgICBzbGlkZXNUb1Njcm9sbDogMSxcclxuXHQgICAgIGF1dG9wbGF5OiBmYWxzZSxcclxuXHQgICAgIGF1dG9wbGF5U3BlZWQ6IDIwMDAsXHJcblx0ICAgICBtb2JpbGVGaXJzdDogdHJ1ZSxcclxuXHQgICAgIGFycm93czogZmFsc2UsXHJcblx0ICAgICBkb3RzOiB0cnVlLFxyXG5cdCAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXHJcblx0ICAgICByZXNwb25zaXZlOiBbXHJcblx0ICAgICAgICB7XHJcblx0ICAgICAgICAgICBicmVha3BvaW50OiA2NDAsXHJcblx0ICAgICAgICAgICBzZXR0aW5nczogXCJ1bnNsaWNrXCJcclxuXHQgICAgICAgIH1cclxuXHQgICAgIF1cclxuXHQgIH0pO1xyXG5cdC8vICQoJHNsaWRlcikuc2xpY2soe1xyXG5cdC8vIFx0YXJyb3dzOiBmYWxzZSxcclxuXHQvLyBcdGF1dG9wbGF5OiBmYWxzZSxcclxuXHQvLyBcdGZhZGU6IHRydWUsXHJcblx0Ly8gXHQvLyBsYXp5TG9hZDogJ3Byb2dyZXNzaXZlJyxcclxuXHQvLyBcdHNwZWVkOiAxMDAsXHJcblx0Ly8gXHQvLyBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXHJcblx0Ly8gXHRyZXNwb25zaXZlOiBbXHJcblx0Ly8gXHQgICAge1xyXG5cdC8vIFx0ICAgICAgYnJlYWtwb2ludDogNzY4LFxyXG5cdC8vIFx0ICAgICAgc2V0dGluZ3M6IHtcclxuXHQvLyBcdCAgICAgICAgICBzbGlkZXNUb1Njcm9sbDogMSxcclxuXHQvLyBcdCAgICAgICAgICBhdXRvcGxheTogdHJ1ZSxcclxuXHQvLyBcdCAgICAgICAgICBhdXRvcGxheVNwZWVkOiA1MDAwLFxyXG5cdC8vIFx0ICAgICAgICAgIGZhZGU6IGZhbHNlLFxyXG5cdC8vIFx0ICAgICAgICAgIGRvdHM6IHRydWUsXHJcblx0Ly8gXHQgICAgICAgICAgc3BlZWQ6IDEwMDAsXHJcblx0Ly8gXHQgICAgICAgICAgYWRhcHRpdmVIZWlnaHQ6IHRydWUsXHJcblx0Ly8gXHQgICAgICAgICAgZWFzaW5nOiAnZWFzZUluT3V0U2luZScsXHJcblx0Ly8gXHQgICAgICB9XHJcblx0Ly8gXHQgICAgfVxyXG5cdC8vIFx0ICBdXHJcblx0Ly8gfSk7XHJcblxyXG59XHJcbi8vIEVORCBTTElERVJcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXNzZXRzL2pzL2xpYi9tb2JpbGVfbW9kdWxlX3NsaWRlci5qcyIsIi8qXHJcblJlZmVyZW5jZTogaHR0cDovL2pzZmlkZGxlLm5ldC9CQjNKSy80Ny9cclxuKi9cclxuXHJcbiBcclxuJCgnc2VsZWN0JykuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgdmFyICR0aGlzID0gJCh0aGlzKSwgXHJcbiAgICAgICAgbnVtYmVyT2ZPcHRpb25zID0gJCh0aGlzKS5jaGlsZHJlbignb3B0aW9uJykubGVuZ3RoLFxyXG4gICAgICAgIG5hbWUgPSAkdGhpcy5hdHRyKCduYW1lJyksXHJcbiAgICAgICAgZGF0YV9kZWZhdWx0ID0gJHRoaXMuYXR0cignZGF0YS1kZWZhdWx0JylcclxuICAgICAgICA7XHJcbiAgICB2YXIgc2VsZWN0X2NsYXNzID0gICc8ZGl2IGNsYXNzPVwic2VsZWN0ICcrbmFtZSsnXCI+PC9kaXY+JztcclxuICAgICR0aGlzLmFkZENsYXNzKCdzZWxlY3QtaGlkZGVuJyk7IFxyXG4gICAgJHRoaXMud3JhcChzZWxlY3RfY2xhc3MpO1xyXG4gICAgJHRoaXMuYWZ0ZXIoJzxkaXYgY2xhc3M9XCJzZWxlY3Qtc3R5bGVkXCIgZGF0YS1uYW1lPVwiJytuYW1lKydcIiBkYXRhLWRlZmF1bHQ9XCInK2RhdGFfZGVmYXVsdCsnXCIgZGF0YS1pZD1cIm51bGxcIj48L2Rpdj4nKTtcclxuXHJcbiAgICB2YXIgJHN0eWxlZFNlbGVjdCA9ICR0aGlzLm5leHQoJ2Rpdi5zZWxlY3Qtc3R5bGVkJyk7XHJcbiAgICAkc3R5bGVkU2VsZWN0LnRleHQoJHRoaXMuY2hpbGRyZW4oJ29wdGlvbicpLmVxKDApLnRleHQoKSk7XHJcbiAgXHJcbiAgICB2YXIgJGxpc3QgPSAkKCc8dWwgLz4nLCB7XHJcbiAgICAgICAgJ2NsYXNzJzogJ3NlbGVjdC1vcHRpb25zIG5nLWJpbmRpbmcgbmctc2NvcGUnXHJcbiAgICB9KS5pbnNlcnRBZnRlcigkc3R5bGVkU2VsZWN0KTtcclxuICBcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZPcHRpb25zOyBpKyspIHtcclxuICAgICAgICBsZXQgJGNsYXNzLFxyXG4gICAgICAgICR0aGlzb3B0aW9uID0gJHRoaXMuY2hpbGRyZW4oJ29wdGlvbicpLmVxKGkpO1xyXG4gICAgICAgIGlmICggJHRoaXNvcHRpb25bMF0uaGlkZGVuID09IHRydWUgfHwgICR0aGlzb3B0aW9uWzBdLmRpc2FibGVkID09IHRydWUpe1xyXG4gICAgICAgICAgICAkY2xhc3MgPSAnbmctYmluZGluZyBoaWRlJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAkY2xhc3MgPSAnbmctYmluZGluZyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoJzxsaSAvPicsIHtcclxuICAgICAgICAgICAgLy8gaWYgKCR0aGlzLmNoaWxkcmVuKCdvcHRpb24nKS5lcShpKS5oaWRkZW4gPT0gdHJ1ZSksXHJcbiAgICAgICAgICAgICdjbGFzcyc6ICRjbGFzcyxcclxuICAgICAgICAgICAgdGV4dDogJHRoaXNvcHRpb24udGV4dCgpLFxyXG4gICAgICAgICAgICByZWw6ICR0aGlzb3B0aW9uLnZhbCgpXHJcbiAgICAgICAgfSkuYXBwZW5kVG8oJGxpc3QpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgdmFyICRsaXN0SXRlbXMgPSAkbGlzdC5jaGlsZHJlbignbGknKTtcclxuICBcclxuICAgICRzdHlsZWRTZWxlY3QuY2xpY2soZnVuY3Rpb24oZSkge1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgJCgnZGl2LnNlbGVjdC1zdHlsZWQuYWN0aXZlJykubm90KHRoaXMpLmVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgJCh0aGlzKS5yZW1vdmVDbGFzcygnYWN0aXZlJykubmV4dCgndWwuc2VsZWN0LW9wdGlvbnMnKS5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgJCh0aGlzKS50b2dnbGVDbGFzcygnYWN0aXZlJykubmV4dCgndWwuc2VsZWN0LW9wdGlvbnMnKS50b2dnbGUoKTtcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgJGxpc3RJdGVtcy5jbGljayhmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdmFyIHJlbCA9ICQodGhpcykuYXR0cigncmVsJyk7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAkc3R5bGVkU2VsZWN0LnRleHQoJCh0aGlzKS50ZXh0KCkpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgICAkc3R5bGVkU2VsZWN0LmF0dHIoJ2RhdGEtaWQnLCByZWwpO1xyXG4gICAgICAgICR0aGlzLnZhbCgkKHRoaXMpLmF0dHIoJ3JlbCcpKTtcclxuICAgICAgICBcclxuICAgICAgICAkbGlzdC5oaWRlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gdmFyIHNlbGVjdE5hbWUgPSAkc3R5bGVkU2VsZWN0LmF0dHIoJ2RhdGEtbmFtZScpLFxyXG4gICAgICAgIC8vICAgICBzZWxlY3RWYWwgPSAkdGhpcy52YWwoKTtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzZWxlY3ROYW1lLCBzZWxlY3RWYWwpO1xyXG4gICAgICAgIC8vICQoJyNmaWx0ZXIxIHNlbGVjdFtuYW1lPVwiJytzZWxlY3ROYW1lKydcIl0nKS52YWwoc2VsZWN0VmFsKS50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAkdGhpcy50cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICBcclxuICAgIH0pO1xyXG4gIFxyXG4gICAgJChkb2N1bWVudCkuY2xpY2soZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgJHN0eWxlZFNlbGVjdC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICAgICAgJGxpc3QuaGlkZSgpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCR0aGlzLnZhbCgpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdtZW51IHJlYWR5Jyk7XHJcblxyXG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXNzZXRzL2pzL2xpYi9kcm9wZG93bl9tZW51LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==